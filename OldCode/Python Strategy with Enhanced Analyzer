{"cells":[{"cell_type":"code","source":["import numpy as np\n","import pandas as pd\n","import os\n","import logging\n","import matplotlib.pyplot as plt\n","from typing import Dict, Any, Optional, Tuple, List\n","from pathlib import Path\n","import argparse\n","from datetime import timedelta\n","from collections import defaultdict # Needed for EnhancedSignalAnalyzer\n","import sys # Needed for exit code in main\n","\n","# Initialize logging\n","logging.basicConfig(\n","    level=logging.INFO,\n","    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n","    handlers=[\n","        logging.FileHandler('signals_analyzer_merged.log'), # New log file name\n","        logging.StreamHandler()\n","    ]\n",")\n","logger = logging.getLogger(__name__)\n","\n","# Configuration\n","DATA_FOLDER = Path(\"data\")\n","# Default file names (can be overridden by command line args)\n","DEFAULT_INPUT_FILE = DATA_FOLDER / \"nifty_signals.csv\"\n","DEFAULT_OUTPUT_FILE = DATA_FOLDER / \"nifty_signals_final_analyzer.csv\"\n","DEFAULT_PLOT_FILE = DATA_FOLDER / \"signals_plot_analyzer.png\"\n","\n","# Parameter Organization - Using nested dictionaries (from Script 1)\n","PARAMS: Dict[str, Dict[str, Any]] = {\n","    # --- Backtesting Parameters ---\n","    'backtest': {\n","        # 'initial_capital': 100000, # Analyzer calculates P/L in points/price, not capital based yet\n","        'commission_pct': 0.0005, # Example commission per trade (0.05%)\n","        'slippage_pct': 0.0002,  # Example slippage per trade (0.02%)\n","        'filter_last_month': True # Flag to filter data for last month only\n","    },\n","    'core': {\n","        \"max_trade_duration\": 50,\n","        'exit_score_drop_threshold': 1.5, # Exit if score drops below (5.0 - Threshold) or above (5.0 + Threshold)\n","        'use_score_drop_exit': True,     # Flag to enable/disable score drop exit\n","        'entry_score_threshold': 6.0,     # Minimum scaled score required for any entry signal\n","        'use_fib_bounce_entry': True,\n","        'use_fib_bounce_sell': True,\n","        'fib_bounce_lookback': 3,        # Bars back to check for Fib zone touch\n","        'fib_bounce_long_zone': (0.5, 0.618), # Tuple for low and high fib level for long bounce zone\n","        'fib_bounce_short_zone': (0.382, 0.5),# Tuple for low and high fib level for short bounce zone\n","        'fib_bounce_confirmation_level': 0.5, # Level price needs to cross after bounce\n","        'use_ema_bounce_buy': True,\n","        'use_ema_bounce_sell': True,\n","        'ema_bounce_lookback': 2,\n","        'ema_bounce_source_str': \"Fast EMA\", # \"Fast EMA\" or \"Medium EMA\"\n","        'use_bb_mid_bounce_buy': True,\n","        'use_bb_mid_bounce_sell': True,\n","        'bb_bounce_lookback': 2,\n","        'use_vol_breakout_buy': True,\n","        'use_vol_breakout_sell': True,\n","        'trailing_stop_type': \"atr\",        # \"percentage\" or \"atr\"\n","        'trailing_stop_pct': 0.02,          # Percentage for trailing stop\n","        'trailing_stop_atr_multiplier': 1.5,# ATR multiplier for trailing stop\n","        'profit_protection_levels': {       # Tighten stops after reaching profit levels (based on ATR multiplier)\n","            'level1': {'profit_pct': 0.05, 'new_atr_mult': 1.0},\n","            'level2': {'profit_pct': 0.10, 'new_atr_mult': 0.5}\n","        }\n","    },\n","    'ema': {\n","        'fast_len': 9,\n","        'med_len': 14,\n","        'slow_len': 21,\n","        'use_ema_exit': True              # Use Fast/Med EMA Cross for Exit\n","    },\n","    'bollinger': {\n","        'bb_len': 20,\n","        'bb_std_dev': 2.0,\n","        'use_bb_return_exit': True       # Use BB Return to Mean for Exit\n","    },\n","    'rsi': {\n","        'rsi_len': 14,\n","        'rsi_buy_level': 55.0,            # Threshold for basic RSI condition in score\n","        'rsi_sell_level': 45.0,           # Threshold for basic RSI condition in score\n","        'rsi_confirm_fib': True,          # Require RSI confirmation for Fib Bounce\n","        'rsi_confirm_ema': False,         # Require RSI confirmation for EMA Bounce\n","        'rsi_confirm_bb': False,          # Require RSI confirmation for BB Bounce\n","        'rsi_confirm_level_buy': 40.0,    # RSI must be > this level for bounce confirmation\n","        'rsi_confirm_level_sell': 60.0,   # RSI must be < this level for bounce confirmation\n","        'use_rsi_div_exit': True          # Use RSI Divergence Exit\n","    },\n","    'macd': {\n","        'macd_fast_len': 12,\n","        'macd_slow_len': 26,\n","        'macd_signal_len': 9\n","    },\n","    'volume': {\n","        'vol_ma_len': 50,\n","        'vol_multiplier': 1.5,            # Volume Breakout Multiplier (> MA)\n","        'use_vol_fade_exit': True         # Use Low Volume Pullback Exit\n","    },\n","    'atr': {\n","        'atr_len': 14,\n","        'use_atr_stop': True              # This enables the ATR trailing stop mechanism\n","    },\n","    'fibonacci': {\n","        'use_fib_exit': True,             # Use Fib Extension Exit Target\n","        'fib_lookback_exit': 30,          # Bars back from entry to find swing point for exit target\n","        'fib_extension_level': 1.618,     # Fib Extension Target Level\n","        'fib_pivot_lookback': 15,         # Lookback (left/right) for pivot detection\n","        'fib_max_bars': 200               # Max bars back for pivots\n","    },\n","    'trend': {\n","        'use_ema_trend_filter': True,     # Require EMA Trend (Med > Slow) for entries\n","        'use_adx_filter': True,           # Use ADX Filter for entries\n","        'adx_len': 14,\n","        'adx_threshold': 20.0,            # ADX Trend Strength Threshold (>)\n","        'use_adx_direction_filter': True  # Require ADX Direction (DI+ vs DI-) for entries\n","    },\n","    # --- Score Weights ---\n","    'score_weights': {\n","        'w_ema_trend': 2, 'w_ema_signal': 1, 'w_rsi_thresh': 1,\n","        'w_macd_signal': 1, 'w_macd_zero': 1, 'w_vol_break': 1,\n","        'w_adx_strength': 1, 'w_adx_direction': 1, 'w_fib_bounce': 2,\n","        'w_ema_bounce': 1, 'w_bb_bounce': 1,\n","    }\n","}\n","\n","# --- TradeState Class (from Script 1) ---\n","class TradeState:\n","    \"\"\"Keeps track of the current trade status.\"\"\"\n","    def __init__(self):\n","        self.position = None\n","        self.entry_price = None\n","        self.entry_index = None\n","        self.trailing_stop = None\n","        self.highest_high_in_trade = None\n","        self.lowest_low_in_trade = None\n","        self.time_in_trade = 0\n","\n","    def reset(self):\n","        self.__init__()\n","\n","    def update_trailing_stop(self, current_low, current_high, current_close, atr):\n","        if self.position is None or atr is None or pd.isna(atr) or self.entry_price is None:\n","            return\n","\n","        stop_type = PARAMS['core']['trailing_stop_type']\n","        initial_atr_mult = PARAMS['core']['trailing_stop_atr_multiplier']\n","        stop_pct = PARAMS['core']['trailing_stop_pct']\n","        current_atr_mult = initial_atr_mult\n","\n","        if self.position == 'Long':\n","            if self.highest_high_in_trade is None or current_high > self.highest_high_in_trade:\n","                self.highest_high_in_trade = current_high\n","\n","            profit_pct = (current_close - self.entry_price) / self.entry_price if self.entry_price else 0\n","            for level_name, level_info in sorted(PARAMS['core']['profit_protection_levels'].items()):\n","                if profit_pct >= level_info['profit_pct']:\n","                    current_atr_mult = level_info['new_atr_mult']\n","\n","            if stop_type == \"percentage\":\n","                potential_stop = self.highest_high_in_trade * (1 - stop_pct) if self.highest_high_in_trade else None\n","            else:\n","                potential_stop = self.highest_high_in_trade - (atr * current_atr_mult) if self.highest_high_in_trade else None\n","\n","            if potential_stop is not None and (self.trailing_stop is None or potential_stop > self.trailing_stop):\n","                self.trailing_stop = potential_stop\n","\n","        elif self.position == 'Short':\n","            if self.lowest_low_in_trade is None or current_low < self.lowest_low_in_trade:\n","                self.lowest_low_in_trade = current_low\n","\n","            profit_pct = (self.entry_price - current_close) / self.entry_price if self.entry_price else 0\n","            for level_name, level_info in sorted(PARAMS['core']['profit_protection_levels'].items()):\n","                 if profit_pct >= level_info['profit_pct']:\n","                    current_atr_mult = level_info['new_atr_mult']\n","\n","            if stop_type == \"percentage\":\n","                potential_stop = self.lowest_low_in_trade * (1 + stop_pct) if self.lowest_low_in_trade else None\n","            else:\n","                potential_stop = self.lowest_low_in_trade + (atr * current_atr_mult) if self.lowest_low_in_trade else None\n","\n","            if potential_stop is not None and (self.trailing_stop is None or potential_stop < self.trailing_stop):\n","                self.trailing_stop = potential_stop\n","\n","# --- Indicator/Feature Calculation Functions (from Script 1) ---\n","def calculate_fibonacci_levels(df: pd.DataFrame) -> pd.DataFrame:\n","    logger.info(\"Calculating Fibonacci levels\")\n","    try:\n","        lookback = PARAMS['fibonacci']['fib_pivot_lookback']\n","        max_bars = PARAMS['fibonacci']['fib_max_bars']\n","        df['rolling_high'] = df['high'].rolling(window=2 * lookback + 1, center=True, min_periods=lookback//2+1).max()\n","        df['rolling_low'] = df['low'].rolling(window=2 * lookback + 1, center=True, min_periods=lookback//2+1).min()\n","        df['is_pivot_high'] = df['high'] == df['rolling_high']\n","        df['is_pivot_low'] = df['low'] == df['rolling_low']\n","        df['last_pivot_high_price'] = df.loc[df['is_pivot_high'], 'high'].ffill().shift()\n","        df['last_pivot_high_idx'] = df.loc[df['is_pivot_high']].index.to_series().ffill().shift()\n","        df['last_pivot_low_price'] = df.loc[df['is_pivot_low'], 'low'].ffill().shift()\n","        df['last_pivot_low_idx'] = df.loc[df['is_pivot_low']].index.to_series().ffill().shift()\n","        current_bar_indices = np.arange(len(df))\n","        df['last_pivot_high_idx_num'] = df['last_pivot_high_idx'].apply(lambda x: df.index.get_loc(x) if pd.notna(x) and x in df.index else np.nan)\n","        df['last_pivot_low_idx_num'] = df['last_pivot_low_idx'].apply(lambda x: df.index.get_loc(x) if pd.notna(x) and x in df.index else np.nan)\n","        high_too_old = (current_bar_indices - df['last_pivot_high_idx_num']) > max_bars\n","        low_too_old = (current_bar_indices - df['last_pivot_low_idx_num']) > max_bars\n","        df.loc[high_too_old, ['last_pivot_high_price', 'last_pivot_high_idx', 'last_pivot_high_idx_num']] = np.nan\n","        df.loc[low_too_old, ['last_pivot_low_price', 'last_pivot_low_idx', 'last_pivot_low_idx_num']] = np.nan\n","        df['last_pivot_high_idx_num'].fillna(-1, inplace=True)\n","        df['last_pivot_low_idx_num'].fillna(-1, inplace=True)\n","        is_uptrend_fib = (df['last_pivot_high_idx_num'] > df['last_pivot_low_idx_num'])\n","        swing_high = np.where(is_uptrend_fib, df['last_pivot_high_price'], df['last_pivot_low_price'])\n","        swing_low = np.where(is_uptrend_fib, df['last_pivot_low_price'], df['last_pivot_high_price'])\n","        fib_range = swing_high - swing_low\n","        fib_range[fib_range <= 0] = np.nan\n","        level_0 = np.where(is_uptrend_fib, swing_low, swing_high)\n","        level_100 = np.where(is_uptrend_fib, swing_high, swing_low)\n","        df['fib_0'] = level_0\n","        df['fib_236'] = level_0 + fib_range * 0.236\n","        df['fib_382'] = level_0 + fib_range * 0.382\n","        df['fib_500'] = level_0 + fib_range * 0.500\n","        df['fib_618'] = level_0 + fib_range * 0.618\n","        df['fib_786'] = level_0 + fib_range * 0.786\n","        df['fib_100'] = level_100\n","        df['is_uptrend_fib'] = is_uptrend_fib\n","        df.drop(columns=[ 'rolling_high', 'rolling_low', 'is_pivot_high', 'is_pivot_low', 'last_pivot_high_price', 'last_pivot_high_idx', 'last_pivot_low_price', 'last_pivot_low_idx', 'last_pivot_high_idx_num', 'last_pivot_low_idx_num'], inplace=True, errors='ignore')\n","        logger.info(\"Finished calculating Fibonacci levels\")\n","        return df\n","    except Exception as e:\n","        logger.error(f\"Error in calculate_fibonacci_levels: {str(e)}\", exc_info=True)\n","        raise\n","\n","def calculate_score(df: pd.DataFrame) -> pd.DataFrame:\n","    logger.info(\"Calculating weighted trading score\")\n","    try:\n","        weights = PARAMS['score_weights']\n","        total_possible_score = sum(w for k, w in weights.items() if PARAMS.get(k.split('_')[1], {}).get(f'use_{k.split(\"_\")[1]}', True) or 'use_' not in k) # Rough dynamic total\n","        total_possible_score = max(1, total_possible_score)\n","        df['cond_ema_trend_buy'] = df['ema_med'] > df['ema_slow']\n","        df['cond_ema_trend_sell'] = df['ema_med'] < df['ema_slow']\n","        df['cond_ema_signal_buy'] = (df['ema_fast'] > df['ema_slow']) & (df['ema_fast'].shift() <= df['ema_slow'].shift())\n","        df['cond_ema_signal_sell'] = (df['ema_fast'] < df['ema_slow']) & (df['ema_fast'].shift() >= df['ema_slow'].shift())\n","        df['cond_rsi_buy'] = df['rsi'] > PARAMS['rsi']['rsi_buy_level']\n","        df['cond_rsi_sell'] = df['rsi'] < PARAMS['rsi']['rsi_sell_level']\n","        df['cond_macd_signal_buy'] = (df['macd'] > df['macd_signal']) & (df['macd'].shift() <= df['macd_signal'].shift())\n","        df['cond_macd_signal_sell'] = (df['macd'] < df['macd_signal']) & (df['macd'].shift() >= df['macd_signal'].shift())\n","        df['cond_macd_zero_buy'] = (df['macd'] > 0) & (df['macd'].shift() <= 0)\n","        df['cond_macd_zero_sell'] = (df['macd'] < 0) & (df['macd'].shift() >= 0)\n","        df['cond_vol_break_buy'] = (df['volume'] > df['vol_ma'] * PARAMS['volume']['vol_multiplier']) & (df['close'] > df['open'])\n","        df['cond_vol_break_sell'] = (df['volume'] > df['vol_ma'] * PARAMS['volume']['vol_multiplier']) & (df['close'] < df['open'])\n","        df['cond_adx_strength'] = df['adx'] > PARAMS['trend']['adx_threshold']\n","        df['cond_adx_dir_buy'] = df['plus_di'] > df['minus_di']\n","        df['cond_adx_dir_sell'] = df['minus_di'] > df['plus_di']\n","        df['cond_fib_bounce_buy'] = False; df['cond_fib_bounce_sell'] = False\n","        df['cond_ema_bounce_buy'] = False; df['cond_ema_bounce_sell'] = False\n","        df['cond_bb_bounce_buy'] = False; df['cond_bb_bounce_sell'] = False\n","        buy_score = pd.Series(0.0, index=df.index); sell_score = pd.Series(0.0, index=df.index)\n","        if PARAMS['trend']['use_ema_trend_filter']: buy_score += df['cond_ema_trend_buy'] * weights.get('w_ema_trend', 0); sell_score += df['cond_ema_trend_sell'] * weights.get('w_ema_trend', 0)\n","        buy_score += df['cond_ema_signal_buy'] * weights.get('w_ema_signal', 0); sell_score += df['cond_ema_signal_sell'] * weights.get('w_ema_signal', 0)\n","        buy_score += df['cond_rsi_buy'] * weights.get('w_rsi_thresh', 0); sell_score += df['cond_rsi_sell'] * weights.get('w_rsi_thresh', 0)\n","        buy_score += df['cond_macd_signal_buy'] * weights.get('w_macd_signal', 0); sell_score += df['cond_macd_signal_sell'] * weights.get('w_macd_signal', 0)\n","        buy_score += df['cond_macd_zero_buy'] * weights.get('w_macd_zero', 0); sell_score += df['cond_macd_zero_sell'] * weights.get('w_macd_zero', 0)\n","        if PARAMS['core']['use_vol_breakout_buy'] or PARAMS['core']['use_vol_breakout_sell']: buy_score += df['cond_vol_break_buy'] * weights.get('w_vol_break', 0); sell_score += df['cond_vol_break_sell'] * weights.get('w_vol_break', 0)\n","        if PARAMS['trend']['use_adx_filter']: buy_score += (df['cond_adx_strength'] & df['cond_adx_dir_buy']) * weights.get('w_adx_strength', 0); sell_score += (df['cond_adx_strength'] & df['cond_adx_dir_sell']) * weights.get('w_adx_strength', 0)\n","        if PARAMS['trend']['use_adx_direction_filter']: buy_score += df['cond_adx_dir_buy'] * weights.get('w_adx_direction', 0); sell_score += df['cond_adx_dir_sell'] * weights.get('w_adx_direction', 0)\n","        df['buy_score_raw'] = buy_score; df['sell_score_raw'] = sell_score\n","        df['scaled_score'] = 5.0\n","        logger.info(\"Finished initial score calculation\")\n","        return df\n","    except Exception as e:\n","        logger.error(f\"Error in calculate_score: {str(e)}\", exc_info=True)\n","        raise\n","\n","def calculate_rsi_divergence(df: pd.DataFrame, lookback: int = 14) -> pd.DataFrame:\n","    logger.info(f\"Calculating RSI divergence with lookback {lookback}\")\n","    try:\n","        df['bullish_rsi_div'] = False; df['bearish_rsi_div'] = False\n","        df['price_low_roll'] = df['low'].rolling(window=lookback, closed='left').min()\n","        df['rsi_low_roll'] = df['rsi'].rolling(window=lookback, closed='left').min()\n","        df['price_high_roll'] = df['high'].rolling(window=lookback, closed='left').max()\n","        df['rsi_high_roll'] = df['rsi'].rolling(window=lookback, closed='left').max()\n","        df['bullish_rsi_div'] = (df['low'] < df['price_low_roll']) & (df['rsi'] > df['rsi_low_roll'])\n","        df['bearish_rsi_div'] = (df['high'] > df['price_high_roll']) & (df['rsi'] < df['rsi_high_roll'])\n","        df.drop(columns=['price_low_roll', 'rsi_low_roll', 'price_high_roll', 'rsi_high_roll'], inplace=True, errors='ignore')\n","        logger.info(\"Finished calculating RSI divergence\")\n","        return df\n","    except Exception as e:\n","        logger.error(f\"Error in calculate_rsi_divergence: {str(e)}\", exc_info=True)\n","        raise\n","\n","def calculate_targets_for_trade(df: pd.DataFrame, entry_idx: int, position: str, entry_price: float, initial_stop: float) -> pd.DataFrame:\n","    try:\n","        current_idx = df.index[entry_idx]\n","        atr = df.loc[current_idx, 'atr']\n","        fib_lookback = PARAMS['fibonacci']['fib_lookback_exit']\n","        fib_ext_level = PARAMS['fibonacci']['fib_extension_level']\n","        use_fib_target = PARAMS['fibonacci']['use_fib_exit']\n","        atr_mult_target = PARAMS['atr'].get('atr_mult', 2.0) # Use .get with default\n","\n","        if pd.isna(atr) or pd.isna(entry_price) or pd.isna(initial_stop):\n","            logger.warning(f\"Cannot calculate targets for trade at index {entry_idx} due to NaN inputs.\")\n","            return df\n","\n","        if position == 'Long':\n","            atr_target = entry_price + (atr * atr_mult_target)\n","            risk = entry_price - initial_stop\n","            rr_target = entry_price + (risk * 2) if risk > 0 else np.nan\n","            fib_target = np.nan\n","            if use_fib_target:\n","                lookback_start = max(0, entry_idx - fib_lookback)\n","                swing_low_series = df['low'].iloc[lookback_start : entry_idx]\n","                if not swing_low_series.empty:\n","                    swing_low_price = swing_low_series.min()\n","                    swing_range = entry_price - swing_low_price\n","                    if swing_range > 0: fib_target = entry_price + (swing_range * fib_ext_level)\n","            df.loc[current_idx:, 'fib_target_long'] = fib_target\n","            valid_targets = [t for t in [atr_target, rr_target, fib_target] if pd.notna(t)]\n","            if valid_targets: df.loc[current_idx:, 'target_price_long'] = min(valid_targets)\n","\n","        elif position == 'Short':\n","            atr_target = entry_price - (atr * atr_mult_target)\n","            risk = initial_stop - entry_price\n","            rr_target = entry_price - (risk * 2) if risk > 0 else np.nan\n","            fib_target = np.nan\n","            if use_fib_target:\n","                lookback_start = max(0, entry_idx - fib_lookback)\n","                swing_high_series = df['high'].iloc[lookback_start : entry_idx]\n","                if not swing_high_series.empty:\n","                    swing_high_price = swing_high_series.max()\n","                    swing_range = swing_high_price - entry_price\n","                    if swing_range > 0: fib_target = entry_price - (swing_range * fib_ext_level)\n","            df.loc[current_idx:, 'fib_target_short'] = fib_target\n","            valid_targets = [t for t in [atr_target, rr_target, fib_target] if pd.notna(t)]\n","            if valid_targets: df.loc[current_idx:, 'target_price_short'] = max(valid_targets)\n","\n","        return df\n","    except Exception as e:\n","        logger.error(f\"Error calculating targets for trade at index {entry_idx}: {str(e)}\", exc_info=True)\n","        return df\n","\n","# --- Main Signal Processing Function (from Script 1) ---\n","def process_signals(df: pd.DataFrame) -> pd.DataFrame:\n","    logger.info(\"Starting enhanced signal processing\")\n","    try:\n","        # --- Indicator Calculations ---\n","        logger.info(\"Calculating base indicators\")\n","        df['ema_fast'] = df['close'].ewm(span=PARAMS['ema']['fast_len'], adjust=False).mean()\n","        df['ema_med'] = df['close'].ewm(span=PARAMS['ema']['med_len'], adjust=False).mean()\n","        df['ema_slow'] = df['close'].ewm(span=PARAMS['ema']['slow_len'], adjust=False).mean()\n","        df['bb_middle'] = df['close'].rolling(PARAMS['bollinger']['bb_len']).mean()\n","        rolling_std = df['close'].rolling(PARAMS['bollinger']['bb_len']).std()\n","        df['bb_upper'] = df['bb_middle'] + rolling_std * PARAMS['bollinger']['bb_std_dev']\n","        df['bb_lower'] = df['bb_middle'] - rolling_std * PARAMS['bollinger']['bb_std_dev']\n","        delta = df['close'].diff()\n","        gain = delta.where(delta > 0, 0.0); loss = -delta.where(delta < 0, 0.0)\n","        avg_gain = gain.ewm(alpha=1/PARAMS['rsi']['rsi_len'], adjust=False).mean()\n","        avg_loss = loss.ewm(alpha=1/PARAMS['rsi']['rsi_len'], adjust=False).mean()\n","        rs = avg_gain / avg_loss.replace(0, 1e-6)\n","        df['rsi'] = 100.0 - (100.0 / (1.0 + rs)); df['rsi'].fillna(50, inplace=True)\n","        ema_fast_macd = df['close'].ewm(span=PARAMS['macd']['macd_fast_len'], adjust=False).mean()\n","        ema_slow_macd = df['close'].ewm(span=PARAMS['macd']['macd_slow_len'], adjust=False).mean()\n","        df['macd'] = ema_fast_macd - ema_slow_macd\n","        df['macd_signal'] = df['macd'].ewm(span=PARAMS['macd']['macd_signal_len'], adjust=False).mean()\n","        df['macd_hist'] = df['macd'] - df['macd_signal']\n","        df['vol_ma'] = df['volume'].rolling(PARAMS['volume']['vol_ma_len']).mean()\n","        high_low = df['high'] - df['low']; high_close_prev = abs(df['high'] - df['close'].shift()); low_close_prev = abs(df['low'] - df['close'].shift())\n","        tr = pd.concat([high_low, high_close_prev, low_close_prev], axis=1).max(axis=1)\n","        df['atr'] = tr.ewm(alpha=1/PARAMS['atr']['atr_len'], adjust=False).mean()\n","        if PARAMS['trend']['use_adx_filter'] or PARAMS['trend']['use_adx_direction_filter']:\n","            adx_len = PARAMS['trend']['adx_len']; up_move = df['high'].diff(); down_move = -df['low'].diff()\n","            plus_dm = ((up_move > down_move) & (up_move > 0)) * up_move; minus_dm = ((down_move > up_move) & (down_move > 0)) * down_move\n","            plus_dm.fillna(0, inplace=True); minus_dm.fillna(0, inplace=True)\n","            tr_smoothed = tr.ewm(alpha=1/adx_len, adjust=False).mean().replace(0, 1e-6)\n","            smooth_plus_dm = plus_dm.ewm(alpha=1/adx_len, adjust=False).mean(); smooth_minus_dm = minus_dm.ewm(alpha=1/adx_len, adjust=False).mean()\n","            df['plus_di'] = 100 * (smooth_plus_dm / tr_smoothed); df['minus_di'] = 100 * (smooth_minus_dm / tr_smoothed)\n","            di_sum = (df['plus_di'] + df['minus_di']).replace(0, 1e-6); dx = 100 * (abs(df['plus_di'] - df['minus_di']) / di_sum)\n","            df['adx'] = dx.ewm(alpha=1/adx_len, adjust=False).mean(); df.fillna({'adx': 0, 'plus_di': 0, 'minus_di': 0}, inplace=True)\n","        else:\n","            df['plus_di'] = 0.0; df['minus_di'] = 0.0; df['adx'] = 0.0\n","\n","        df = calculate_fibonacci_levels(df)\n","        df = calculate_score(df)\n","        df = calculate_rsi_divergence(df, lookback=PARAMS['rsi']['rsi_len'])\n","\n","        # --- Initialize Signal Columns ---\n","        df['signal'] = 'Hold'; df['position'] = ''; df['entry_price'] = np.nan\n","        df['stop_loss'] = np.nan; df['trailing_stop'] = np.nan; df['exit_price'] = np.nan\n","        df['exit_reason'] = ''; df['entry_signal_type'] = ''\n","        df['target_price_long'] = np.nan; df['target_price_short'] = np.nan # Initialize target columns\n","        df['fib_target_long'] = np.nan; df['fib_target_short'] = np.nan\n","\n","        start_index = max( PARAMS['ema']['slow_len'], PARAMS['bollinger']['bb_len'], PARAMS['rsi']['rsi_len'], PARAMS['macd']['macd_slow_len'], PARAMS['volume']['vol_ma_len'], PARAMS['atr']['atr_len'], (PARAMS['trend']['adx_len'] * 2) if (PARAMS['trend']['use_adx_filter'] or PARAMS['trend']['use_adx_direction_filter']) else 0, (PARAMS['fibonacci']['fib_pivot_lookback'] * 2 + 1), PARAMS['fibonacci']['fib_lookback_exit'], PARAMS['core']['fib_bounce_lookback'], PARAMS['core']['ema_bounce_lookback'], PARAMS['core']['bb_bounce_lookback'] ) + 1\n","\n","        if start_index >= len(df):\n","             logger.warning(f\"Not enough data. Required: {start_index}, Available: {len(df)}\")\n","             return df # Return early if not enough data\n","\n","        logger.info(f\"Starting main processing loop from index {start_index}\")\n","        trade_state = TradeState()\n","        weights = PARAMS['score_weights']\n","        total_possible_score = max(1, sum(weights.values())) # Simplification\n","\n","        for i in range(start_index, len(df)):\n","            current_idx = df.index[i]; prev_idx = df.index[i-1]\n","            current = df.iloc[i]; prev = df.iloc[i-1]\n","            exit_triggered_this_bar = False; exit_price_this_bar = np.nan\n","\n","            # --- I. Check for Exits ---\n","            if trade_state.position is not None:\n","                trade_state.time_in_trade += 1\n","                trade_state.update_trailing_stop(current['low'], current['high'], current['close'], current['atr'])\n","                df.loc[current_idx, 'trailing_stop'] = trade_state.trailing_stop\n","                potential_exit_price = current['close']\n","\n","                # Exit Priority: SL > Div > Target > Score > EMA > BB > Vol > Time\n","                if PARAMS['atr']['use_atr_stop'] and trade_state.trailing_stop is not None:\n","                    if trade_state.position == 'Long' and current['low'] <= trade_state.trailing_stop: exit_reason='Trailing Stop'; exit_price_this_bar = min(current['open'], trade_state.trailing_stop); exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and current['high'] >= trade_state.trailing_stop: exit_reason='Trailing Stop'; exit_price_this_bar = max(current['open'], trade_state.trailing_stop); exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['rsi']['use_rsi_div_exit']:\n","                    if trade_state.position == 'Long' and current['bearish_rsi_div']: exit_reason='RSI Div'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and current['bullish_rsi_div']: exit_reason='RSI Div'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['fibonacci']['use_fib_exit']:\n","                    fib_target_long = df.loc[current_idx, 'fib_target_long']; fib_target_short = df.loc[current_idx, 'fib_target_short']\n","                    if trade_state.position == 'Long' and pd.notna(fib_target_long) and current['high'] >= fib_target_long: exit_reason='Fib Target'; exit_price_this_bar = max(current['open'], fib_target_long); exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and pd.notna(fib_target_short) and current['low'] <= fib_target_short: exit_reason='Fib Target'; exit_price_this_bar = min(current['open'], fib_target_short); exit_triggered_this_bar = True\n","                # Recalculate score for exit check\n","                buy_score_bar_exit = df.loc[current_idx, 'buy_score_raw']; sell_score_bar_exit = df.loc[current_idx, 'sell_score_raw']\n","                if df.loc[current_idx, 'cond_fib_bounce_buy']: buy_score_bar_exit += weights.get('w_fib_bounce', 0); # Add bounce scores if flags were set (in entry logic)\n","                if df.loc[current_idx, 'cond_fib_bounce_sell']: sell_score_bar_exit += weights.get('w_fib_bounce', 0); # etc...\n","                if df.loc[current_idx, 'cond_ema_bounce_buy']: buy_score_bar_exit += weights.get('w_ema_bounce', 0)\n","                if df.loc[current_idx, 'cond_ema_bounce_sell']: sell_score_bar_exit += weights.get('w_ema_bounce', 0)\n","                if df.loc[current_idx, 'cond_bb_bounce_buy']: buy_score_bar_exit += weights.get('w_bb_bounce', 0)\n","                if df.loc[current_idx, 'cond_bb_bounce_sell']: sell_score_bar_exit += weights.get('w_bb_bounce', 0)\n","                net_score_bar_exit = buy_score_bar_exit - sell_score_bar_exit; scaled_score_bar_exit = max(0.0, min(10.0, ((net_score_bar_exit / total_possible_score) * 5.0) + 5.0))\n","                df.loc[current_idx, 'scaled_score'] = scaled_score_bar_exit # Update final score regardless of exit\n","                if not exit_triggered_this_bar and PARAMS['core']['use_score_drop_exit']:\n","                    score_threshold = PARAMS['core']['exit_score_drop_threshold']\n","                    if trade_state.position == 'Long' and scaled_score_bar_exit < (5.0 - score_threshold): exit_reason=f'Score Drop ({scaled_score_bar_exit:.1f})'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and scaled_score_bar_exit > (5.0 + score_threshold): exit_reason=f'Score Drop ({scaled_score_bar_exit:.1f})'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['ema']['use_ema_exit']:\n","                    fast_ema_cross_med_sell = current['ema_fast'] < current['ema_med'] and prev['ema_fast'] >= prev['ema_med']; fast_ema_cross_med_buy = current['ema_fast'] > current['ema_med'] and prev['ema_fast'] <= prev['ema_med']\n","                    if trade_state.position == 'Long' and fast_ema_cross_med_sell: exit_reason='EMA Cross'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and fast_ema_cross_med_buy: exit_reason='EMA Cross'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['bollinger']['use_bb_return_exit']:\n","                    cross_under_bb_mid = current['close'] < current['bb_middle'] and prev['close'] >= prev['bb_middle']; cross_over_bb_mid = current['close'] > current['bb_middle'] and prev['close'] <= prev['bb_middle']\n","                    if trade_state.position == 'Long' and cross_under_bb_mid: exit_reason='BB Mid Exit'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and cross_over_bb_mid: exit_reason='BB Mid Exit'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['volume']['use_vol_fade_exit']:\n","                    low_vol = current['volume'] < df.loc[prev_idx, 'vol_ma']; pullback_long = current['close'] < current['ema_fast']; pullback_short = current['close'] > current['ema_fast']\n","                    if trade_state.position == 'Long' and low_vol and pullback_long: exit_reason='Vol Fade'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and low_vol and pullback_short: exit_reason='Vol Fade'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and trade_state.time_in_trade >= PARAMS['core']['max_trade_duration']: exit_reason='Time Exit'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","\n","                if exit_triggered_this_bar:\n","                    signal_prefix = 'Exit Long' if trade_state.position == 'Long' else 'Exit Short'\n","                    df.loc[current_idx, 'signal'] = signal_prefix\n","                    df.loc[current_idx, 'exit_reason'] = exit_reason\n","                    df.loc[current_idx, 'exit_price'] = exit_price_this_bar\n","                    trade_state.reset()\n","                    df.loc[current_idx:, ['target_price_long', 'target_price_short', 'fib_target_long', 'fib_target_short']] = np.nan\n","\n","            # --- II. Check for Entries ---\n","            if trade_state.position is None and not exit_triggered_this_bar:\n","                entry_signal = None; buy_score_bar = df.loc[current_idx, 'buy_score_raw']; sell_score_bar = df.loc[current_idx, 'sell_score_raw']\n","                df.loc[current_idx, ['cond_fib_bounce_buy', 'cond_fib_bounce_sell','cond_ema_bounce_buy', 'cond_ema_bounce_sell','cond_bb_bounce_buy', 'cond_bb_bounce_sell']] = False # Reset flags\n","\n","                # Calculate bounce/breakout conditions & update score\n","                fib_bounce_buy_cond = False; fib_bounce_sell_cond = False\n","                if PARAMS['core']['use_fib_bounce_entry'] or PARAMS['core']['use_fib_bounce_sell']:\n","                    lookback=PARAMS['core']['fib_bounce_lookback']; low_zone_long, high_zone_long = PARAMS['core']['fib_bounce_long_zone']; low_zone_short, high_zone_short = PARAMS['core']['fib_bounce_short_zone']; conf_level = PARAMS['core']['fib_bounce_confirmation_level']; rsi_conf = PARAMS['rsi']['rsi_confirm_fib']; rsi_buy_lvl, rsi_sell_lvl = PARAMS['rsi']['rsi_confirm_level_buy'], PARAMS['rsi']['rsi_confirm_level_sell']\n","                    if PARAMS['core']['use_fib_bounce_entry'] and current['is_uptrend_fib']:\n","                        fib_low_name = f'fib_{int(low_zone_long*1000)}'; fib_high_name = f'fib_{int(high_zone_long*1000)}'; fib_conf_name = f'fib_{int(conf_level*1000)}'\n","                        if fib_low_name in df.columns and fib_high_name in df.columns and fib_conf_name in df.columns:\n","                            fib_low = current[fib_low_name]; fib_high = current[fib_high_name]; fib_conf = current[fib_conf_name]\n","                            if pd.notna(fib_low) and pd.notna(fib_high) and pd.notna(fib_conf):\n","                                touched_zone = (df['low'].iloc[i-lookback:i] <= fib_high).any(); bounced_above = current['close'] > fib_conf; rsi_ok = not rsi_conf or (current['rsi'] > rsi_buy_lvl and current['rsi'] > prev['rsi'])\n","                                if touched_zone and bounced_above and rsi_ok: fib_bounce_buy_cond = True; df.loc[current_idx, 'cond_fib_bounce_buy'] = True; buy_score_bar += weights.get('w_fib_bounce', 0)\n","                    if PARAMS['core']['use_fib_bounce_sell'] and not current['is_uptrend_fib']:\n","                        fib_low_name = f'fib_{int(low_zone_short*1000)}'; fib_high_name = f'fib_{int(high_zone_short*1000)}'; fib_conf_name = f'fib_{int(conf_level*1000)}'\n","                        if fib_low_name in df.columns and fib_high_name in df.columns and fib_conf_name in df.columns:\n","                            fib_low = current[fib_low_name]; fib_high = current[fib_high_name]; fib_conf = current[fib_conf_name]\n","                            if pd.notna(fib_low) and pd.notna(fib_high) and pd.notna(fib_conf):\n","                                touched_zone = (df['high'].iloc[i-lookback:i] >= fib_low).any(); bounced_below = current['close'] < fib_conf; rsi_ok = not rsi_conf or (current['rsi'] < rsi_sell_lvl and current['rsi'] < prev['rsi'])\n","                                if touched_zone and bounced_below and rsi_ok: fib_bounce_sell_cond = True; df.loc[current_idx, 'cond_fib_bounce_sell'] = True; sell_score_bar += weights.get('w_fib_bounce', 0)\n","                ema_bounce_buy_cond = False; ema_bounce_sell_cond = False\n","                if PARAMS['core']['use_ema_bounce_buy'] or PARAMS['core']['use_ema_bounce_sell']:\n","                    lookback=PARAMS['core']['ema_bounce_lookback']; ema_source_col = 'ema_fast' if PARAMS['core']['ema_bounce_source_str'] == \"Fast EMA\" else 'ema_med'; ema_source = df[ema_source_col]; rsi_conf = PARAMS['rsi']['rsi_confirm_ema']; rsi_buy_lvl, rsi_sell_lvl = PARAMS['rsi']['rsi_confirm_level_buy'], PARAMS['rsi']['rsi_confirm_level_sell']\n","                    if PARAMS['core']['use_ema_bounce_buy']:\n","                         touched_ema = (df['low'].iloc[i-lookback:i] <= ema_source.iloc[i-lookback:i]).any(); bounced_above = current['close'] > current[ema_source_col] and current['close'] > current['open']; rsi_ok = not rsi_conf or (current['rsi'] > rsi_buy_lvl and current['rsi'] > prev['rsi'])\n","                         if touched_ema and bounced_above and rsi_ok: ema_bounce_buy_cond = True; df.loc[current_idx, 'cond_ema_bounce_buy'] = True; buy_score_bar += weights.get('w_ema_bounce', 0)\n","                    if PARAMS['core']['use_ema_bounce_sell']:\n","                        touched_ema = (df['high'].iloc[i-lookback:i] >= ema_source.iloc[i-lookback:i]).any(); bounced_below = current['close'] < current[ema_source_col] and current['close'] < current['open']; rsi_ok = not rsi_conf or (current['rsi'] < rsi_sell_lvl and current['rsi'] < prev['rsi'])\n","                        if touched_ema and bounced_below and rsi_ok: ema_bounce_sell_cond = True; df.loc[current_idx, 'cond_ema_bounce_sell'] = True; sell_score_bar += weights.get('w_ema_bounce', 0)\n","                bb_bounce_buy_cond = False; bb_bounce_sell_cond = False\n","                if PARAMS['core']['use_bb_mid_bounce_buy'] or PARAMS['core']['use_bb_mid_bounce_sell']:\n","                    lookback=PARAMS['core']['bb_bounce_lookback']; bb_mid = df['bb_middle']; rsi_conf = PARAMS['rsi']['rsi_confirm_bb']; rsi_buy_lvl, rsi_sell_lvl = PARAMS['rsi']['rsi_confirm_level_buy'], PARAMS['rsi']['rsi_confirm_level_sell']\n","                    if PARAMS['core']['use_bb_mid_bounce_buy']:\n","                        touched_bb = (df['low'].iloc[i-lookback:i] <= bb_mid.iloc[i-lookback:i]).any(); bounced_above = current['close'] > current['bb_middle'] and current['close'] > current['open']; rsi_ok = not rsi_conf or (current['rsi'] > rsi_buy_lvl and current['rsi'] > prev['rsi'])\n","                        if touched_bb and bounced_above and rsi_ok: bb_bounce_buy_cond = True; df.loc[current_idx, 'cond_bb_bounce_buy'] = True; buy_score_bar += weights.get('w_bb_bounce', 0)\n","                    if PARAMS['core']['use_bb_mid_bounce_sell']:\n","                        touched_bb = (df['high'].iloc[i-lookback:i] >= bb_mid.iloc[i-lookback:i]).any(); bounced_below = current['close'] < current['bb_middle'] and current['close'] < current['open']; rsi_ok = not rsi_conf or (current['rsi'] < rsi_sell_lvl and current['rsi'] < prev['rsi'])\n","                        if touched_bb and bounced_below and rsi_ok: bb_bounce_sell_cond = True; df.loc[current_idx, 'cond_bb_bounce_sell'] = True; sell_score_bar += weights.get('w_bb_bounce', 0)\n","                vol_breakout_buy_cond = False; vol_breakout_sell_cond = False\n","                if PARAMS['core']['use_vol_breakout_buy'] or PARAMS['core']['use_vol_breakout_sell']:\n","                    high_vol = current['volume'] > current['vol_ma'] * PARAMS['volume']['vol_multiplier']; lookback_pa = 5\n","                    if i >= lookback_pa: recent_high = df['high'].iloc[i-lookback_pa:i].max(); recent_low = df['low'].iloc[i-lookback_pa:i].min()\n","                    else: recent_high = np.nan; recent_low = np.nan\n","                    if pd.notna(recent_high) and PARAMS['core']['use_vol_breakout_buy'] and high_vol and current['close'] > current['open'] and current['close'] > recent_high: vol_breakout_buy_cond = True\n","                    if pd.notna(recent_low) and PARAMS['core']['use_vol_breakout_sell'] and high_vol and current['close'] < current['open'] and current['close'] < recent_low: vol_breakout_sell_cond = True\n","\n","                # Final score calculation for the bar\n","                net_score_bar = buy_score_bar - sell_score_bar\n","                current_total_possible = sum(w for k, w in weights.items() if df.loc[current_idx, f'cond_{k.split(\"_\")[1]}_{k.split(\"_\")[-1]}'] or 'bounce' not in k) # Dynamic total based on active conditions\n","                safe_total_score = max(1, current_total_possible if current_total_possible > 0 else total_possible_score) # Use dynamic total if available\n","                scaled_score_bar = max(0.0, min(10.0, ((net_score_bar / safe_total_score) * 5.0) + 5.0))\n","                df.loc[current_idx, 'scaled_score'] = scaled_score_bar\n","\n","                # Trend Filters\n","                trend_ok_buy = True; trend_ok_sell = True\n","                if PARAMS['trend']['use_ema_trend_filter']: trend_ok_buy &= current['cond_ema_trend_buy']; trend_ok_sell &= current['cond_ema_trend_sell']\n","                if PARAMS['trend']['use_adx_filter']: trend_ok_buy &= current['cond_adx_strength']; trend_ok_sell &= current['cond_adx_strength']\n","                if PARAMS['trend']['use_adx_direction_filter']: trend_ok_buy &= current['cond_adx_dir_buy']; trend_ok_sell &= current['cond_adx_dir_sell']\n","\n","                # Entry Decision\n","                entry_score_threshold = PARAMS['core']['entry_score_threshold']\n","                if trend_ok_buy and scaled_score_bar >= entry_score_threshold:\n","                    if fib_bounce_buy_cond: entry_signal = \"Fib Bounce Long\"\n","                    elif ema_bounce_buy_cond: entry_signal = \"EMA Bounce Long\"\n","                    elif bb_bounce_buy_cond: entry_signal = \"BB Bounce Long\"\n","                    elif vol_breakout_buy_cond: entry_signal = \"Vol Breakout Long\"\n","                    elif df.loc[current_idx,'cond_ema_signal_buy'] and df.loc[current_idx,'cond_rsi_buy']: entry_signal = \"Basic Long\"\n","                elif trend_ok_sell and scaled_score_bar <= (10.0 - entry_score_threshold):\n","                    if fib_bounce_sell_cond: entry_signal = \"Fib Bounce Short\"\n","                    elif ema_bounce_sell_cond: entry_signal = \"EMA Bounce Short\"\n","                    elif bb_bounce_sell_cond: entry_signal = \"BB Bounce Short\"\n","                    elif vol_breakout_sell_cond: entry_signal = \"Vol Breakout Short\"\n","                    elif df.loc[current_idx,'cond_ema_signal_sell'] and df.loc[current_idx,'cond_rsi_sell']: entry_signal = \"Basic Short\"\n","\n","                # Process Entry\n","                if entry_signal:\n","                    entry_price_adj = current['close'] * (1 + PARAMS['backtest']['slippage_pct']) if \"Long\" in entry_signal else current['close'] * (1 - PARAMS['backtest']['slippage_pct'])\n","                    trade_state.entry_price = entry_price_adj; trade_state.entry_index = i; trade_state.time_in_trade = 0\n","                    if \"Long\" in entry_signal:\n","                        trade_state.position = 'Long'; trade_state.highest_high_in_trade = current['high']\n","                        initial_stop = current['low'] - current['atr'] * PARAMS['core']['trailing_stop_atr_multiplier']\n","                        trade_state.trailing_stop = initial_stop; df.loc[current_idx, 'signal'] = 'Long'; df.loc[current_idx, 'stop_loss'] = initial_stop\n","                    elif \"Short\" in entry_signal:\n","                        trade_state.position = 'Short'; trade_state.lowest_low_in_trade = current['low']\n","                        initial_stop = current['high'] + current['atr'] * PARAMS['core']['trailing_stop_atr_multiplier']\n","                        trade_state.trailing_stop = initial_stop; df.loc[current_idx, 'signal'] = 'Short'; df.loc[current_idx, 'stop_loss'] = initial_stop\n","                    df.loc[current_idx, 'position'] = trade_state.position; df.loc[current_idx, 'entry_price'] = trade_state.entry_price\n","                    df.loc[current_idx, 'entry_signal_type'] = entry_signal; df.loc[current_idx, 'trailing_stop'] = trade_state.trailing_stop\n","                    df = calculate_targets_for_trade(df, i, trade_state.position, trade_state.entry_price, initial_stop)\n","\n","            # --- III. Update Position State ---\n","            if trade_state.position is not None and df.loc[current_idx, 'signal'] == 'Hold':\n","                df.loc[current_idx, 'position'] = trade_state.position\n","                df.loc[current_idx, 'entry_price'] = trade_state.entry_price\n","\n","        logger.info(\"Finished main processing loop\")\n","        return df\n","    except Exception as e:\n","        logger.error(f\"Error in process_signals: {str(e)}\", exc_info=True)\n","        raise\n","\n","# --- EnhancedSignalAnalyzer Class (from Script 2 - Adapted) ---\n","class EnhancedSignalAnalyzer:\n","    def __init__(self):\n","        self.trade_history = []\n","        self.summary_stats = defaultdict(float) # Use defaultdict for easier summing\n","        self.entry_stats = defaultdict(lambda: defaultdict(float))\n","        self.exit_stats = defaultdict(lambda: defaultdict(float))\n","        self.signal_stats = defaultdict(lambda: defaultdict(float))\n","\n","    def analyze_trades(self, df: pd.DataFrame):\n","        \"\"\"Analyzes trades from a DataFrame processed by process_signals.\"\"\"\n","        logger.info(\"Analyzing generated trades for detailed statistics\")\n","        try:\n","            self.trade_history = [] # Reset history\n","            current_trade = None\n","            running_pnl = 0.0\n","            peak_pnl = 0.0\n","            max_drawdown = 0.0\n","            win_pnls = []; loss_pnls = []\n","            win_durations = []; loss_durations = []\n","            risk_rewards = []\n","            current_streak = 0; max_consec_wins = 0; max_consec_losses = 0\n","            current_streak_type = None\n","\n","            # Iterate through DataFrame to identify trades\n","            for i in range(len(df)):\n","                current_idx = df.index[i]\n","                signal = df.loc[current_idx, 'signal']\n","\n","                # Entry Signal Found\n","                if signal in ['Long', 'Short'] and current_trade is None:\n","                    entry_price = df.loc[current_idx, 'entry_price']\n","                    stop_loss = df.loc[current_idx, 'stop_loss']\n","                    target_price_col = 'target_price_long' if signal == 'Long' else 'target_price_short'\n","                    target_price = df.loc[current_idx, target_price_col] # Get target set at entry\n","\n","                    if pd.notna(entry_price) and pd.notna(stop_loss):\n","                        current_trade = {\n","                            'entry_index': i,\n","                            'entry_idx_time': current_idx,\n","                            'entry_price': entry_price,\n","                            'position': signal,\n","                            'stop_loss': stop_loss,\n","                            'target_price': target_price, # Store potential target\n","                            'signal_type': df.loc[current_idx, 'entry_signal_type']\n","                        }\n","                        # Calculate risk/reward ratio at entry\n","                        if current_trade['position'] == 'Long':\n","                            risk = current_trade['entry_price'] - current_trade['stop_loss']\n","                            reward = current_trade['target_price'] - current_trade['entry_price'] if pd.notna(current_trade['target_price']) else np.nan\n","                        else: # Short\n","                            risk = current_trade['stop_loss'] - current_trade['entry_price']\n","                            reward = current_trade['entry_price'] - current_trade['target_price'] if pd.notna(current_trade['target_price']) else np.nan\n","\n","                        current_trade['risk_at_entry'] = risk\n","                        current_trade['reward_at_entry'] = reward\n","                        current_trade['risk_reward_ratio'] = reward / risk if risk > 0 and pd.notna(reward) else np.nan\n","\n","                # Exit Signal Found\n","                elif current_trade and 'Exit' in signal:\n","                    exit_price = df.loc[current_idx, 'exit_price']\n","                    exit_idx_time = current_idx\n","                    exit_reason = df.loc[current_idx, 'exit_reason']\n","\n","                    if pd.isna(exit_price): # Fallback if exit price missing\n","                        exit_price = df.loc[current_idx, 'close']\n","                        logger.warning(f\"Exit price NaN for trade entered on {current_trade['entry_idx_time'].date()}, using close price {exit_price:.2f}\")\n","\n","                    # Calculate P/L (Points) - Costs applied later if needed\n","                    if current_trade['position'] == 'Long':\n","                        pnl_points = exit_price - current_trade['entry_price']\n","                    else: # Short\n","                        pnl_points = current_trade['entry_price'] - exit_price\n","\n","                    # Apply simple commission/slippage (as points approx)\n","                    # Note: This is simplified. Real calculation needs position size.\n","                    commission = (current_trade['entry_price'] + exit_price) * PARAMS['backtest']['commission_pct']\n","                    # Slippage already applied in process_signals entry/exit price setting\n","                    net_pnl_points = pnl_points - commission\n","\n","                    pct_change = (net_pnl_points / current_trade['entry_price']) * 100 if current_trade['entry_price'] else 0\n","                    duration_delta = exit_idx_time - current_trade['entry_idx_time']\n","                    duration_bars = i - current_trade['entry_index'] # Duration in bars\n","\n","                    outcome = 'Win' if net_pnl_points > 0 else 'Loss'\n","\n","                    trade_record = {\n","                        **current_trade,\n","                        'exit_idx_time': exit_idx_time,\n","                        'exit_price': exit_price,\n","                        'pnl_points': net_pnl_points,\n","                        'pct_change': pct_change,\n","                        'duration_delta': duration_delta,\n","                        'duration_bars': duration_bars,\n","                        'outcome': outcome,\n","                        'exit_reason': exit_reason\n","                    }\n","                    self.trade_history.append(trade_record)\n","\n","                    # --- Update Summary Stats ---\n","                    self.summary_stats['total_trades'] += 1\n","                    self.summary_stats['total_pnl'] += net_pnl_points\n","                    # total_pnl_percent requires capital tracking, skip for now\n","\n","                    if outcome == 'Win':\n","                        self.summary_stats['winning_trades'] += 1\n","                        win_pnls.append(net_pnl_points)\n","                        win_durations.append(duration_bars)\n","                    else:\n","                        self.summary_stats['losing_trades'] += 1\n","                        loss_pnls.append(abs(net_pnl_points)) # Use absolute loss\n","                        loss_durations.append(duration_bars)\n","\n","                    if pd.notna(current_trade['risk_reward_ratio']):\n","                         risk_rewards.append(current_trade['risk_reward_ratio'])\n","\n","                    # Update streaks\n","                    if outcome == current_streak_type: current_streak += 1\n","                    else: current_streak = 1; current_streak_type = outcome\n","                    if outcome == 'Win': max_consec_wins = max(max_consec_wins, current_streak)\n","                    else: max_consec_losses = max(max_consec_losses, current_streak)\n","\n","                    # Update running PnL for drawdown\n","                    running_pnl += net_pnl_points\n","                    peak_pnl = max(peak_pnl, running_pnl)\n","                    drawdown = peak_pnl - running_pnl\n","                    self.summary_stats['max_drawdown_points'] = max(self.summary_stats.get('max_drawdown_points', 0.0), drawdown)\n","\n","                    # --- Update Detailed Stats ---\n","                    pos = current_trade['position']\n","                    sig_type = current_trade['signal_type']\n","                    exit_type = exit_reason\n","\n","                    self.entry_stats[pos]['total'] += 1\n","                    self.entry_stats[pos]['total_pnl'] += net_pnl_points\n","                    self.entry_stats[pos]['total_duration_bars'] += duration_bars\n","                    if outcome == 'Win': self.entry_stats[pos]['success'] += 1\n","                    # Check SL/Target Hit (Approximate check)\n","                    if exit_type == 'Trailing Stop' or exit_type == 'ATR Stop': self.entry_stats[pos]['sl_hit'] += 1\n","                    if exit_type == 'Fib Target' or exit_type == 'Target': self.entry_stats[pos]['target_hit'] += 1\n","\n","                    self.exit_stats[exit_type]['total'] += 1\n","                    self.exit_stats[exit_type]['total_pnl'] += net_pnl_points\n","                    self.exit_stats[exit_type]['total_duration_bars'] += duration_bars\n","                    if outcome == 'Win': self.exit_stats[exit_type]['success'] += 1\n","\n","                    self.signal_stats[sig_type]['total'] += 1\n","                    self.signal_stats[sig_type]['total_pnl'] += net_pnl_points\n","                    if outcome == 'Win': self.signal_stats[sig_type]['success'] += 1\n","\n","                    current_trade = None # Reset current trade\n","\n","            # --- Finalize Summary Metrics ---\n","            if self.summary_stats['total_trades'] > 0:\n","                avg_win = np.mean(win_pnls) if win_pnls else 0\n","                avg_loss = np.mean(loss_pnls) if loss_pnls else 0\n","                self.summary_stats['win_rate'] = (self.summary_stats['winning_trades'] / self.summary_stats['total_trades']) * 100\n","                self.summary_stats['avg_win_points'] = avg_win\n","                self.summary_stats['avg_loss_points'] = avg_loss\n","                self.summary_stats['profit_factor'] = abs(sum(win_pnls) / sum(loss_pnls)) if sum(loss_pnls) != 0 else np.inf\n","                self.summary_stats['expectancy_points'] = (avg_win * (self.summary_stats['win_rate']/100)) - (avg_loss * (1 - self.summary_stats['win_rate']/100))\n","                self.summary_stats['max_consec_wins'] = max_consec_wins\n","                self.summary_stats['max_consec_losses'] = max_consec_losses\n","                self.summary_stats['avg_win_duration_bars'] = np.mean(win_durations) if win_durations else 0\n","                self.summary_stats['avg_loss_duration_bars'] = np.mean(loss_durations) if loss_durations else 0\n","                self.summary_stats['avg_risk_reward_ratio'] = np.nanmean(risk_rewards) if risk_rewards else np.nan # Use nanmean\n","\n","                # Health Score (Example)\n","                health_score = min(100, max(0,\n","                    (self.summary_stats['win_rate'] * 0.4) +\n","                    (min(self.summary_stats['profit_factor'], 5) * 10 if pd.notna(self.summary_stats['profit_factor']) else 0) +\n","                    (1 - (self.summary_stats['avg_loss_duration_bars']/self.summary_stats['avg_win_duration_bars'] if self.summary_stats['avg_win_duration_bars'] > 0 else 1) * 20) +\n","                    (self.summary_stats['avg_risk_reward_ratio'] * 10 if pd.notna(self.summary_stats['avg_risk_reward_ratio']) else 0)\n","                ))\n","                self.summary_stats['health_score'] = health_score\n","\n","            # --- Finalize Detailed Stats (Averages) ---\n","            for pos in list(self.entry_stats.keys()): # Use list to avoid dict size change error\n","                if self.entry_stats[pos]['total'] > 0:\n","                    self.entry_stats[pos]['avg_pnl'] = self.entry_stats[pos]['total_pnl'] / self.entry_stats[pos]['total']\n","                    self.entry_stats[pos]['avg_duration_bars'] = self.entry_stats[pos]['total_duration_bars'] / self.entry_stats[pos]['total']\n","                    self.entry_stats[pos]['win_rate'] = (self.entry_stats[pos]['success'] / self.entry_stats[pos]['total']) * 100\n","                    self.entry_stats[pos]['sl_rate'] = (self.entry_stats[pos]['sl_hit'] / self.entry_stats[pos]['total']) * 100\n","                    self.entry_stats[pos]['target_rate'] = (self.entry_stats[pos]['target_hit'] / self.entry_stats[pos]['total']) * 100\n","\n","            for exit_type in list(self.exit_stats.keys()):\n","                 if self.exit_stats[exit_type]['total'] > 0:\n","                    self.exit_stats[exit_type]['avg_pnl'] = self.exit_stats[exit_type]['total_pnl'] / self.exit_stats[exit_type]['total']\n","                    self.exit_stats[exit_type]['avg_duration_bars'] = self.exit_stats[exit_type]['total_duration_bars'] / self.exit_stats[exit_type]['total']\n","                    self.exit_stats[exit_type]['win_rate'] = (self.exit_stats[exit_type]['success'] / self.exit_stats[exit_type]['total']) * 100\n","\n","            for sig_type in list(self.signal_stats.keys()):\n","                 if self.signal_stats[sig_type]['total'] > 0:\n","                    self.signal_stats[sig_type]['avg_pnl'] = self.signal_stats[sig_type]['total_pnl'] / self.signal_stats[sig_type]['total']\n","                    self.signal_stats[sig_type]['win_rate'] = (self.signal_stats[sig_type]['success'] / self.signal_stats[sig_type]['total']) * 100\n","\n","            logger.info(\"Finished analyzing trades.\")\n","            # Return original df, analysis is stored in the object\n","            return df\n","\n","        except Exception as e:\n","            logger.error(f\"Error in analyze_trades: {str(e)}\", exc_info=True)\n","            raise\n","\n","    def print_summary(self):\n","        \"\"\"Print comprehensive performance statistics.\"\"\"\n","        if not self.summary_stats or self.summary_stats['total_trades'] == 0:\n","             print(\"\\nNo trades to summarize.\")\n","             logger.info(\"No trades to summarize.\")\n","             return\n","        try:\n","            summary = [\n","                \"\\n=== ENHANCED TRADE SUMMARY ===\",\n","                f\"Total Trades: {int(self.summary_stats['total_trades'])}\",\n","                f\"Winning Trades: {int(self.summary_stats['winning_trades'])} ({self.summary_stats['win_rate']:.1f}%)\",\n","                f\"Losing Trades: {int(self.summary_stats['losing_trades'])}\",\n","                f\"Total P&L (Points): {self.summary_stats['total_pnl']:.2f}\",\n","                # f\"Total P&L %: {self.summary_stats['total_pnl_percent']:.2f}%\", # Needs capital\n","                f\"Profit Factor: {self.summary_stats['profit_factor']:.2f}\",\n","                f\"Expectancy (Points): {self.summary_stats['expectancy_points']:.2f}\",\n","                f\"Max Drawdown (Points): {self.summary_stats['max_drawdown_points']:.2f}\",\n","                f\"Avg Win / Avg Loss (Points): {self.summary_stats['avg_win_points']:.2f} / {self.summary_stats['avg_loss_points']:.2f}\",\n","                f\"Max Consecutive Wins: {int(self.summary_stats['max_consec_wins'])}\",\n","                f\"Max Consecutive Losses: {int(self.summary_stats['max_consec_losses'])}\",\n","                f\"Avg Win Duration (Bars): {self.summary_stats['avg_win_duration_bars']:.1f}\",\n","                f\"Avg Loss Duration (Bars): {self.summary_stats['avg_loss_duration_bars']:.1f}\",\n","                f\"Avg Risk/Reward Ratio (at Entry): {self.summary_stats['avg_risk_reward_ratio']:.2f}:1\" if pd.notna(self.summary_stats['avg_risk_reward_ratio']) else \"N/A\",\n","                f\"Strategy Health Score: {self.summary_stats['health_score']:.1f}/100\",\n","                \"\\n=== ENTRY STATISTICS ===\",\n","                \"Position | Total | Win % | Avg P&L | Avg Dur | SL % | Target %\",\n","                \"-------------------------------------------------------------\"\n","            ]\n","            for position, stats in self.entry_stats.items():\n","                summary.append(\n","                    f\"{position:8} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f} | {stats['avg_duration_bars']:7.1f} | {stats['sl_rate']:4.1f}% | {stats['target_rate']:6.1f}%\"\n","                )\n","            summary.extend([\n","                \"\\n=== EXIT STATISTICS ===\",\n","                \"Exit Type           | Total | Win % | Avg P&L | Avg Dur\",\n","                \"------------------------------------------------------\"\n","            ])\n","            for exit_type, stats in sorted(self.exit_stats.items()): # Sort for consistency\n","                summary.append(\n","                    f\"{str(exit_type):19} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f} | {stats['avg_duration_bars']:7.1f}\"\n","                )\n","            summary.extend([\n","                \"\\n=== SIGNAL TYPE STATISTICS ===\",\n","                \"Signal Type          | Total | Win % | Avg P&L\",\n","                \"---------------------------------------------\"\n","            ])\n","            for signal_type, stats in sorted(self.signal_stats.items()): # Sort for consistency\n","                 if not signal_type: continue # Skip empty signal types if any\n","                 summary.append(\n","                    f\"{str(signal_type):20} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f}\"\n","                )\n","\n","            print(\"\\n\".join(summary))\n","            logger.info(\"\\n\".join(summary))\n","\n","            health = self.summary_stats['health_score']\n","            if health >= 70: health_indicator = \" STRONG\"\n","            elif health >= 50: health_indicator = \" MODERATE\"\n","            else: health_indicator = \" WEAK\"\n","            print(f\"\\nStrategy Health: {health_indicator}\")\n","            if self.summary_stats['total_trades'] < 30: print(\"  Warning: Low sample size (<30 trades)\")\n","\n","        except Exception as e:\n","            logger.error(f\"Error printing summary: {str(e)}\", exc_info=True)\n","            raise\n","\n","# --- Plotting Function (Simplified - No Equity Curve) ---\n","def plot_signals(df: pd.DataFrame, save_path: Optional[Path] = None):\n","    \"\"\"Visualize the signals with price and indicators.\"\"\"\n","    logger.info(\"Generating signal plot\")\n","    plt.style.use('seaborn-v0_8-darkgrid')\n","    fig, axes = plt.subplots(4, 1, sharex=True, figsize=(20, 15)) # 4 subplots\n","\n","    # --- Price Chart ---\n","    ax1 = axes[0]\n","    ax1.plot(df['close'], label='Price', color='black', alpha=0.9, linewidth=1.0)\n","    ax1.plot(df['ema_fast'], label=f\"EMA {PARAMS['ema']['fast_len']}\", alpha=0.6, linewidth=0.8)\n","    ax1.plot(df['ema_med'], label=f\"EMA {PARAMS['ema']['med_len']}\", alpha=0.6, linewidth=0.8)\n","    ax1.plot(df['ema_slow'], label=f\"EMA {PARAMS['ema']['slow_len']}\", alpha=0.6, linewidth=0.8)\n","    long_entries = df[df['signal'] == 'Long']; short_entries = df[df['signal'] == 'Short']\n","    long_exits = df[df['signal'].str.contains('Exit Long', na=False)]; short_exits = df[df['signal'].str.contains('Exit Short', na=False)]\n","    ax1.scatter(long_entries.index, long_entries['entry_price'], marker='^', color='lime', s=100, label='Long Entry', zorder=5, edgecolors='black')\n","    ax1.scatter(short_entries.index, short_entries['entry_price'], marker='v', color='red', s=100, label='Short Entry', zorder=5, edgecolors='black')\n","    ax1.scatter(long_exits.index, long_exits['exit_price'], marker='x', color='fuchsia', s=80, label='Exit', zorder=5) # Combined exit label\n","    ax1.scatter(short_exits.index, short_exits['exit_price'], marker='x', color='fuchsia', s=80, zorder=5)\n","    ax1.plot(df['trailing_stop'], label='Trailing Stop', linestyle='--', color='purple', alpha=0.7, linewidth=1.0)\n","    ax1.scatter(df.index, df['target_price_long'], marker='_', color='blue', alpha=0.5, s=50, label='Long Target')\n","    ax1.scatter(df.index, df['target_price_short'], marker='_', color='orange', alpha=0.5, s=50, label='Short Target')\n","    ax1.legend(loc='upper left'); ax1.set_title('Price, EMAs, Signals, Stops & Targets'); ax1.set_ylabel('Price'); ax1.grid(True, which='both', linestyle=':', linewidth=0.5)\n","\n","    # --- Score Chart ---\n","    ax_score = axes[1]\n","    ax_score.plot(df['scaled_score'], label='Scaled Score (0-10)', color='teal', linewidth=1.5)\n","    ax_score.axhline(PARAMS['core']['entry_score_threshold'], color='green', linestyle='--', alpha=0.5, label=f'Long Entry Thresh')\n","    ax_score.axhline(10.0 - PARAMS['core']['entry_score_threshold'], color='red', linestyle='--', alpha=0.5, label=f'Short Entry Thresh')\n","    if PARAMS['core']['use_score_drop_exit']:\n","        ax_score.axhline(5.0 - PARAMS['core']['exit_score_drop_threshold'], color='red', linestyle=':', alpha=0.4, label=f'Long Exit Drop')\n","        ax_score.axhline(5.0 + PARAMS['core']['exit_score_drop_threshold'], color='green', linestyle=':', alpha=0.4, label=f'Short Exit Drop')\n","    ax_score.set_ylim(0, 10); ax_score.legend(loc='upper left'); ax_score.set_title('Confidence Score'); ax_score.set_ylabel('Score'); ax_score.grid(True, which='both', linestyle=':', linewidth=0.5)\n","\n","    # --- RSI Chart ---\n","    ax_rsi = axes[2]\n","    ax_rsi.plot(df['rsi'], label='RSI', color='orange', linewidth=1.0)\n","    ax_rsi.axhline(50, linestyle='--', color='gray', alpha=0.5); ax_rsi.axhline(PARAMS['rsi']['rsi_buy_level'], linestyle=':', color='green', alpha=0.4); ax_rsi.axhline(PARAMS['rsi']['rsi_sell_level'], linestyle=':', color='red', alpha=0.4)\n","    bull_div = df[df['bullish_rsi_div']]; bear_div = df[df['bearish_rsi_div']]\n","    ax_rsi.scatter(bull_div.index, bull_div['rsi'] * 0.98, marker='^', color='cyan', s=50, label='Bullish Div', zorder=5)\n","    ax_rsi.scatter(bear_div.index, bear_div['rsi'] * 1.02, marker='v', color='magenta', s=50, label='Bearish Div', zorder=5)\n","    ax_rsi.legend(loc='upper left'); ax_rsi.set_title('RSI & Divergence'); ax_rsi.set_ylabel('RSI'); ax_rsi.grid(True, which='both', linestyle=':', linewidth=0.5)\n","\n","    # --- MACD Chart ---\n","    ax_macd = axes[3]\n","    ax_macd.plot(df['macd'], label='MACD', color='blue', linewidth=1.0); ax_macd.plot(df['macd_signal'], label='Signal', color='red', alpha=0.8, linewidth=1.0)\n","    colors = ['g' if v >= 0 else 'r' for v in df['macd_hist']]; ax_macd.bar(df.index, df['macd_hist'], label='Histogram', color=colors, alpha=0.5)\n","    ax_macd.axhline(0, linestyle='--', color='gray', alpha=0.5); ax_macd.legend(loc='upper left'); ax_macd.set_title('MACD'); ax_macd.set_ylabel('MACD'); ax_macd.grid(True, which='both', linestyle=':', linewidth=0.5)\n","\n","    # Common x-axis label and formatting\n","    axes[-1].tick_params(axis='x', rotation=45)\n","    plt.xlabel('Date')\n","    plt.tight_layout(rect=[0, 0.03, 1, 0.97])\n","    fig.suptitle('Trading Strategy Signals and Indicators', fontsize=16)\n","\n","    if save_path:\n","        plt.savefig(save_path, dpi=150)\n","        logger.info(f\"Saved signal plot to {save_path}\")\n","    else:\n","        plt.show()\n","    plt.close(fig)\n","\n","# --- Command Line Argument Parsing ---\n","def parse_args():\n","    parser = argparse.ArgumentParser(description='Generate enhanced trading signals and calculate detailed stats.')\n","    parser.add_argument('--input', type=str, default=str(DEFAULT_INPUT_FILE), help=f'Input CSV (default: {DEFAULT_INPUT_FILE})')\n","    parser.add_argument('--output', type=str, default=str(DEFAULT_OUTPUT_FILE), help=f'Output CSV (default: {DEFAULT_OUTPUT_FILE})')\n","    parser.add_argument('--plot', type=str, default=str(DEFAULT_PLOT_FILE), help=f'Plot image path (default: {DEFAULT_PLOT_FILE})')\n","    parser.add_argument('--no-plot', action='store_true', help='Disable generating plot')\n","    parser.add_argument('--full-history', action='store_true', help='Run on full history')\n","    return parser.parse_args()\n","\n","# --- Main Execution Block ---\n","if __name__ == \"__main__\":\n","    args = parse_args()\n","    input_file = Path(args.input); output_file = Path(args.output); plot_file = Path(args.plot)\n","\n","    try:\n","        output_file.parent.mkdir(parents=True, exist_ok=True)\n","        if not args.no_plot: plot_file.parent.mkdir(parents=True, exist_ok=True)\n","\n","        logger.info(f\"Loading data from {input_file}\")\n","        if not input_file.exists(): raise FileNotFoundError(f\"Input file not found: {input_file}\")\n","        df_full = pd.read_csv(input_file, parse_dates=['datetime'], index_col='datetime')\n","        if df_full.empty: raise pd.errors.EmptyDataError(\"Input file is empty.\")\n","        required_cols = ['open', 'high', 'low', 'close', 'volume']\n","        if not all(col in df_full.columns for col in required_cols): raise ValueError(f\"Input CSV must contain: {', '.join(required_cols)}\")\n","\n","        # --- Filter Data ---\n","        if PARAMS['backtest']['filter_last_month'] and not args.full_history:\n","            if not df_full.empty:\n","                last_date = df_full.index.max(); one_month_prior = last_date - pd.DateOffset(months=1)\n","                df = df_full.loc[one_month_prior:].copy()\n","                logger.info(f\"Filtered data from {df.index.min().date()} to {df.index.max().date()}.\")\n","            else: df = df_full\n","        else:\n","            df = df_full.copy()\n","            logger.info(f\"Using full data history from {df.index.min().date()} to {df.index.max().date()}.\")\n","\n","        if df.empty:\n","             logger.warning(\"DataFrame empty after filtering. Skipping processing.\")\n","             df_processed = df\n","             analyzer = None # No analyzer needed\n","        else:\n","            logger.info(\"Processing signals...\")\n","            df_processed = process_signals(df) # Generate signals\n","\n","            logger.info(\"Analyzing trades...\")\n","            analyzer = EnhancedSignalAnalyzer() # Instantiate analyzer\n","            analyzer.analyze_trades(df_processed) # Analyze the processed df\n","            analyzer.print_summary() # Print detailed stats\n","\n","        logger.info(f\"Saving results to {output_file}\")\n","        df_processed.to_csv(output_file) # Save df with signals\n","\n","        # --- Plotting ---\n","        if not args.no_plot and not df_processed.empty:\n","            plot_signals(df_processed, plot_file) # Use simplified plot function\n","        elif not args.no_plot and df_processed.empty:\n","             logger.warning(\"Plotting skipped as no data.\")\n","\n","        logger.info(\"Processing completed successfully\")\n","        sys.exit(0) # Success exit code\n","\n","    except FileNotFoundError as e: logger.error(str(e)); sys.exit(1)\n","    except pd.errors.EmptyDataError as e: logger.error(f\"Input file '{input_file}' empty/corrupt.\"); sys.exit(1)\n","    except ValueError as e: logger.error(f\"Data validation error: {str(e)}\"); sys.exit(1)\n","    except Exception as e: logger.error(f\"Unexpected error: {str(e)}\", exc_info=True); sys.exit(1)"],"outputs":[],"execution_count":null,"metadata":{"id":"01nlHu6CPo1a"}}],"metadata":{"colab":{"provenance":[]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}