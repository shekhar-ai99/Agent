{"cells":[{"cell_type":"code","source":["import numpy as np\n","import pandas as pd\n","import os\n","import logging\n","import matplotlib.pyplot as plt\n","from typing import Dict, Any, Optional, Tuple, List\n","from pathlib import Path\n","import argparse\n","from datetime import timedelta\n","from collections import defaultdict # Needed for EnhancedSignalAnalyzer\n","import sys # Needed for exit code in main\n","\n","# Initialize logging\n","logging.basicConfig(\n","    level=logging.INFO,\n","    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n","    handlers=[\n","        logging.FileHandler('signals_calculator_analyzer.log'), # New log file name\n","        logging.StreamHandler()\n","    ]\n",")\n","logger = logging.getLogger(__name__)\n","\n","# Configuration\n","\n","# Default file names (can be overridden by command line args)\n","DEFAULT_INPUT_FILE =  \"nifty_historical_data.csv\" # Changed default input name - expects raw data now\n","DEFAULT_OUTPUT_FILE = \"nifty_signals_final_calculated.csv\"\n","DEFAULT_PLOT_FILE =  \"signals_plot_calculated.png\"\n","\n","# --- IndicatorCalculator Class (from Script 2 - Enhanced) ---\n","class IndicatorCalculator:\n","    \"\"\"Enhanced technical indicator calculator with complete implementations\"\"\"\n","\n","    DEFAULT_PARAMS = {\n","        'sma_periods': [20, 50, 200],\n","        'ema_periods': [9, 14, 21, 50], # Added 14 for ema_med\n","        'macd_params': (12, 26, 9),\n","        'rsi_period': 14,\n","        'stochastic_period': 14,\n","        'bollinger_period': 20,\n","        'bollinger_std': 2,\n","        'atr_period': 14,\n","        'adx_period': 14, # Added ADX period\n","        'vol_sma_period': 50, # Added Volume SMA period\n","        'obv_ema_period': 21,\n","        'vwap_enabled': True\n","    }\n","\n","    def __init__(self, params: Optional[Dict] = None):\n","        self.params = {**self.DEFAULT_PARAMS, **(params or {})}\n","        self._validate_params()\n","\n","    def _validate_params(self) -> None:\n","        \"\"\"Validate indicator parameters\"\"\"\n","        periods_to_check = [\n","            *self.params['sma_periods'], *self.params['ema_periods'],\n","            self.params['rsi_period'], self.params['stochastic_period'],\n","            self.params['bollinger_period'], self.params['atr_period'],\n","            self.params['adx_period'], self.params['vol_sma_period']\n","        ]\n","        if any(p <= 0 for p in periods_to_check):\n","            raise ValueError(\"All periods must be positive integers\")\n","        if self.params['bollinger_std'] <= 0:\n","            raise ValueError(\"Bollinger standard deviation must be positive\")\n","\n","    def validate_dataframe(self, df: pd.DataFrame) -> None:\n","        \"\"\"Validate input dataframe structure and data quality\"\"\"\n","        required_columns = ['open', 'high', 'low', 'close', 'volume']\n","        missing = [col for col in required_columns if col not in df.columns]\n","        if missing: raise ValueError(f\"Missing required columns: {missing}\")\n","        for col in required_columns:\n","            if not pd.api.types.is_numeric_dtype(df[col]): raise ValueError(f\"Column {col} must be numeric\")\n","        min_period = max([p for p in self.params.values() if isinstance(p, int) and p > 0] + [max(p) for p in self.params.values() if isinstance(p, list) and p])\n","        if len(df) < min_period: logger.warning(f\"Limited data points ({len(df)}) may affect indicator accuracy (min {min_period} recommended)\")\n","        if (df['high'] < df['low']).any(): raise ValueError(\"High price cannot be less than low price\")\n","        if (df['close'] > df['high']).any() or (df['close'] < df['low']).any(): raise ValueError(\"Close price must be between high and low\")\n","        if (df['volume'] < 0).any(): raise ValueError(\"Volume cannot be negative\")\n","\n","    def calculate_trend_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            for period in self.params['sma_periods']: df[f'sma_{period}'] = df['close'].rolling(window=period, min_periods=1).mean()\n","            for period in self.params['ema_periods']: df[f'ema_{period}'] = df['close'].ewm(span=period, adjust=False, min_periods=1).mean()\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating trend indicators: {str(e)}\"); raise\n","\n","    def calculate_macd(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            fast, slow, signal = self.params['macd_params']\n","            ema_fast = df['close'].ewm(span=fast, adjust=False, min_periods=1).mean()\n","            ema_slow = df['close'].ewm(span=slow, adjust=False, min_periods=1).mean()\n","            df['macd'] = ema_fast - ema_slow\n","            df['macd_signal'] = df['macd'].ewm(span=signal, adjust=False, min_periods=1).mean()\n","            df['macd_hist'] = df['macd'] - df['macd_signal']\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating MACD: {str(e)}\"); raise\n","\n","    def calculate_rsi(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['rsi_period']; delta = df['close'].diff()\n","            if len(delta) < period: logger.warning(f\"Insufficient data for RSI ({len(delta)} points)\"); df['rsi'] = np.nan; return df\n","            gain = delta.where(delta > 0, 0.0); loss = -delta.where(delta < 0, 0.0)\n","            # Use EWM for RSI calculation (more standard than rolling mean)\n","            avg_gain = gain.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            avg_loss = loss.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            rs = avg_gain / avg_loss.replace(0, 1e-6)\n","            df['rsi'] = 100.0 - (100.0 / (1.0 + rs))\n","            df['rsi'] = df['rsi'].fillna(50); df['rsi'] = df['rsi'].clip(0, 100)\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating RSI: {str(e)}\"); raise\n","\n","    def calculate_stochastic(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['stochastic_period']\n","            low_min = df['low'].rolling(window=period, min_periods=1).min()\n","            high_max = df['high'].rolling(window=period, min_periods=1).max()\n","            df['stochastic_k'] = 100 * ((df['close'] - low_min) / (high_max - low_min).replace(0, 1e-6))\n","            df['stochastic_d'] = df['stochastic_k'].rolling(window=3, min_periods=1).mean()\n","            df['stochastic_k'] = df['stochastic_k'].fillna(50); df['stochastic_d'] = df['stochastic_d'].fillna(50)\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating Stochastic: {str(e)}\"); raise\n","\n","    def calculate_bollinger_bands(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['bollinger_period']; std_dev = self.params['bollinger_std']\n","            sma = df['close'].rolling(window=period, min_periods=1).mean()\n","            rolling_std = df['close'].rolling(window=period, min_periods=1).std()\n","            df['bollinger_upper'] = sma + (std_dev * rolling_std)\n","            df['bollinger_lower'] = sma - (std_dev * rolling_std)\n","            df['bollinger_mid'] = sma\n","            df['bollinger_bandwidth'] = (df['bollinger_upper'] - df['bollinger_lower']) / df['bollinger_mid'].replace(0, 1e-6)\n","            df['bollinger_pctb'] = (df['close'] - df['bollinger_lower']) / (df['bollinger_upper'] - df['bollinger_lower']).replace(0, 1e-6)\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating Bollinger Bands: {str(e)}\"); raise\n","\n","    def calculate_atr(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['atr_period']\n","            high_low = df['high'] - df['low']\n","            high_close = (df['high'] - df['close'].shift()).abs()\n","            low_close = (df['low'] - df['close'].shift()).abs()\n","            true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)\n","            # Use EWM for ATR (Wilder's smoothing)\n","            df['atr'] = true_range.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating ATR: {str(e)}\"); raise\n","\n","    # --- NEW: ADX Calculation ---\n","    def calculate_adx(self, df: pd.DataFrame) -> pd.DataFrame:\n","        \"\"\"Calculate ADX, +DI, -DI\"\"\"\n","        try:\n","            period = self.params['adx_period']\n","            if 'atr' not in df.columns: # Calculate ATR if not already present\n","                df = self.calculate_atr(df)\n","\n","            up_move = df['high'].diff()\n","            down_move = -df['low'].diff()\n","            plus_dm = ((up_move > down_move) & (up_move > 0)) * up_move\n","            minus_dm = ((down_move > up_move) & (down_move > 0)) * down_move\n","            plus_dm = plus_dm.fillna(0)\n","            minus_dm = minus_dm.fillna(0)\n","\n","            # Use Wilder's smoothing for DM and TR\n","            smooth_plus_dm = plus_dm.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            smooth_minus_dm = minus_dm.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            # TR is needed for smoothing, use the already calculated ATR column for consistency\n","            atr_smoothed = df['atr'].replace(0, 1e-6) # Use the calculated ATR\n","\n","            df['plus_di'] = 100 * (smooth_plus_dm / atr_smoothed)\n","            df['minus_di'] = 100 * (smooth_minus_dm / atr_smoothed)\n","            di_sum = (df['plus_di'] + df['minus_di']).replace(0, 1e-6)\n","            dx = 100 * (abs(df['plus_di'] - df['minus_di']) / di_sum)\n","            df['adx'] = dx.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","\n","            # Fill initial NaNs\n","            df[['plus_di', 'minus_di', 'adx']] = df[['plus_di', 'minus_di', 'adx']].fillna(0)\n","\n","            return df\n","        except Exception as e:\n","            logger.error(f\"Error calculating ADX: {str(e)}\")\n","            raise\n","\n","    # --- NEW: Volume SMA Calculation ---\n","    def calculate_volume_sma(self, df: pd.DataFrame) -> pd.DataFrame:\n","        \"\"\"Calculate Simple Moving Average on Volume\"\"\"\n","        try:\n","            period = self.params['vol_sma_period']\n","            df[f'vol_sma_{period}'] = df['volume'].rolling(window=period, min_periods=1).mean()\n","            return df\n","        except Exception as e:\n","            logger.error(f\"Error calculating Volume SMA: {str(e)}\")\n","            raise\n","\n","    def calculate_volume_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            df['obv'] = (np.sign(df['close'].diff()) * df['volume']).fillna(0).cumsum()\n","            df['obv_ema'] = df['obv'].ewm(span=self.params['obv_ema_period'], adjust=False).mean()\n","            if self.params['vwap_enabled']:\n","                # VWAP calculation needs careful handling, especially for intraday resets\n","                # Simple cumulative VWAP:\n","                df['vwap'] = (df['close'] * df['volume']).cumsum() / df['volume'].cumsum().replace(0, 1e-6)\n","                # For proper daily VWAP, reset calculation at the start of each day\n","                # This requires grouping by date, which is more complex here.\n","                # logger.warning(\"VWAP calculation is cumulative; for daily VWAP, implement daily reset.\")\n","            df = self.calculate_volume_sma(df) # Calculate Volume SMA here\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating volume indicators: {str(e)}\"); raise\n","\n","    def calculate_all_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            self.validate_dataframe(df)\n","            df = df.copy() # Work on a copy\n","            df = self.calculate_trend_indicators(df)\n","            df = self.calculate_macd(df)\n","            df = self.calculate_rsi(df)\n","            df = self.calculate_stochastic(df)\n","            df = self.calculate_bollinger_bands(df)\n","            df = self.calculate_atr(df) # ATR needed for ADX\n","            df = self.calculate_adx(df) # Calculate ADX\n","            df = self.calculate_volume_indicators(df) # Includes Vol SMA\n","            logger.info(f\"Successfully calculated indicators\")\n","            return df.dropna(axis=0, how='any') # Drop rows with initial NaNs from indicator calcs\n","        except Exception as e: logger.error(f\"Indicator calculation failed: {str(e)}\", exc_info=True); raise\n","\n","\n","# --- Parameter Dictionary (Strategy Logic Parameters Only) ---\n","# Indicator parameters are now defined in IndicatorCalculator.DEFAULT_PARAMS\n","PARAMS: Dict[str, Dict[str, Any]] = {\n","    'backtest': {\n","        'commission_pct': 0.0005,\n","        'slippage_pct': 0.0002,\n","        'filter_last_month': True\n","    },\n","    'core': {\n","        \"max_trade_duration\": 50,\n","        'exit_score_drop_threshold': 1.5,\n","        'use_score_drop_exit': True,\n","        'entry_score_threshold': 6.0,\n","        'use_fib_bounce_entry': True,\n","        'use_fib_bounce_sell': True,\n","        'fib_bounce_lookback': 3,\n","        'fib_bounce_long_zone': (0.5, 0.618),\n","        'fib_bounce_short_zone': (0.382, 0.5),\n","        'fib_bounce_confirmation_level': 0.5,\n","        'use_ema_bounce_buy': True,\n","        'use_ema_bounce_sell': True,\n","        'ema_bounce_lookback': 2,\n","        'ema_bounce_source_str': \"Fast EMA\", # Uses 'ema_fast' (mapped from ema_9)\n","        'use_bb_mid_bounce_buy': True,\n","        'use_bb_mid_bounce_sell': True,\n","        'bb_bounce_lookback': 2,\n","        'use_vol_breakout_buy': True,\n","        'use_vol_breakout_sell': True,\n","        'trailing_stop_type': \"atr\",\n","        'trailing_stop_pct': 0.02,\n","        'trailing_stop_atr_multiplier': 1.5,\n","        'profit_protection_levels': {\n","            'level1': {'profit_pct': 0.05, 'new_atr_mult': 1.0},\n","            'level2': {'profit_pct': 0.10, 'new_atr_mult': 0.5}\n","        }\n","    },\n","    'ema': { # Only keep params for strategy logic using EMAs\n","        'med_len': 14, # Length used for internal calculation if needed (e.g., trend check)\n","        'use_ema_exit': True\n","    },\n","    'bollinger': { # Only keep strategy logic params\n","        'use_bb_return_exit': True\n","    },\n","    'rsi': { # Only keep strategy logic params\n","        'rsi_buy_level': 55.0,\n","        'rsi_sell_level': 45.0,\n","        'rsi_confirm_fib': True,\n","        'rsi_confirm_ema': False,\n","        'rsi_confirm_bb': False,\n","        'rsi_confirm_level_buy': 40.0,\n","        'rsi_confirm_level_sell': 60.0,\n","        'use_rsi_div_exit': True\n","    },\n","    'macd': { # No MACD specific strategy params here, but keep section if needed later\n","    },\n","    'volume': { # Keep strategy logic params\n","        'vol_multiplier': 1.5,\n","        'use_vol_fade_exit': True\n","    },\n","    'atr': { # Keep strategy logic params\n","        'use_atr_stop': True\n","    },\n","    'fibonacci': {\n","        'use_fib_exit': True,\n","        'fib_lookback_exit': 30,\n","        'fib_extension_level': 1.618,\n","        'fib_pivot_lookback': 15,\n","        'fib_max_bars': 200\n","    },\n","    'trend': { # Keep strategy logic params\n","        'use_ema_trend_filter': True,\n","        'use_adx_filter': True,\n","        # 'adx_len': 14, # Defined in IndicatorCalculator\n","        'adx_threshold': 20.0,\n","        'use_adx_direction_filter': True\n","    },\n","    'score_weights': {\n","        'w_ema_trend': 2, 'w_ema_signal': 1, 'w_rsi_thresh': 1,\n","        'w_macd_signal': 1, 'w_macd_zero': 1, 'w_vol_break': 1,\n","        'w_adx_strength': 1, 'w_adx_direction': 1, 'w_fib_bounce': 2,\n","        'w_ema_bounce': 1, 'w_bb_bounce': 1,\n","    }\n","}\n","\n","\n","# --- TradeState Class ---\n","# (Keep the TradeState class definition as it was in strategy_merged_analyzer_v3)\n","class TradeState:\n","    \"\"\"Keeps track of the current trade status.\"\"\"\n","    def __init__(self):\n","        self.position = None\n","        self.entry_price = None\n","        self.entry_index = None\n","        self.trailing_stop = None\n","        self.highest_high_in_trade = None\n","        self.lowest_low_in_trade = None\n","        self.time_in_trade = 0\n","\n","    def reset(self):\n","        self.__init__()\n","\n","    def update_trailing_stop(self, current_low, current_high, current_close, atr):\n","        if self.position is None or atr is None or pd.isna(atr) or self.entry_price is None:\n","            return\n","\n","        stop_type = PARAMS['core']['trailing_stop_type']\n","        initial_atr_mult = PARAMS['core']['trailing_stop_atr_multiplier']\n","        stop_pct = PARAMS['core']['trailing_stop_pct']\n","        current_atr_mult = initial_atr_mult\n","\n","        if self.position == 'Long':\n","            if self.highest_high_in_trade is None or current_high > self.highest_high_in_trade:\n","                self.highest_high_in_trade = current_high\n","\n","            profit_pct = (current_close - self.entry_price) / self.entry_price if self.entry_price else 0\n","            for level_name, level_info in sorted(PARAMS['core']['profit_protection_levels'].items()):\n","                if profit_pct >= level_info['profit_pct']:\n","                    current_atr_mult = level_info['new_atr_mult']\n","\n","            if stop_type == \"percentage\":\n","                potential_stop = self.highest_high_in_trade * (1 - stop_pct) if self.highest_high_in_trade else None\n","            else:\n","                potential_stop = self.highest_high_in_trade - (atr * current_atr_mult) if self.highest_high_in_trade else None\n","\n","            if potential_stop is not None and (self.trailing_stop is None or potential_stop > self.trailing_stop):\n","                self.trailing_stop = potential_stop\n","\n","        elif self.position == 'Short':\n","            if self.lowest_low_in_trade is None or current_low < self.lowest_low_in_trade:\n","                self.lowest_low_in_trade = current_low\n","\n","            profit_pct = (self.entry_price - current_close) / self.entry_price if self.entry_price else 0\n","            for level_name, level_info in sorted(PARAMS['core']['profit_protection_levels'].items()):\n","                 if profit_pct >= level_info['profit_pct']:\n","                    current_atr_mult = level_info['new_atr_mult']\n","\n","            if stop_type == \"percentage\":\n","                potential_stop = self.lowest_low_in_trade * (1 + stop_pct) if self.lowest_low_in_trade else None\n","            else:\n","                potential_stop = self.lowest_low_in_trade + (atr * current_atr_mult) if self.lowest_low_in_trade else None\n","\n","            if potential_stop is not None and (self.trailing_stop is None or potential_stop < self.trailing_stop):\n","                self.trailing_stop = potential_stop\n","\n","\n","# --- Feature Calculation Functions (Fib, Score, Divergence, Targets) ---\n","# (Keep calculate_fibonacci_levels, calculate_score, calculate_rsi_divergence,\n","#  calculate_targets_for_trade functions as they were in strategy_merged_analyzer_v3,\n","#  but ensure calculate_score uses the correct indicator names after renaming)\n","\n","def calculate_score(df: pd.DataFrame) -> Tuple[pd.DataFrame, float]:\n","    logger.info(\"Calculating weighted trading score using provided indicators\")\n","    try:\n","        weights = PARAMS['score_weights']\n","        # Calculate total possible score dynamically based on enabled features in PARAMS\n","        total_possible_score = 0.0\n","        if PARAMS['trend']['use_ema_trend_filter']: total_possible_score += weights.get('w_ema_trend', 0)\n","        total_possible_score += weights.get('w_ema_signal', 0) # Assume always calculated\n","        total_possible_score += weights.get('w_rsi_thresh', 0) # Assume always calculated\n","        total_possible_score += weights.get('w_macd_signal', 0) # Assume always calculated\n","        total_possible_score += weights.get('w_macd_zero', 0) # Assume always calculated\n","        if PARAMS['core']['use_vol_breakout_buy'] or PARAMS['core']['use_vol_breakout_sell']: total_possible_score += weights.get('w_vol_break', 0)\n","        if PARAMS['trend']['use_adx_filter']: total_possible_score += weights.get('w_adx_strength', 0)\n","        if PARAMS['trend']['use_adx_direction_filter']: total_possible_score += weights.get('w_adx_direction', 0)\n","        if PARAMS['core']['use_fib_bounce_entry'] or PARAMS['core']['use_fib_bounce_sell']: total_possible_score += weights.get('w_fib_bounce', 0)\n","        if PARAMS['core']['use_ema_bounce_buy'] or PARAMS['core']['use_ema_bounce_sell']: total_possible_score += weights.get('w_ema_bounce', 0)\n","        if PARAMS['core']['use_bb_mid_bounce_buy'] or PARAMS['core']['use_bb_mid_bounce_sell']: total_possible_score += weights.get('w_bb_bounce', 0)\n","        total_possible_score = max(1.0, total_possible_score)\n","\n","        # --- Calculate Individual Condition Flags using provided/renamed columns ---\n","        # Ensure these columns exist after renaming!\n","        df['cond_ema_trend_buy'] = df['ema_med'] > df['ema_slow']\n","        df['cond_ema_trend_sell'] = df['ema_med'] < df['ema_slow']\n","        df['cond_ema_signal_buy'] = (df['ema_fast'] > df['ema_slow']) & (df['ema_fast'].shift() <= df['ema_slow'].shift())\n","        df['cond_ema_signal_sell'] = (df['ema_fast'] < df['ema_slow']) & (df['ema_fast'].shift() >= df['ema_slow'].shift())\n","        df['cond_rsi_buy'] = df['rsi'] > PARAMS['rsi']['rsi_buy_level']\n","        df['cond_rsi_sell'] = df['rsi'] < PARAMS['rsi']['rsi_sell_level']\n","        df['cond_macd_signal_buy'] = (df['macd'] > df['macd_signal']) & (df['macd'].shift() <= df['macd_signal'].shift())\n","        df['cond_macd_signal_sell'] = (df['macd'] < df['macd_signal']) & (df['macd'].shift() >= df['macd_signal'].shift())\n","        df['cond_macd_zero_buy'] = (df['macd'] > 0) & (df['macd'].shift() <= 0)\n","        df['cond_macd_zero_sell'] = (df['macd'] < 0) & (df['macd'].shift() >= 0)\n","        df['cond_vol_break_buy'] = (df['volume'] > df['vol_ma'] * PARAMS['volume']['vol_multiplier']) & (df['close'] > df['open']) # Uses calculated vol_ma\n","        df['cond_vol_break_sell'] = (df['volume'] > df['vol_ma'] * PARAMS['volume']['vol_multiplier']) & (df['close'] < df['open'])\n","        df['cond_adx_strength'] = df['adx'] > PARAMS['trend']['adx_threshold'] # Uses calculated adx\n","        df['cond_adx_dir_buy'] = df['plus_di'] > df['minus_di'] # Uses calculated di\n","        df['cond_adx_dir_sell'] = df['minus_di'] > df['plus_di']\n","        df['cond_fib_bounce_buy'] = False; df['cond_fib_bounce_sell'] = False\n","        df['cond_ema_bounce_buy'] = False; df['cond_ema_bounce_sell'] = False\n","        df['cond_bb_bounce_buy'] = False; df['cond_bb_bounce_sell'] = False\n","\n","        buy_score = pd.Series(0.0, index=df.index); sell_score = pd.Series(0.0, index=df.index)\n","        if PARAMS['trend']['use_ema_trend_filter']: buy_score += df['cond_ema_trend_buy'] * weights.get('w_ema_trend', 0); sell_score += df['cond_ema_trend_sell'] * weights.get('w_ema_trend', 0)\n","        buy_score += df['cond_ema_signal_buy'] * weights.get('w_ema_signal', 0); sell_score += df['cond_ema_signal_sell'] * weights.get('w_ema_signal', 0)\n","        buy_score += df['cond_rsi_buy'] * weights.get('w_rsi_thresh', 0); sell_score += df['cond_rsi_sell'] * weights.get('w_rsi_thresh', 0)\n","        buy_score += df['cond_macd_signal_buy'] * weights.get('w_macd_signal', 0); sell_score += df['cond_macd_signal_sell'] * weights.get('w_macd_signal', 0)\n","        buy_score += df['cond_macd_zero_buy'] * weights.get('w_macd_zero', 0); sell_score += df['cond_macd_zero_sell'] * weights.get('w_macd_zero', 0)\n","        if PARAMS['core']['use_vol_breakout_buy'] or PARAMS['core']['use_vol_breakout_sell']: buy_score += df['cond_vol_break_buy'] * weights.get('w_vol_break', 0); sell_score += df['cond_vol_break_sell'] * weights.get('w_vol_break', 0)\n","        if PARAMS['trend']['use_adx_filter']: buy_score += (df['cond_adx_strength'] & df['cond_adx_dir_buy']) * weights.get('w_adx_strength', 0); sell_score += (df['cond_adx_strength'] & df['cond_adx_dir_sell']) * weights.get('w_adx_strength', 0)\n","        if PARAMS['trend']['use_adx_direction_filter']: buy_score += df['cond_adx_dir_buy'] * weights.get('w_adx_direction', 0); sell_score += df['cond_adx_dir_sell'] * weights.get('w_adx_direction', 0)\n","        df['buy_score_raw'] = buy_score; df['sell_score_raw'] = sell_score\n","        df['scaled_score'] = 5.0\n","        logger.info(\"Finished initial score calculation\")\n","        return df, total_possible_score\n","    except Exception as e:\n","        logger.error(f\"Error in calculate_score: {str(e)}\", exc_info=True)\n","        raise\n","\n","def calculate_rsi_divergence(df: pd.DataFrame) -> pd.DataFrame:\n","    # This function now relies on the 'rsi' column being present\n","    logger.info(f\"Calculating RSI divergence\")\n","    try:\n","        if 'rsi' not in df.columns:\n","             logger.error(\"RSI column not found for divergence calculation.\")\n","             df['bullish_rsi_div'] = False; df['bearish_rsi_div'] = False\n","             return df\n","        lookback = 14 # Default or get from PARAMS if needed\n","        df['bullish_rsi_div'] = False; df['bearish_rsi_div'] = False\n","        df['price_low_roll'] = df['low'].rolling(window=lookback, closed='left').min()\n","        df['rsi_low_roll'] = df['rsi'].rolling(window=lookback, closed='left').min()\n","        df['price_high_roll'] = df['high'].rolling(window=lookback, closed='left').max()\n","        df['rsi_high_roll'] = df['rsi'].rolling(window=lookback, closed='left').max()\n","        df['bullish_rsi_div'] = (df['low'] < df['price_low_roll']) & (df['rsi'] > df['rsi_low_roll'])\n","        df['bearish_rsi_div'] = (df['high'] > df['price_high_roll']) & (df['rsi'] < df['rsi_high_roll'])\n","        df = df.drop(columns=['price_low_roll', 'rsi_low_roll', 'price_high_roll', 'rsi_high_roll'], errors='ignore')\n","        logger.info(\"Finished calculating RSI divergence\")\n","        return df\n","    except Exception as e:\n","        logger.error(f\"Error in calculate_rsi_divergence: {str(e)}\", exc_info=True)\n","        raise\n","\n","def calculate_targets_for_trade(df: pd.DataFrame, entry_idx: int, position: str, entry_price: float, initial_stop: float) -> pd.DataFrame:\n","    # This function relies on 'atr' column being present\n","    try:\n","        current_idx = df.index[entry_idx]\n","        if 'atr' not in df.columns:\n","             logger.warning(f\"ATR column missing, cannot calculate ATR/RR targets for trade at index {entry_idx}.\")\n","             return df\n","        atr = df.loc[current_idx, 'atr']\n","\n","        fib_lookback = PARAMS['fibonacci']['fib_lookback_exit']\n","        fib_ext_level = PARAMS['fibonacci']['fib_extension_level']\n","        use_fib_target = PARAMS['fibonacci']['use_fib_exit']\n","        atr_mult_target = PARAMS['atr'].get('atr_mult', 2.0) # Use .get with default\n","\n","        if pd.isna(atr) or pd.isna(entry_price) or pd.isna(initial_stop):\n","            logger.warning(f\"Cannot calculate targets for trade at index {entry_idx} due to NaN inputs.\")\n","            return df\n","\n","        target_price_long_col = df['target_price_long'].copy()\n","        target_price_short_col = df['target_price_short'].copy()\n","        fib_target_long_col = df['fib_target_long'].copy()\n","        fib_target_short_col = df['fib_target_short'].copy()\n","\n","        if position == 'Long':\n","            atr_target = entry_price + (atr * atr_mult_target)\n","            risk = entry_price - initial_stop\n","            rr_target = entry_price + (risk * 2) if risk > 0 else np.nan\n","            fib_target = np.nan\n","            if use_fib_target:\n","                lookback_start = max(0, entry_idx - fib_lookback)\n","                swing_low_series = df['low'].iloc[lookback_start : entry_idx]\n","                if not swing_low_series.empty:\n","                    swing_low_price = swing_low_series.min()\n","                    swing_range = entry_price - swing_low_price\n","                    if swing_range > 0: fib_target = entry_price + (swing_range * fib_ext_level)\n","            fib_target_long_col.loc[current_idx:] = fib_target\n","            valid_targets = [t for t in [atr_target, rr_target, fib_target] if pd.notna(t)]\n","            if valid_targets: target_price_long_col.loc[current_idx:] = min(valid_targets)\n","\n","        elif position == 'Short':\n","            atr_target = entry_price - (atr * atr_mult_target)\n","            risk = initial_stop - entry_price\n","            rr_target = entry_price - (risk * 2) if risk > 0 else np.nan\n","            fib_target = np.nan\n","            if use_fib_target:\n","                lookback_start = max(0, entry_idx - fib_lookback)\n","                swing_high_series = df['high'].iloc[lookback_start : entry_idx]\n","                if not swing_high_series.empty:\n","                    swing_high_price = swing_high_series.max()\n","                    swing_range = swing_high_price - entry_price\n","                    if swing_range > 0: fib_target = entry_price - (swing_range * fib_ext_level)\n","            fib_target_short_col.loc[current_idx:] = fib_target\n","            valid_targets = [t for t in [atr_target, rr_target, fib_target] if pd.notna(t)]\n","            if valid_targets: target_price_short_col.loc[current_idx:] = max(valid_targets)\n","\n","        df['target_price_long'] = target_price_long_col\n","        df['target_price_short'] = target_price_short_col\n","        df['fib_target_long'] = fib_target_long_col\n","        df['fib_target_short'] = fib_target_short_col\n","\n","        return df\n","    except Exception as e:\n","        logger.error(f\"Error calculating targets for trade at index {entry_idx}: {str(e)}\", exc_info=True)\n","        return df\n","\n","# --- Main Signal Processing Function (Uses Calculated Indicators) ---\n","def process_signals(df: pd.DataFrame) -> pd.DataFrame:\n","    logger.info(\"Starting signal processing using calculated indicators\")\n","    try:\n","        # --- Ensure necessary columns exist after renaming ---\n","        required_internal_cols = [\n","            'open', 'high', 'low', 'close', 'volume', 'atr', 'rsi',\n","            'macd', 'macd_signal', 'macd_hist',\n","            'ema_fast', 'ema_med', 'ema_slow', # Renamed/Calculated\n","            'bb_middle', 'bb_upper', 'bb_lower', # Renamed\n","            'vol_ma', # Calculated by IndicatorCalculator (vol_sma_50 renamed)\n","            'adx', 'plus_di', 'minus_di' # Calculated by IndicatorCalculator\n","        ]\n","        missing_cols = [col for col in required_internal_cols if col not in df.columns]\n","        if missing_cols:\n","            raise ValueError(f\"DataFrame missing required columns for signal processing: {missing_cols}\")\n","\n","        # --- Indicator calculations are now done *before* calling this function ---\n","        # --- Calculate Features needed only for signals (Fib, Score, Divergence) ---\n","        df = calculate_fibonacci_levels(df)\n","        df, total_possible_score = calculate_score(df) # Get total score calculated once\n","        df = calculate_rsi_divergence(df) # Uses provided RSI\n","\n","        # --- Initialize Signal Columns ---\n","        df['signal'] = 'Hold'; df['position'] = ''; df['entry_price'] = np.nan\n","        df['stop_loss'] = np.nan; df['trailing_stop'] = np.nan; df['exit_price'] = np.nan\n","        df['exit_reason'] = ''; df['entry_signal_type'] = ''\n","        df['target_price_long'] = np.nan; df['target_price_short'] = np.nan\n","        df['fib_target_long'] = np.nan; df['fib_target_short'] = np.nan\n","\n","        # --- Determine Safe Start Index (based on strategy lookbacks) ---\n","        start_index = max(\n","            (PARAMS['fibonacci']['fib_pivot_lookback'] * 2 + 1),\n","            PARAMS['fibonacci']['fib_lookback_exit'],\n","            PARAMS['core']['fib_bounce_lookback'],\n","            PARAMS['core']['ema_bounce_lookback'],\n","            PARAMS['core']['bb_bounce_lookback'],\n","            5 # Lookback for volume breakout price action check\n","        ) + 1\n","\n","        # Ensure start index is valid after potential dropna in indicator calc\n","        if start_index >= len(df):\n","             logger.warning(f\"Not enough data after indicator calculations. Required: {start_index}, Available: {len(df)}\")\n","             if 'scaled_score' not in df.columns: df['scaled_score'] = 5.0\n","             return df\n","\n","        logger.info(f\"Starting main processing loop from index {start_index}\")\n","        trade_state = TradeState()\n","        weights = PARAMS['score_weights']\n","        # total_possible_score is passed from calculate_score\n","\n","        # --- Main Processing Loop ---\n","        for i in range(start_index, len(df)):\n","            current_idx = df.index[i]; prev_idx = df.index[i-1]\n","            current = df.iloc[i]; prev = df.iloc[i-1]\n","            exit_triggered_this_bar = False; exit_price_this_bar = np.nan; exit_reason = ''\n","\n","            # --- I. Check for Exits ---\n","            if trade_state.position is not None:\n","                trade_state.time_in_trade += 1\n","                trade_state.update_trailing_stop(current['low'], current['high'], current['close'], current['atr'])\n","                df.loc[current_idx, 'trailing_stop'] = trade_state.trailing_stop\n","                potential_exit_price = current['close']\n","\n","                # Exit Priority: SL > Div > Target > Score > EMA > BB > Vol > Time\n","                if PARAMS['atr']['use_atr_stop'] and trade_state.trailing_stop is not None:\n","                    if trade_state.position == 'Long' and current['low'] <= trade_state.trailing_stop: exit_reason='Trailing Stop'; exit_price_this_bar = min(current['open'], trade_state.trailing_stop); exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and current['high'] >= trade_state.trailing_stop: exit_reason='Trailing Stop'; exit_price_this_bar = max(current['open'], trade_state.trailing_stop); exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['rsi']['use_rsi_div_exit']:\n","                    if trade_state.position == 'Long' and current['bearish_rsi_div']: exit_reason='RSI Div'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and current['bullish_rsi_div']: exit_reason='RSI Div'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['fibonacci']['use_fib_exit']:\n","                    fib_target_long = df.loc[current_idx, 'fib_target_long']; fib_target_short = df.loc[current_idx, 'fib_target_short']\n","                    if trade_state.position == 'Long' and pd.notna(fib_target_long) and current['high'] >= fib_target_long: exit_reason='Fib Target'; exit_price_this_bar = max(current['open'], fib_target_long); exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and pd.notna(fib_target_short) and current['low'] <= fib_target_short: exit_reason='Fib Target'; exit_price_this_bar = min(current['open'], fib_target_short); exit_triggered_this_bar = True\n","\n","                # Recalculate score for exit check\n","                buy_score_bar_exit = df.loc[current_idx, 'buy_score_raw']; sell_score_bar_exit = df.loc[current_idx, 'sell_score_raw']\n","                if df.loc[current_idx, 'cond_fib_bounce_buy']: buy_score_bar_exit += weights.get('w_fib_bounce', 0)\n","                if df.loc[current_idx, 'cond_fib_bounce_sell']: sell_score_bar_exit += weights.get('w_fib_bounce', 0)\n","                if df.loc[current_idx, 'cond_ema_bounce_buy']: buy_score_bar_exit += weights.get('w_ema_bounce', 0)\n","                if df.loc[current_idx, 'cond_ema_bounce_sell']: sell_score_bar_exit += weights.get('w_ema_bounce', 0)\n","                if df.loc[current_idx, 'cond_bb_bounce_buy']: buy_score_bar_exit += weights.get('w_bb_bounce', 0)\n","                if df.loc[current_idx, 'cond_bb_bounce_sell']: sell_score_bar_exit += weights.get('w_bb_bounce', 0)\n","                net_score_bar_exit = buy_score_bar_exit - sell_score_bar_exit\n","                scaled_score_bar_exit = max(0.0, min(10.0, ((net_score_bar_exit / total_possible_score) * 5.0) + 5.0))\n","                df.loc[current_idx, 'scaled_score'] = scaled_score_bar_exit # Update final score\n","\n","                if not exit_triggered_this_bar and PARAMS['core']['use_score_drop_exit']:\n","                    score_threshold = PARAMS['core']['exit_score_drop_threshold']\n","                    if trade_state.position == 'Long' and scaled_score_bar_exit < (5.0 - score_threshold): exit_reason=f'Score Drop ({scaled_score_bar_exit:.1f})'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and scaled_score_bar_exit > (5.0 + score_threshold): exit_reason=f'Score Drop ({scaled_score_bar_exit:.1f})'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['ema']['use_ema_exit']:\n","                    fast_ema_cross_med_sell = current['ema_fast'] < current['ema_med'] and prev['ema_fast'] >= prev['ema_med']; fast_ema_cross_med_buy = current['ema_fast'] > current['ema_med'] and prev['ema_fast'] <= prev['ema_med']\n","                    if trade_state.position == 'Long' and fast_ema_cross_med_sell: exit_reason='EMA Cross'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and fast_ema_cross_med_buy: exit_reason='EMA Cross'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['bollinger']['use_bb_return_exit']:\n","                    cross_under_bb_mid = current['close'] < current['bb_middle'] and prev['close'] >= prev['bb_middle']; cross_over_bb_mid = current['close'] > current['bb_middle'] and prev['close'] <= prev['bb_middle']\n","                    if trade_state.position == 'Long' and cross_under_bb_mid: exit_reason='BB Mid Exit'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and cross_over_bb_mid: exit_reason='BB Mid Exit'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['volume']['use_vol_fade_exit']:\n","                    low_vol = current['volume'] < df.loc[prev_idx, 'vol_ma']; pullback_long = current['close'] < current['ema_fast']; pullback_short = current['close'] > current['ema_fast']\n","                    if trade_state.position == 'Long' and low_vol and pullback_long: exit_reason='Vol Fade'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and low_vol and pullback_short: exit_reason='Vol Fade'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and trade_state.time_in_trade >= PARAMS['core']['max_trade_duration']: exit_reason='Time Exit'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","\n","                if exit_triggered_this_bar:\n","                    signal_prefix = 'Exit Long' if trade_state.position == 'Long' else 'Exit Short'\n","                    df.loc[current_idx, 'signal'] = signal_prefix\n","                    df.loc[current_idx, 'exit_reason'] = exit_reason\n","                    df.loc[current_idx, 'exit_price'] = exit_price_this_bar\n","                    trade_state.reset()\n","                    df.loc[current_idx:, ['target_price_long', 'target_price_short', 'fib_target_long', 'fib_target_short']] = np.nan\n","\n","            # --- II. Check for Entries ---\n","            if trade_state.position is None and not exit_triggered_this_bar:\n","                entry_signal = None; buy_score_bar = df.loc[current_idx, 'buy_score_raw']; sell_score_bar = df.loc[current_idx, 'sell_score_raw']\n","                df.loc[current_idx, ['cond_fib_bounce_buy', 'cond_fib_bounce_sell','cond_ema_bounce_buy', 'cond_ema_bounce_sell','cond_bb_bounce_buy', 'cond_bb_bounce_sell']] = False\n","\n","                # Calculate bounce/breakout conditions & update score\n","                fib_bounce_buy_cond = False; fib_bounce_sell_cond = False\n","                if PARAMS['core']['use_fib_bounce_entry'] or PARAMS['core']['use_fib_bounce_sell']:\n","                    lookback=PARAMS['core']['fib_bounce_lookback']; low_zone_long, high_zone_long = PARAMS['core']['fib_bounce_long_zone']; low_zone_short, high_zone_short = PARAMS['core']['fib_bounce_short_zone']; conf_level = PARAMS['core']['fib_bounce_confirmation_level']; rsi_conf = PARAMS['rsi']['rsi_confirm_fib']; rsi_buy_lvl, rsi_sell_lvl = PARAMS['rsi']['rsi_confirm_level_buy'], PARAMS['rsi']['rsi_confirm_level_sell']\n","                    if PARAMS['core']['use_fib_bounce_entry'] and current['is_uptrend_fib']:\n","                        fib_low_name = f'fib_{int(low_zone_long*1000)}'; fib_high_name = f'fib_{int(high_zone_long*1000)}'; fib_conf_name = f'fib_{int(conf_level*1000)}'\n","                        if fib_low_name in df.columns and fib_high_name in df.columns and fib_conf_name in df.columns:\n","                            fib_low = current[fib_low_name]; fib_high = current[fib_high_name]; fib_conf = current[fib_conf_name]\n","                            if pd.notna(fib_low) and pd.notna(fib_high) and pd.notna(fib_conf):\n","                                touched_zone = (df['low'].iloc[i-lookback:i] <= fib_high).any(); bounced_above = current['close'] > fib_conf; rsi_ok = not rsi_conf or (current['rsi'] > rsi_buy_lvl and current['rsi'] > prev['rsi'])\n","                                if touched_zone and bounced_above and rsi_ok: fib_bounce_buy_cond = True; df.loc[current_idx, 'cond_fib_bounce_buy'] = True; buy_score_bar += weights.get('w_fib_bounce', 0)\n","                    if PARAMS['core']['use_fib_bounce_sell'] and not current['is_uptrend_fib']:\n","                        fib_low_name = f'fib_{int(low_zone_short*1000)}'; fib_high_name = f'fib_{int(high_zone_short*1000)}'; fib_conf_name = f'fib_{int(conf_level*1000)}'\n","                        if fib_low_name in df.columns and fib_high_name in df.columns and fib_conf_name in df.columns:\n","                            fib_low = current[fib_low_name]; fib_high = current[fib_high_name]; fib_conf = current[fib_conf_name]\n","                            if pd.notna(fib_low) and pd.notna(fib_high) and pd.notna(fib_conf):\n","                                touched_zone = (df['high'].iloc[i-lookback:i] >= fib_low).any(); bounced_below = current['close'] < fib_conf; rsi_ok = not rsi_conf or (current['rsi'] < rsi_sell_lvl and current['rsi'] < prev['rsi'])\n","                                if touched_zone and bounced_below and rsi_ok: fib_bounce_sell_cond = True; df.loc[current_idx, 'cond_fib_bounce_sell'] = True; sell_score_bar += weights.get('w_fib_bounce', 0)\n","                ema_bounce_buy_cond = False; ema_bounce_sell_cond = False\n","                if PARAMS['core']['use_ema_bounce_buy'] or PARAMS['core']['use_ema_bounce_sell']:\n","                    lookback=PARAMS['core']['ema_bounce_lookback']; ema_source_col = 'ema_fast'; ema_source = df[ema_source_col]; rsi_conf = PARAMS['rsi']['rsi_confirm_ema']; rsi_buy_lvl, rsi_sell_lvl = PARAMS['rsi']['rsi_confirm_level_buy'], PARAMS['rsi']['rsi_confirm_level_sell']\n","                    if PARAMS['core']['use_ema_bounce_buy']:\n","                         touched_ema = (df['low'].iloc[i-lookback:i] <= ema_source.iloc[i-lookback:i]).any(); bounced_above = current['close'] > current[ema_source_col] and current['close'] > current['open']; rsi_ok = not rsi_conf or (current['rsi'] > rsi_buy_lvl and current['rsi'] > prev['rsi'])\n","                         if touched_ema and bounced_above and rsi_ok: ema_bounce_buy_cond = True; df.loc[current_idx, 'cond_ema_bounce_buy'] = True; buy_score_bar += weights.get('w_ema_bounce', 0)\n","                    if PARAMS['core']['use_ema_bounce_sell']:\n","                        touched_ema = (df['high'].iloc[i-lookback:i] >= ema_source.iloc[i-lookback:i]).any(); bounced_below = current['close'] < current[ema_source_col] and current['close'] < current['open']; rsi_ok = not rsi_conf or (current['rsi'] < rsi_sell_lvl and current['rsi'] < prev['rsi'])\n","                        if touched_ema and bounced_below and rsi_ok: ema_bounce_sell_cond = True; df.loc[current_idx, 'cond_ema_bounce_sell'] = True; sell_score_bar += weights.get('w_ema_bounce', 0)\n","                bb_bounce_buy_cond = False; bb_bounce_sell_cond = False\n","                if PARAMS['core']['use_bb_mid_bounce_buy'] or PARAMS['core']['use_bb_mid_bounce_sell']:\n","                    lookback=PARAMS['core']['bb_bounce_lookback']; bb_mid = df['bb_middle']; rsi_conf = PARAMS['rsi']['rsi_confirm_bb']; rsi_buy_lvl, rsi_sell_lvl = PARAMS['rsi']['rsi_confirm_level_buy'], PARAMS['rsi']['rsi_confirm_level_sell']\n","                    if PARAMS['core']['use_bb_mid_bounce_buy']:\n","                        touched_bb = (df['low'].iloc[i-lookback:i] <= bb_mid.iloc[i-lookback:i]).any(); bounced_above = current['close'] > current['bb_middle'] and current['close'] > current['open']; rsi_ok = not rsi_conf or (current['rsi'] > rsi_buy_lvl and current['rsi'] > prev['rsi'])\n","                        if touched_bb and bounced_above and rsi_ok: bb_bounce_buy_cond = True; df.loc[current_idx, 'cond_bb_bounce_buy'] = True; buy_score_bar += weights.get('w_bb_bounce', 0)\n","                    if PARAMS['core']['use_bb_mid_bounce_sell']:\n","                        touched_bb = (df['high'].iloc[i-lookback:i] >= bb_mid.iloc[i-lookback:i]).any(); bounced_below = current['close'] < current['bb_middle'] and current['close'] < current['open']; rsi_ok = not rsi_conf or (current['rsi'] < rsi_sell_lvl and current['rsi'] < prev['rsi'])\n","                        if touched_bb and bounced_below and rsi_ok: bb_bounce_sell_cond = True; df.loc[current_idx, 'cond_bb_bounce_sell'] = True; sell_score_bar += weights.get('w_bb_bounce', 0)\n","                vol_breakout_buy_cond = False; vol_breakout_sell_cond = False\n","                if PARAMS['core']['use_vol_breakout_buy'] or PARAMS['core']['use_vol_breakout_sell']:\n","                    high_vol = current['volume'] > current['vol_ma'] * PARAMS['volume']['vol_multiplier']; lookback_pa = 5\n","                    if i >= lookback_pa: recent_high = df['high'].iloc[i-lookback_pa:i].max(); recent_low = df['low'].iloc[i-lookback_pa:i].min()\n","                    else: recent_high = np.nan; recent_low = np.nan\n","                    if pd.notna(recent_high) and PARAMS['core']['use_vol_breakout_buy'] and high_vol and current['close'] > current['open'] and current['close'] > recent_high: vol_breakout_buy_cond = True\n","                    if pd.notna(recent_low) and PARAMS['core']['use_vol_breakout_sell'] and high_vol and current['close'] < current['open'] and current['close'] < recent_low: vol_breakout_sell_cond = True\n","\n","                # Final score calculation for the bar\n","                net_score_bar = buy_score_bar - sell_score_bar\n","                scaled_score_bar = max(0.0, min(10.0, ((net_score_bar / total_possible_score) * 5.0) + 5.0)) # Use pre-calculated total score\n","                df.loc[current_idx, 'scaled_score'] = scaled_score_bar\n","\n","                # Trend Filters\n","                trend_ok_buy = True; trend_ok_sell = True\n","                if PARAMS['trend']['use_ema_trend_filter']: trend_ok_buy &= current['cond_ema_trend_buy']; trend_ok_sell &= current['cond_ema_trend_sell']\n","                if PARAMS['trend']['use_adx_filter']: trend_ok_buy &= current['cond_adx_strength']; trend_ok_sell &= current['cond_adx_strength']\n","                if PARAMS['trend']['use_adx_direction_filter']: trend_ok_buy &= current['cond_adx_dir_buy']; trend_ok_sell &= current['cond_adx_dir_sell']\n","\n","                # Entry Decision\n","                entry_score_threshold = PARAMS['core']['entry_score_threshold']\n","                if trend_ok_buy and scaled_score_bar >= entry_score_threshold:\n","                    if fib_bounce_buy_cond: entry_signal = \"Fib Bounce Long\"\n","                    elif ema_bounce_buy_cond: entry_signal = \"EMA Bounce Long\"\n","                    elif bb_bounce_buy_cond: entry_signal = \"BB Bounce Long\"\n","                    elif vol_breakout_buy_cond: entry_signal = \"Vol Breakout Long\"\n","                    elif df.loc[current_idx,'cond_ema_signal_buy'] and df.loc[current_idx,'cond_rsi_buy']: entry_signal = \"Basic Long\"\n","                elif trend_ok_sell and scaled_score_bar <= (10.0 - entry_score_threshold):\n","                    if fib_bounce_sell_cond: entry_signal = \"Fib Bounce Short\"\n","                    elif ema_bounce_sell_cond: entry_signal = \"EMA Bounce Short\"\n","                    elif bb_bounce_sell_cond: entry_signal = \"BB Bounce Short\"\n","                    elif vol_breakout_sell_cond: entry_signal = \"Vol Breakout Short\"\n","                    elif df.loc[current_idx,'cond_ema_signal_sell'] and df.loc[current_idx,'cond_rsi_sell']: entry_signal = \"Basic Short\"\n","\n","                # Process Entry\n","                if entry_signal:\n","                    entry_price_adj = current['close'] * (1 + PARAMS['backtest']['slippage_pct']) if \"Long\" in entry_signal else current['close'] * (1 - PARAMS['backtest']['slippage_pct'])\n","                    trade_state.entry_price = entry_price_adj; trade_state.entry_index = i; trade_state.time_in_trade = 0\n","                    if \"Long\" in entry_signal:\n","                        trade_state.position = 'Long'; trade_state.highest_high_in_trade = current['high']\n","                        initial_stop = current['low'] - current['atr'] * PARAMS['core']['trailing_stop_atr_multiplier']\n","                        trade_state.trailing_stop = initial_stop; df.loc[current_idx, 'signal'] = 'Long'; df.loc[current_idx, 'stop_loss'] = initial_stop\n","                    elif \"Short\" in entry_signal:\n","                        trade_state.position = 'Short'; trade_state.lowest_low_in_trade = current['low']\n","                        initial_stop = current['high'] + current['atr'] * PARAMS['core']['trailing_stop_atr_multiplier']\n","                        trade_state.trailing_stop = initial_stop; df.loc[current_idx, 'signal'] = 'Short'; df.loc[current_idx, 'stop_loss'] = initial_stop\n","                    df.loc[current_idx, 'position'] = trade_state.position; df.loc[current_idx, 'entry_price'] = trade_state.entry_price\n","                    df.loc[current_idx, 'entry_signal_type'] = entry_signal; df.loc[current_idx, 'trailing_stop'] = trade_state.trailing_stop\n","                    df = calculate_targets_for_trade(df, i, trade_state.position, trade_state.entry_price, initial_stop)\n","\n","            # --- III. Update Position State ---\n","            if trade_state.position is not None and df.loc[current_idx, 'signal'] == 'Hold':\n","                df.loc[current_idx, 'position'] = trade_state.position\n","                df.loc[current_idx, 'entry_price'] = trade_state.entry_price\n","\n","        logger.info(\"Finished main processing loop\")\n","        return df\n","    except Exception as e:\n","        logger.error(f\"Error in process_signals: {str(e)}\", exc_info=True)\n","        raise\n","\n","# --- EnhancedSignalAnalyzer Class ---\n","# (Keep the EnhancedSignalAnalyzer class definition as it was in strategy_merged_analyzer_v3)\n","class EnhancedSignalAnalyzer:\n","    def __init__(self):\n","        self.trade_history = []\n","        self.summary_stats = defaultdict(float)\n","        self.entry_stats = defaultdict(lambda: defaultdict(float))\n","        self.exit_stats = defaultdict(lambda: defaultdict(float))\n","        self.signal_stats = defaultdict(lambda: defaultdict(float))\n","\n","    def analyze_trades(self, df: pd.DataFrame):\n","        logger.info(\"Analyzing generated trades for detailed statistics\")\n","        try:\n","            self.trade_history = []\n","            current_trade = None\n","            running_pnl = 0.0; peak_pnl = 0.0; max_drawdown = 0.0\n","            win_pnls = []; loss_pnls = []\n","            win_durations = []; loss_durations = []\n","            risk_rewards = []\n","            current_streak = 0; max_consec_wins = 0; max_consec_losses = 0\n","            current_streak_type = None\n","\n","            for i in range(len(df)):\n","                current_idx = df.index[i]\n","                signal = df.loc[current_idx, 'signal']\n","\n","                if signal in ['Long', 'Short'] and current_trade is None:\n","                    entry_price = df.loc[current_idx, 'entry_price']\n","                    stop_loss = df.loc[current_idx, 'stop_loss']\n","                    target_price_col = 'target_price_long' if signal == 'Long' else 'target_price_short'\n","                    target_price = df.loc[current_idx, target_price_col]\n","                    if pd.notna(entry_price) and pd.notna(stop_loss):\n","                        current_trade = {'entry_index': i, 'entry_idx_time': current_idx, 'entry_price': entry_price, 'position': signal, 'stop_loss': stop_loss, 'target_price': target_price, 'signal_type': df.loc[current_idx, 'entry_signal_type']}\n","                        if current_trade['position'] == 'Long': risk = current_trade['entry_price'] - current_trade['stop_loss']; reward = current_trade['target_price'] - current_trade['entry_price'] if pd.notna(current_trade['target_price']) else np.nan\n","                        else: risk = current_trade['stop_loss'] - current_trade['entry_price']; reward = current_trade['entry_price'] - current_trade['target_price'] if pd.notna(current_trade['target_price']) else np.nan\n","                        current_trade['risk_at_entry'] = risk; current_trade['reward_at_entry'] = reward\n","                        current_trade['risk_reward_ratio'] = reward / risk if risk > 0 and pd.notna(reward) else np.nan\n","\n","                elif current_trade and 'Exit' in signal:\n","                    exit_price = df.loc[current_idx, 'exit_price']\n","                    if pd.isna(exit_price): exit_price = df.loc[current_idx, 'close']; logger.warning(f\"Exit price NaN for trade entered on {current_trade['entry_idx_time'].date()}, using close price {exit_price:.2f}\")\n","                    exit_idx_time = current_idx; exit_reason = df.loc[current_idx, 'exit_reason']\n","                    if current_trade['position'] == 'Long': pnl_points = exit_price - current_trade['entry_price']\n","                    else: pnl_points = current_trade['entry_price'] - exit_price\n","                    commission = (current_trade['entry_price'] + exit_price) * PARAMS['backtest']['commission_pct']\n","                    net_pnl_points = pnl_points - commission\n","                    pct_change = (net_pnl_points / current_trade['entry_price']) * 100 if current_trade['entry_price'] else 0\n","                    duration_delta = exit_idx_time - current_trade['entry_idx_time']; duration_bars = i - current_trade['entry_index']\n","                    outcome = 'Win' if net_pnl_points > 0 else 'Loss'\n","                    trade_record = {**current_trade, 'exit_idx_time': exit_idx_time, 'exit_price': exit_price, 'pnl_points': net_pnl_points, 'pct_change': pct_change, 'duration_delta': duration_delta, 'duration_bars': duration_bars, 'outcome': outcome, 'exit_reason': exit_reason}\n","                    self.trade_history.append(trade_record)\n","                    self.summary_stats['total_trades'] += 1; self.summary_stats['total_pnl'] += net_pnl_points\n","                    if outcome == 'Win': self.summary_stats['winning_trades'] += 1; win_pnls.append(net_pnl_points); win_durations.append(duration_bars)\n","                    else: self.summary_stats['losing_trades'] += 1; loss_pnls.append(abs(net_pnl_points)); loss_durations.append(duration_bars)\n","                    if pd.notna(current_trade['risk_reward_ratio']): risk_rewards.append(current_trade['risk_reward_ratio'])\n","                    if outcome == current_streak_type: current_streak += 1\n","                    else: current_streak = 1; current_streak_type = outcome\n","                    if outcome == 'Win': max_consec_wins = max(max_consec_wins, current_streak)\n","                    else: max_consec_losses = max(max_consec_losses, current_streak)\n","                    running_pnl += net_pnl_points; peak_pnl = max(peak_pnl, running_pnl); drawdown = peak_pnl - running_pnl\n","                    self.summary_stats['max_drawdown_points'] = max(self.summary_stats.get('max_drawdown_points', 0.0), drawdown)\n","                    pos = current_trade['position']; sig_type = current_trade['signal_type']; exit_type = exit_reason\n","                    self.entry_stats[pos]['total'] += 1; self.entry_stats[pos]['total_pnl'] += net_pnl_points; self.entry_stats[pos]['total_duration_bars'] += duration_bars\n","                    if outcome == 'Win': self.entry_stats[pos]['success'] += 1\n","                    if exit_type == 'Trailing Stop' or exit_type == 'ATR Stop': self.entry_stats[pos]['sl_hit'] += 1\n","                    if exit_type == 'Fib Target' or exit_type == 'Target': self.entry_stats[pos]['target_hit'] += 1\n","                    self.exit_stats[exit_type]['total'] += 1; self.exit_stats[exit_type]['total_pnl'] += net_pnl_points; self.exit_stats[exit_type]['total_duration_bars'] += duration_bars\n","                    if outcome == 'Win': self.exit_stats[exit_type]['success'] += 1\n","                    self.signal_stats[sig_type]['total'] += 1; self.signal_stats[sig_type]['total_pnl'] += net_pnl_points\n","                    if outcome == 'Win': self.signal_stats[sig_type]['success'] += 1\n","                    current_trade = None\n","\n","            if self.summary_stats['total_trades'] > 0:\n","                avg_win = np.mean(win_pnls) if win_pnls else 0; avg_loss = np.mean(loss_pnls) if loss_pnls else 0\n","                self.summary_stats['win_rate'] = (self.summary_stats['winning_trades'] / self.summary_stats['total_trades']) * 100\n","                self.summary_stats['avg_win_points'] = avg_win; self.summary_stats['avg_loss_points'] = avg_loss\n","                self.summary_stats['profit_factor'] = abs(sum(win_pnls) / sum(loss_pnls)) if sum(loss_pnls) != 0 else np.inf\n","                self.summary_stats['expectancy_points'] = (avg_win * (self.summary_stats['win_rate']/100)) - (avg_loss * (1 - self.summary_stats['win_rate']/100))\n","                self.summary_stats['max_consec_wins'] = max_consec_wins; self.summary_stats['max_consec_losses'] = max_consec_losses\n","                self.summary_stats['avg_win_duration_bars'] = np.mean(win_durations) if win_durations else 0\n","                self.summary_stats['avg_loss_duration_bars'] = np.mean(loss_durations) if loss_durations else 0\n","                self.summary_stats['avg_risk_reward_ratio'] = np.nanmean(risk_rewards) if risk_rewards else np.nan\n","                health_score = min(100, max(0, (self.summary_stats['win_rate'] * 0.4) + (min(self.summary_stats['profit_factor'], 5) * 10 if pd.notna(self.summary_stats['profit_factor']) else 0) + (1 - (self.summary_stats['avg_loss_duration_bars']/self.summary_stats['avg_win_duration_bars'] if self.summary_stats['avg_win_duration_bars'] > 0 else 1) * 20) + (self.summary_stats['avg_risk_reward_ratio'] * 10 if pd.notna(self.summary_stats['avg_risk_reward_ratio']) else 0) ))\n","                self.summary_stats['health_score'] = health_score\n","\n","            for pos in list(self.entry_stats.keys()):\n","                if self.entry_stats[pos]['total'] > 0: self.entry_stats[pos]['avg_pnl'] = self.entry_stats[pos]['total_pnl'] / self.entry_stats[pos]['total']; self.entry_stats[pos]['avg_duration_bars'] = self.entry_stats[pos]['total_duration_bars'] / self.entry_stats[pos]['total']; self.entry_stats[pos]['win_rate'] = (self.entry_stats[pos]['success'] / self.entry_stats[pos]['total']) * 100; self.entry_stats[pos]['sl_rate'] = (self.entry_stats[pos]['sl_hit'] / self.entry_stats[pos]['total']) * 100; self.entry_stats[pos]['target_rate'] = (self.entry_stats[pos]['target_hit'] / self.entry_stats[pos]['total']) * 100\n","            for exit_type in list(self.exit_stats.keys()):\n","                 if self.exit_stats[exit_type]['total'] > 0: self.exit_stats[exit_type]['avg_pnl'] = self.exit_stats[exit_type]['total_pnl'] / self.exit_stats[exit_type]['total']; self.exit_stats[exit_type]['avg_duration_bars'] = self.exit_stats[exit_type]['total_duration_bars'] / self.exit_stats[exit_type]['total']; self.exit_stats[exit_type]['win_rate'] = (self.exit_stats[exit_type]['success'] / self.exit_stats[exit_type]['total']) * 100\n","            for sig_type in list(self.signal_stats.keys()):\n","                 if self.signal_stats[sig_type]['total'] > 0: self.signal_stats[sig_type]['avg_pnl'] = self.signal_stats[sig_type]['total_pnl'] / self.signal_stats[sig_type]['total']; self.signal_stats[sig_type]['win_rate'] = (self.signal_stats[sig_type]['success'] / self.signal_stats[sig_type]['total']) * 100\n","\n","            logger.info(\"Finished analyzing trades.\")\n","            return df\n","        except Exception as e:\n","            logger.error(f\"Error in analyze_trades: {str(e)}\", exc_info=True)\n","            raise\n","\n","    def print_summary(self):\n","        if not self.summary_stats or self.summary_stats['total_trades'] == 0:\n","             print(\"\\nNo trades to summarize.\")\n","             logger.info(\"No trades to summarize.\")\n","             return\n","        try:\n","            summary = [ f\"\\n=== ENHANCED TRADE SUMMARY ===\", f\"Total Trades: {int(self.summary_stats['total_trades'])}\", f\"Winning Trades: {int(self.summary_stats['winning_trades'])} ({self.summary_stats['win_rate']:.1f}%)\", f\"Losing Trades: {int(self.summary_stats['losing_trades'])}\", f\"Total P&L (Points): {self.summary_stats['total_pnl']:.2f}\", f\"Profit Factor: {self.summary_stats['profit_factor']:.2f}\", f\"Expectancy (Points): {self.summary_stats['expectancy_points']:.2f}\", f\"Max Drawdown (Points): {self.summary_stats['max_drawdown_points']:.2f}\", f\"Avg Win / Avg Loss (Points): {self.summary_stats['avg_win_points']:.2f} / {self.summary_stats['avg_loss_points']:.2f}\", f\"Max Consecutive Wins: {int(self.summary_stats['max_consec_wins'])}\", f\"Max Consecutive Losses: {int(self.summary_stats['max_consec_losses'])}\", f\"Avg Win Duration (Bars): {self.summary_stats['avg_win_duration_bars']:.1f}\", f\"Avg Loss Duration (Bars): {self.summary_stats['avg_loss_duration_bars']:.1f}\", f\"Avg Risk/Reward Ratio (at Entry): {self.summary_stats['avg_risk_reward_ratio']:.2f}:1\" if pd.notna(self.summary_stats['avg_risk_reward_ratio']) else \"N/A\", f\"Strategy Health Score: {self.summary_stats['health_score']:.1f}/100\", \"\\n=== ENTRY STATISTICS ===\", \"Position | Total | Win % | Avg P&L | Avg Dur | SL % | Target %\", \"-------------------------------------------------------------\"]\n","            for position, stats in self.entry_stats.items(): summary.append(f\"{position:8} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f} | {stats['avg_duration_bars']:7.1f} | {stats['sl_rate']:4.1f}% | {stats['target_rate']:6.1f}%\")\n","            summary.extend([\"\\n=== EXIT STATISTICS ===\", \"Exit Type           | Total | Win % | Avg P&L | Avg Dur\", \"------------------------------------------------------\"])\n","            for exit_type, stats in sorted(self.exit_stats.items()): summary.append(f\"{str(exit_type):19} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f} | {stats['avg_duration_bars']:7.1f}\")\n","            summary.extend([\"\\n=== SIGNAL TYPE STATISTICS ===\", \"Signal Type          | Total | Win % | Avg P&L\", \"---------------------------------------------\"])\n","            for signal_type, stats in sorted(self.signal_stats.items()):\n","                 if not signal_type: continue\n","                 summary.append(f\"{str(signal_type):20} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f}\")\n","\n","            print(\"\\n\".join(summary)); logger.info(\"\\n\".join(summary))\n","            health = self.summary_stats['health_score']\n","            if health >= 70: health_indicator = \" STRONG\"\n","            elif health >= 50: health_indicator = \" MODERATE\"\n","            else: health_indicator = \" WEAK\"\n","            print(f\"\\nStrategy Health: {health_indicator}\")\n","            if self.summary_stats['total_trades'] < 30: print(\"  Warning: Low sample size (<30 trades)\")\n","        except Exception as e:\n","            logger.error(f\"Error printing summary: {str(e)}\", exc_info=True)\n","            raise\n","\n","# --- Plotting Function ---\n","# (Keep the plot_signals function as it was in strategy_merged_analyzer_v3)\n","def plot_signals(df: pd.DataFrame, save_path: Optional[Path] = None):\n","    logger.info(\"Generating signal plot\")\n","    plt.style.use('seaborn-v0_8-darkgrid')\n","    fig, axes = plt.subplots(4, 1, sharex=True, figsize=(20, 15))\n","    if df.empty: logger.warning(\"Plotting skipped: DataFrame is empty.\"); return\n","\n","    ax1 = axes[0] # Price Chart\n","    ax1.plot(df['close'], label='Price', color='black', alpha=0.9, linewidth=1.0)\n","    if 'ema_fast' in df.columns: ax1.plot(df['ema_fast'], label=f\"EMA Fast\", alpha=0.6, linewidth=0.8)\n","    if 'ema_med' in df.columns: ax1.plot(df['ema_med'], label=f\"EMA Med ({PARAMS['ema']['med_len']})\", alpha=0.6, linewidth=0.8)\n","    if 'ema_slow' in df.columns: ax1.plot(df['ema_slow'], label=f\"EMA Slow\", alpha=0.6, linewidth=0.8)\n","    long_entries = df[df['signal'] == 'Long']; short_entries = df[df['signal'] == 'Short']\n","    long_exits = df[df['signal'].str.contains('Exit Long', na=False)]; short_exits = df[df['signal'].str.contains('Exit Short', na=False)]\n","    if not long_entries.empty: ax1.scatter(long_entries.index, long_entries['entry_price'], marker='^', color='lime', s=100, label='Long Entry', zorder=5, edgecolors='black')\n","    if not short_entries.empty: ax1.scatter(short_entries.index, short_entries['entry_price'], marker='v', color='red', s=100, label='Short Entry', zorder=5, edgecolors='black')\n","    # Plot exits at exit_price if available, otherwise close\n","    exit_long_prices = long_exits['exit_price'].fillna(long_exits['close'])\n","    exit_short_prices = short_exits['exit_price'].fillna(short_exits['close'])\n","    if not long_exits.empty: ax1.scatter(long_exits.index, exit_long_prices, marker='x', color='fuchsia', s=80, label='Exit', zorder=5)\n","    if not short_exits.empty: ax1.scatter(short_exits.index, exit_short_prices, marker='x', color='fuchsia', s=80, zorder=5)\n","    if 'trailing_stop' in df.columns: ax1.plot(df['trailing_stop'], label='Trailing Stop', linestyle='--', color='purple', alpha=0.7, linewidth=1.0)\n","    if 'target_price_long' in df.columns: ax1.scatter(df.index, df['target_price_long'], marker='_', color='blue', alpha=0.5, s=50, label='Long Target')\n","    if 'target_price_short' in df.columns: ax1.scatter(df.index, df['target_price_short'], marker='_', color='orange', alpha=0.5, s=50, label='Short Target')\n","    ax1.legend(loc='upper left'); ax1.set_title('Price, EMAs, Signals, Stops & Targets'); ax1.set_ylabel('Price'); ax1.grid(True, which='both', linestyle=':', linewidth=0.5)\n","\n","    ax_score = axes[1] # Score Chart\n","    if 'scaled_score' in df.columns:\n","        ax_score.plot(df['scaled_score'], label='Scaled Score (0-10)', color='teal', linewidth=1.5)\n","        ax_score.axhline(PARAMS['core']['entry_score_threshold'], color='green', linestyle='--', alpha=0.5, label=f'Long Entry Thresh')\n","        ax_score.axhline(10.0 - PARAMS['core']['entry_score_threshold'], color='red', linestyle='--', alpha=0.5, label=f'Short Entry Thresh')\n","        if PARAMS['core']['use_score_drop_exit']:\n","            ax_score.axhline(5.0 - PARAMS['core']['exit_score_drop_threshold'], color='red', linestyle=':', alpha=0.4, label=f'Long Exit Drop')\n","            ax_score.axhline(5.0 + PARAMS['core']['exit_score_drop_threshold'], color='green', linestyle=':', alpha=0.4, label=f'Short Exit Drop')\n","        ax_score.set_ylim(0, 10); ax_score.legend(loc='upper left'); ax_score.set_title('Confidence Score'); ax_score.set_ylabel('Score'); ax_score.grid(True, which='both', linestyle=':', linewidth=0.5)\n","    else: ax_score.set_title('Confidence Score (Not Calculated)'); ax_score.grid(True)\n","\n","    ax_rsi = axes[2] # RSI Chart\n","    if 'rsi' in df.columns:\n","        ax_rsi.plot(df['rsi'], label='RSI', color='orange', linewidth=1.0)\n","        ax_rsi.axhline(50, linestyle='--', color='gray', alpha=0.5); ax_rsi.axhline(PARAMS['rsi']['rsi_buy_level'], linestyle=':', color='green', alpha=0.4); ax_rsi.axhline(PARAMS['rsi']['rsi_sell_level'], linestyle=':', color='red', alpha=0.4)\n","        if 'bullish_rsi_div' in df.columns and 'bearish_rsi_div' in df.columns:\n","            bull_div = df[df['bullish_rsi_div']]; bear_div = df[df['bearish_rsi_div']]\n","            if not bull_div.empty: ax_rsi.scatter(bull_div.index, bull_div['rsi'] * 0.98, marker='^', color='cyan', s=50, label='Bullish Div', zorder=5)\n","            if not bear_div.empty: ax_rsi.scatter(bear_div.index, bear_div['rsi'] * 1.02, marker='v', color='magenta', s=50, label='Bearish Div', zorder=5)\n","        ax_rsi.legend(loc='upper left'); ax_rsi.set_title('RSI & Divergence'); ax_rsi.set_ylabel('RSI'); ax_rsi.grid(True, which='both', linestyle=':', linewidth=0.5)\n","    else: ax_rsi.set_title('RSI (Not Calculated)'); ax_rsi.grid(True)\n","\n","    ax_macd = axes[3] # MACD Chart\n","    if 'macd' in df.columns and 'macd_signal' in df.columns and 'macd_hist' in df.columns:\n","        ax_macd.plot(df['macd'], label='MACD', color='blue', linewidth=1.0); ax_macd.plot(df['macd_signal'], label='Signal', color='red', alpha=0.8, linewidth=1.0)\n","        colors = ['g' if v >= 0 else 'r' for v in df['macd_hist']]; ax_macd.bar(df.index, df['macd_hist'], label='Histogram', color=colors, alpha=0.5)\n","        ax_macd.axhline(0, linestyle='--', color='gray', alpha=0.5); ax_macd.legend(loc='upper left'); ax_macd.set_title('MACD'); ax_macd.set_ylabel('MACD'); ax_macd.grid(True, which='both', linestyle=':', linewidth=0.5)\n","    else: ax_macd.set_title('MACD (Not Calculated)'); ax_macd.grid(True)\n","\n","    axes[-1].tick_params(axis='x', rotation=45)\n","    plt.xlabel('Date')\n","    plt.tight_layout(rect=[0, 0.03, 1, 0.97])\n","    fig.suptitle('Trading Strategy Signals and Indicators', fontsize=16)\n","\n","    if save_path: plt.savefig(save_path, dpi=150); logger.info(f\"Saved signal plot to {save_path}\")\n","    else: plt.show()\n","    plt.close(fig)\n","\n","# --- Command Line Argument Parsing ---\n","def parse_args():\n","    parser = argparse.ArgumentParser(description='Calculate indicators, generate signals, and calculate detailed stats.')\n","    parser.add_argument('--input', type=str, default=str(DEFAULT_INPUT_FILE), help=f'Input RAW OHLCV CSV (default: {DEFAULT_INPUT_FILE})')\n","    parser.add_argument('--output', type=str, default=str(DEFAULT_OUTPUT_FILE), help=f'Output CSV (default: {DEFAULT_OUTPUT_FILE})')\n","    parser.add_argument('--plot', type=str, default=str(DEFAULT_PLOT_FILE), help=f'Plot image path (default: {DEFAULT_PLOT_FILE})')\n","    parser.add_argument('--no-plot', action='store_true', help='Disable generating plot')\n","    parser.add_argument('--full-history', action='store_true', help='Run on full history')\n","    return parser.parse_args()\n","\n","# --- Main Execution Block ---\n","if __name__ == \"__main__\":\n","    args = parse_args()\n","    input_file = Path(args.input); output_file = Path(args.output); plot_file = Path(args.plot)\n","\n","    try:\n","        output_file.parent.mkdir(parents=True, exist_ok=True)\n","        if not args.no_plot: plot_file.parent.mkdir(parents=True, exist_ok=True)\n","\n","        logger.info(f\"Loading data from {input_file}\")\n","        if not input_file.exists(): raise FileNotFoundError(f\"Input file not found: {input_file}\")\n","        # Load raw data\n","        df_raw = pd.read_csv(input_file, parse_dates=['datetime'], index_col='datetime')\n","        if df_raw.empty: raise pd.errors.EmptyDataError(\"Input file is empty.\")\n","        # Initial validation for OHLCV\n","        required_ohlcv = ['open', 'high', 'low', 'close', 'volume']\n","        if not all(col in df_raw.columns for col in required_ohlcv): raise ValueError(f\"Input CSV must contain OHLCV columns: {', '.join(required_ohlcv)}\")\n","\n","        # --- Calculate Indicators ---\n","        logger.info(\"Calculating all indicators...\")\n","        calculator = IndicatorCalculator() # Use default params or pass custom dict\n","        df_with_indicators = calculator.calculate_all_indicators(df_raw)\n","        logger.info(f\"Indicators calculated. DataFrame shape: {df_with_indicators.shape}\")\n","        if df_with_indicators.empty:\n","             logger.warning(\"DataFrame empty after indicator calculation (likely due to NaNs). Exiting.\")\n","             sys.exit(0)\n","\n","\n","        # --- Rename columns for strategy logic ---\n","        # Map names from IndicatorCalculator output to names expected by process_signals\n","        rename_map = {\n","            'ema_9': 'ema_fast',\n","            'ema_14': 'ema_med', # EMA 14 calculated by calculator now\n","            'ema_21': 'ema_slow',\n","            'bollinger_mid': 'bb_middle',\n","            'bollinger_upper': 'bb_upper',\n","            'bollinger_lower': 'bb_lower',\n","            'vol_sma_50': 'vol_ma', # Map calculated volume SMA\n","            # Keep macd, macd_signal, macd_hist, rsi, atr, adx, plus_di, minus_di as is (names match)\n","        }\n","        df_renamed = df_with_indicators.rename(columns=rename_map)\n","        logger.info(\"Renamed calculated indicator columns for internal use.\")\n","\n","        # --- Verify all columns needed for process_signals exist ---\n","        required_internal_cols = [\n","            'open', 'high', 'low', 'close', 'volume', 'atr', 'rsi',\n","            'macd', 'macd_signal', 'macd_hist',\n","            'ema_fast', 'ema_med', 'ema_slow',\n","            'bb_middle', 'bb_upper', 'bb_lower',\n","            'vol_ma', 'adx', 'plus_di', 'minus_di'\n","        ]\n","        missing_internal_cols = [col for col in required_internal_cols if col not in df_renamed.columns]\n","        if missing_internal_cols:\n","            raise ValueError(f\"DataFrame missing required columns after calculation/rename for signal processing: {missing_internal_cols}\")\n","\n","\n","        # --- Filter Data ---\n","        if PARAMS['backtest']['filter_last_month'] and not args.full_history:\n","            if not df_renamed.empty:\n","                last_date = df_renamed.index.max(); one_month_prior = last_date - pd.DateOffset(months=1)\n","                df = df_renamed.loc[one_month_prior:].copy()\n","                logger.info(f\"Filtered data from {df.index.min().date()} to {df.index.max().date()}.\")\n","            else: df = df_renamed # Should not happen if initial load worked\n","        else: df = df_renamed.copy(); logger.info(f\"Using full data history from {df.index.min().date()} to {df.index.max().date()}.\")\n","\n","        if df.empty:\n","             logger.warning(\"DataFrame empty after filtering. Skipping processing.\")\n","             df_processed = df; analyzer = None\n","        else:\n","            logger.info(\"Processing signals using calculated indicators...\")\n","            df_processed = process_signals(df) # Generate signals\n","\n","            logger.info(\"Analyzing trades...\")\n","            analyzer = EnhancedSignalAnalyzer() # Instantiate analyzer\n","            analyzer.analyze_trades(df_processed) # Analyze the processed df\n","            analyzer.print_summary() # Print detailed stats\n","\n","        logger.info(f\"Saving results to {output_file}\")\n","        df_processed.to_csv(output_file) # Save df with signals & indicators\n","\n","        # --- Plotting ---\n","        if not args.no_plot and not df_processed.empty:\n","            plot_signals(df_processed, plot_file)\n","        elif not args.no_plot and df_processed.empty:\n","             logger.warning(\"Plotting skipped as no data.\")\n","\n","        logger.info(\"Processing completed successfully\")\n","        sys.exit(0)\n","\n","    except FileNotFoundError as e: logger.error(str(e)); sys.exit(1)\n","    except pd.errors.EmptyDataError as e: logger.error(f\"Input file '{input_file}' empty/corrupt.\"); sys.exit(1)\n","    except ValueError as e: logger.error(f\"Data validation error: {str(e)}\"); sys.exit(1)\n","    except Exception as e: logger.error(f\"Unexpected error: {str(e)}\", exc_info=True); sys.exit(1)"],"outputs":[{"output_type":"stream","name":"stderr","text":["usage: colab_kernel_launcher.py [-h] [--input INPUT] [--output OUTPUT] [--plot PLOT] [--no-plot]\n","                                [--full-history]\n","colab_kernel_launcher.py: error: unrecognized arguments: -f /root/.local/share/jupyter/runtime/kernel-a25e29b8-4e61-4a16-a1d5-4190dd1283fc.json\n"]},{"output_type":"error","ename":"SystemExit","evalue":"2","traceback":["An exception has occurred, use %tb to see the full traceback.\n","\u001b[0;31mSystemExit\u001b[0m\u001b[0;31m:\u001b[0m 2\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/IPython/core/interactiveshell.py:3561: UserWarning: To exit: use 'exit', 'quit', or Ctrl-D.\n","  warn(\"To exit: use 'exit', 'quit', or Ctrl-D.\", stacklevel=1)\n"]}],"execution_count":9,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":176},"id":"05w5Nee0T8Q-","executionInfo":{"status":"error","timestamp":1743712260517,"user_tz":-330,"elapsed":474,"user":{"displayName":"CHANDRA SHEKHAR","userId":"04101457621295165703"}},"outputId":"02f383e9-2e00-4062-b5e0-3bf34f91005a"}},{"source":["# Task\n","Tell me about this dataset.\n","\n","Here is all the data you need:\n","\"nifty_historical_data.csv\""],"cell_type":"markdown","metadata":{"id":"mZjFonNRUe5Y"}},{"source":["## Data loading\n","\n","### Subtask:\n","Load the \"nifty_historical_data.csv\" file into a pandas DataFrame.\n"],"cell_type":"markdown","metadata":{"id":"6biWnzifUfJT"}},{"source":["**Reasoning**:\n","Load the \"nifty_historical_data.csv\" file into a pandas DataFrame and display the first few rows.\n","\n"],"cell_type":"markdown","metadata":{"id":"e1QwL7YSUgBB"}},{"source":["import pandas as pd\n","\n","try:\n","    df = pd.read_csv('nifty_historical_data.csv')\n","    display(df.head())\n","except FileNotFoundError:\n","    print(\"Error: 'nifty_historical_data.csv' not found. Please ensure the file exists in the current directory or provide the correct path.\")\n","    df = None"],"cell_type":"code","metadata":{"colab":{"base_uri":"https://localhost:8080/","height":206},"id":"wJvBPbBoUgQw","executionInfo":{"status":"ok","timestamp":1743711767382,"user_tz":-330,"elapsed":1445,"user":{"displayName":"CHANDRA SHEKHAR","userId":"04101457621295165703"}},"outputId":"8ccfd73d-d643-48b2-f2e5-344ce32b8088"},"execution_count":1,"outputs":[{"output_type":"display_data","data":{"text/plain":["                    datetime      open      high       low     close  volume\n","0  2025-04-03 09:15:00+05:30  23150.30  23226.40  23145.80  23219.65       0\n","1  2025-04-03 09:20:00+05:30  23218.65  23254.65  23214.55  23240.90       0\n","2  2025-04-03 09:25:00+05:30  23240.05  23263.45  23239.85  23251.20       0\n","3  2025-04-03 09:30:00+05:30  23251.65  23270.05  23213.40  23266.90       0\n","4  2025-04-03 09:35:00+05:30  23266.55  23280.80  23239.55  23251.45       0"],"text/html":["\n","  <div id=\"df-c1d5fd35-79a3-4941-a02d-4f200d0e0f96\" class=\"colab-df-container\">\n","    <div>\n","<style scoped>\n","    .dataframe tbody tr th:only-of-type {\n","        vertical-align: middle;\n","    }\n","\n","    .dataframe tbody tr th {\n","        vertical-align: top;\n","    }\n","\n","    .dataframe thead th {\n","        text-align: right;\n","    }\n","</style>\n","<table border=\"1\" class=\"dataframe\">\n","  <thead>\n","    <tr style=\"text-align: right;\">\n","      <th></th>\n","      <th>datetime</th>\n","      <th>open</th>\n","      <th>high</th>\n","      <th>low</th>\n","      <th>close</th>\n","      <th>volume</th>\n","    </tr>\n","  </thead>\n","  <tbody>\n","    <tr>\n","      <th>0</th>\n","      <td>2025-04-03 09:15:00+05:30</td>\n","      <td>23150.30</td>\n","      <td>23226.40</td>\n","      <td>23145.80</td>\n","      <td>23219.65</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>1</th>\n","      <td>2025-04-03 09:20:00+05:30</td>\n","      <td>23218.65</td>\n","      <td>23254.65</td>\n","      <td>23214.55</td>\n","      <td>23240.90</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>2</th>\n","      <td>2025-04-03 09:25:00+05:30</td>\n","      <td>23240.05</td>\n","      <td>23263.45</td>\n","      <td>23239.85</td>\n","      <td>23251.20</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>3</th>\n","      <td>2025-04-03 09:30:00+05:30</td>\n","      <td>23251.65</td>\n","      <td>23270.05</td>\n","      <td>23213.40</td>\n","      <td>23266.90</td>\n","      <td>0</td>\n","    </tr>\n","    <tr>\n","      <th>4</th>\n","      <td>2025-04-03 09:35:00+05:30</td>\n","      <td>23266.55</td>\n","      <td>23280.80</td>\n","      <td>23239.55</td>\n","      <td>23251.45</td>\n","      <td>0</td>\n","    </tr>\n","  </tbody>\n","</table>\n","</div>\n","    <div class=\"colab-df-buttons\">\n","\n","  <div class=\"colab-df-container\">\n","    <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-c1d5fd35-79a3-4941-a02d-4f200d0e0f96')\"\n","            title=\"Convert this dataframe to an interactive table.\"\n","            style=\"display:none;\">\n","\n","  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\" viewBox=\"0 -960 960 960\">\n","    <path d=\"M120-120v-720h720v720H120Zm60-500h600v-160H180v160Zm220 220h160v-160H400v160Zm0 220h160v-160H400v160ZM180-400h160v-160H180v160Zm440 0h160v-160H620v160ZM180-180h160v-160H180v160Zm440 0h160v-160H620v160Z\"/>\n","  </svg>\n","    </button>\n","\n","  <style>\n","    .colab-df-container {\n","      display:flex;\n","      gap: 12px;\n","    }\n","\n","    .colab-df-convert {\n","      background-color: #E8F0FE;\n","      border: none;\n","      border-radius: 50%;\n","      cursor: pointer;\n","      display: none;\n","      fill: #1967D2;\n","      height: 32px;\n","      padding: 0 0 0 0;\n","      width: 32px;\n","    }\n","\n","    .colab-df-convert:hover {\n","      background-color: #E2EBFA;\n","      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n","      fill: #174EA6;\n","    }\n","\n","    .colab-df-buttons div {\n","      margin-bottom: 4px;\n","    }\n","\n","    [theme=dark] .colab-df-convert {\n","      background-color: #3B4455;\n","      fill: #D2E3FC;\n","    }\n","\n","    [theme=dark] .colab-df-convert:hover {\n","      background-color: #434B5C;\n","      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n","      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n","      fill: #FFFFFF;\n","    }\n","  </style>\n","\n","    <script>\n","      const buttonEl =\n","        document.querySelector('#df-c1d5fd35-79a3-4941-a02d-4f200d0e0f96 button.colab-df-convert');\n","      buttonEl.style.display =\n","        google.colab.kernel.accessAllowed ? 'block' : 'none';\n","\n","      async function convertToInteractive(key) {\n","        const element = document.querySelector('#df-c1d5fd35-79a3-4941-a02d-4f200d0e0f96');\n","        const dataTable =\n","          await google.colab.kernel.invokeFunction('convertToInteractive',\n","                                                    [key], {});\n","        if (!dataTable) return;\n","\n","        const docLinkHtml = 'Like what you see? Visit the ' +\n","          '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n","          + ' to learn more about interactive tables.';\n","        element.innerHTML = '';\n","        dataTable['output_type'] = 'display_data';\n","        await google.colab.output.renderOutput(dataTable, element);\n","        const docLink = document.createElement('div');\n","        docLink.innerHTML = docLinkHtml;\n","        element.appendChild(docLink);\n","      }\n","    </script>\n","  </div>\n","\n","\n","<div id=\"df-a98cb34d-a1f8-4325-991f-bf027dc3867b\">\n","  <button class=\"colab-df-quickchart\" onclick=\"quickchart('df-a98cb34d-a1f8-4325-991f-bf027dc3867b')\"\n","            title=\"Suggest charts\"\n","            style=\"display:none;\">\n","\n","<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n","     width=\"24px\">\n","    <g>\n","        <path d=\"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z\"/>\n","    </g>\n","</svg>\n","  </button>\n","\n","<style>\n","  .colab-df-quickchart {\n","      --bg-color: #E8F0FE;\n","      --fill-color: #1967D2;\n","      --hover-bg-color: #E2EBFA;\n","      --hover-fill-color: #174EA6;\n","      --disabled-fill-color: #AAA;\n","      --disabled-bg-color: #DDD;\n","  }\n","\n","  [theme=dark] .colab-df-quickchart {\n","      --bg-color: #3B4455;\n","      --fill-color: #D2E3FC;\n","      --hover-bg-color: #434B5C;\n","      --hover-fill-color: #FFFFFF;\n","      --disabled-bg-color: #3B4455;\n","      --disabled-fill-color: #666;\n","  }\n","\n","  .colab-df-quickchart {\n","    background-color: var(--bg-color);\n","    border: none;\n","    border-radius: 50%;\n","    cursor: pointer;\n","    display: none;\n","    fill: var(--fill-color);\n","    height: 32px;\n","    padding: 0;\n","    width: 32px;\n","  }\n","\n","  .colab-df-quickchart:hover {\n","    background-color: var(--hover-bg-color);\n","    box-shadow: 0 1px 2px rgba(60, 64, 67, 0.3), 0 1px 3px 1px rgba(60, 64, 67, 0.15);\n","    fill: var(--button-hover-fill-color);\n","  }\n","\n","  .colab-df-quickchart-complete:disabled,\n","  .colab-df-quickchart-complete:disabled:hover {\n","    background-color: var(--disabled-bg-color);\n","    fill: var(--disabled-fill-color);\n","    box-shadow: none;\n","  }\n","\n","  .colab-df-spinner {\n","    border: 2px solid var(--fill-color);\n","    border-color: transparent;\n","    border-bottom-color: var(--fill-color);\n","    animation:\n","      spin 1s steps(1) infinite;\n","  }\n","\n","  @keyframes spin {\n","    0% {\n","      border-color: transparent;\n","      border-bottom-color: var(--fill-color);\n","      border-left-color: var(--fill-color);\n","    }\n","    20% {\n","      border-color: transparent;\n","      border-left-color: var(--fill-color);\n","      border-top-color: var(--fill-color);\n","    }\n","    30% {\n","      border-color: transparent;\n","      border-left-color: var(--fill-color);\n","      border-top-color: var(--fill-color);\n","      border-right-color: var(--fill-color);\n","    }\n","    40% {\n","      border-color: transparent;\n","      border-right-color: var(--fill-color);\n","      border-top-color: var(--fill-color);\n","    }\n","    60% {\n","      border-color: transparent;\n","      border-right-color: var(--fill-color);\n","    }\n","    80% {\n","      border-color: transparent;\n","      border-right-color: var(--fill-color);\n","      border-bottom-color: var(--fill-color);\n","    }\n","    90% {\n","      border-color: transparent;\n","      border-bottom-color: var(--fill-color);\n","    }\n","  }\n","</style>\n","\n","  <script>\n","    async function quickchart(key) {\n","      const quickchartButtonEl =\n","        document.querySelector('#' + key + ' button');\n","      quickchartButtonEl.disabled = true;  // To prevent multiple clicks.\n","      quickchartButtonEl.classList.add('colab-df-spinner');\n","      try {\n","        const charts = await google.colab.kernel.invokeFunction(\n","            'suggestCharts', [key], {});\n","      } catch (error) {\n","        console.error('Error during call to suggestCharts:', error);\n","      }\n","      quickchartButtonEl.classList.remove('colab-df-spinner');\n","      quickchartButtonEl.classList.add('colab-df-quickchart-complete');\n","    }\n","    (() => {\n","      let quickchartButtonEl =\n","        document.querySelector('#df-a98cb34d-a1f8-4325-991f-bf027dc3867b button');\n","      quickchartButtonEl.style.display =\n","        google.colab.kernel.accessAllowed ? 'block' : 'none';\n","    })();\n","  </script>\n","</div>\n","\n","    </div>\n","  </div>\n"],"application/vnd.google.colaboratory.intrinsic+json":{"type":"dataframe","summary":"{\n  \"name\": \"    df = None\",\n  \"rows\": 5,\n  \"fields\": [\n    {\n      \"column\": \"datetime\",\n      \"properties\": {\n        \"dtype\": \"object\",\n        \"num_unique_values\": 5,\n        \"samples\": [\n          \"2025-04-03 09:20:00+05:30\",\n          \"2025-04-03 09:35:00+05:30\",\n          \"2025-04-03 09:25:00+05:30\"\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"open\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 45.504318476382224,\n        \"min\": 23150.3,\n        \"max\": 23266.55,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          23218.65,\n          23266.55,\n          23240.05\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"high\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 20.6082689714581,\n        \"min\": 23226.4,\n        \"max\": 23280.8,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          23254.65,\n          23280.8,\n          23263.45\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"low\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 38.45823383880222,\n        \"min\": 23145.8,\n        \"max\": 23239.85,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          23214.55,\n          23239.55,\n          23239.85\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"close\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 17.4204118780239,\n        \"min\": 23219.65,\n        \"max\": 23266.9,\n        \"num_unique_values\": 5,\n        \"samples\": [\n          23240.9,\n          23251.45,\n          23251.2\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"volume\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 0,\n        \"min\": 0,\n        \"max\": 0,\n        \"num_unique_values\": 1,\n        \"samples\": [\n          0\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    }\n  ]\n}"}},"metadata":{}}]},{"cell_type":"code","source":["import numpy as np\n","import pandas as pd\n","import os\n","import logging\n","import matplotlib.pyplot as plt\n","from typing import Dict, Any, Optional, Tuple, List\n","from pathlib import Path\n","import argparse\n","from datetime import timedelta\n","from collections import defaultdict # Needed for EnhancedSignalAnalyzer\n","import sys # Needed for exit code in main\n","\n","# Initialize logging\n","logging.basicConfig(\n","    level=logging.INFO,\n","    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n","    handlers=[\n","        logging.FileHandler('signals_calculator_analyzer.log'), # New log file name\n","        logging.StreamHandler()\n","    ]\n",")\n","logger = logging.getLogger(__name__)\n","\n","# Configuration\n","DATA_FOLDER = Path(\"data\")\n","# Default file names (can be overridden by command line args)\n","DEFAULT_INPUT_FILE = DATA_FOLDER / \"nifty_ohlcv.csv\" # Changed default input name - expects raw data now\n","DEFAULT_OUTPUT_FILE = DATA_FOLDER / \"nifty_signals_final_calculated.csv\"\n","DEFAULT_PLOT_FILE = DATA_FOLDER / \"signals_plot_calculated.png\"\n","\n","# --- IndicatorCalculator Class (from Script 2 - Enhanced) ---\n","class IndicatorCalculator:\n","    \"\"\"Enhanced technical indicator calculator with complete implementations\"\"\"\n","\n","    DEFAULT_PARAMS = {\n","        'sma_periods': [20, 50, 200],\n","        'ema_periods': [9, 14, 21, 50], # Added 14 for ema_med\n","        'macd_params': (12, 26, 9),\n","        'rsi_period': 14,\n","        'stochastic_period': 14,\n","        'bollinger_period': 20,\n","        'bollinger_std': 2,\n","        'atr_period': 14,\n","        'adx_period': 14, # Added ADX period\n","        'vol_sma_period': 50, # Added Volume SMA period\n","        'obv_ema_period': 21,\n","        'vwap_enabled': True\n","    }\n","\n","    def __init__(self, params: Optional[Dict] = None):\n","        self.params = {**self.DEFAULT_PARAMS, **(params or {})}\n","        self._validate_params()\n","\n","    def _validate_params(self) -> None:\n","        \"\"\"Validate indicator parameters\"\"\"\n","        periods_to_check = [\n","            *self.params['sma_periods'], *self.params['ema_periods'],\n","            self.params['rsi_period'], self.params['stochastic_period'],\n","            self.params['bollinger_period'], self.params['atr_period'],\n","            self.params['adx_period'], self.params['vol_sma_period']\n","        ]\n","        if any(p <= 0 for p in periods_to_check):\n","            raise ValueError(\"All periods must be positive integers\")\n","        if self.params['bollinger_std'] <= 0:\n","            raise ValueError(\"Bollinger standard deviation must be positive\")\n","\n","    def validate_dataframe(self, df: pd.DataFrame) -> None:\n","        \"\"\"Validate input dataframe structure and data quality\"\"\"\n","        required_columns = ['open', 'high', 'low', 'close', 'volume']\n","        missing = [col for col in required_columns if col not in df.columns]\n","        if missing: raise ValueError(f\"Missing required columns: {missing}\")\n","        for col in required_columns:\n","            if not pd.api.types.is_numeric_dtype(df[col]): raise ValueError(f\"Column {col} must be numeric\")\n","        min_period = max([p for p in self.params.values() if isinstance(p, int) and p > 0] + [max(p) for p in self.params.values() if isinstance(p, list) and p])\n","        if len(df) < min_period: logger.warning(f\"Limited data points ({len(df)}) may affect indicator accuracy (min {min_period} recommended)\")\n","        if (df['high'] < df['low']).any(): raise ValueError(\"High price cannot be less than low price\")\n","        if (df['close'] > df['high']).any() or (df['close'] < df['low']).any(): raise ValueError(\"Close price must be between high and low\")\n","        if (df['volume'] < 0).any(): raise ValueError(\"Volume cannot be negative\")\n","\n","    def calculate_trend_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            for period in self.params['sma_periods']: df[f'sma_{period}'] = df['close'].rolling(window=period, min_periods=1).mean()\n","            for period in self.params['ema_periods']: df[f'ema_{period}'] = df['close'].ewm(span=period, adjust=False, min_periods=1).mean()\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating trend indicators: {str(e)}\"); raise\n","\n","    def calculate_macd(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            fast, slow, signal = self.params['macd_params']\n","            ema_fast = df['close'].ewm(span=fast, adjust=False, min_periods=1).mean()\n","            ema_slow = df['close'].ewm(span=slow, adjust=False, min_periods=1).mean()\n","            df['macd'] = ema_fast - ema_slow\n","            df['macd_signal'] = df['macd'].ewm(span=signal, adjust=False, min_periods=1).mean()\n","            df['macd_hist'] = df['macd'] - df['macd_signal']\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating MACD: {str(e)}\"); raise\n","\n","    def calculate_rsi(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['rsi_period']; delta = df['close'].diff()\n","            if len(delta) < period: logger.warning(f\"Insufficient data for RSI ({len(delta)} points)\"); df['rsi'] = np.nan; return df\n","            gain = delta.where(delta > 0, 0.0); loss = -delta.where(delta < 0, 0.0)\n","            # Use EWM for RSI calculation (more standard than rolling mean)\n","            avg_gain = gain.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            avg_loss = loss.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            rs = avg_gain / avg_loss.replace(0, 1e-6)\n","            df['rsi'] = 100.0 - (100.0 / (1.0 + rs))\n","            df['rsi'] = df['rsi'].fillna(50); df['rsi'] = df['rsi'].clip(0, 100)\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating RSI: {str(e)}\"); raise\n","\n","    def calculate_stochastic(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['stochastic_period']\n","            low_min = df['low'].rolling(window=period, min_periods=1).min()\n","            high_max = df['high'].rolling(window=period, min_periods=1).max()\n","            df['stochastic_k'] = 100 * ((df['close'] - low_min) / (high_max - low_min).replace(0, 1e-6))\n","            df['stochastic_d'] = df['stochastic_k'].rolling(window=3, min_periods=1).mean()\n","            df['stochastic_k'] = df['stochastic_k'].fillna(50); df['stochastic_d'] = df['stochastic_d'].fillna(50)\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating Stochastic: {str(e)}\"); raise\n","\n","    def calculate_bollinger_bands(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['bollinger_period']; std_dev = self.params['bollinger_std']\n","            sma = df['close'].rolling(window=period, min_periods=1).mean()\n","            rolling_std = df['close'].rolling(window=period, min_periods=1).std()\n","            df['bollinger_upper'] = sma + (std_dev * rolling_std)\n","            df['bollinger_lower'] = sma - (std_dev * rolling_std)\n","            df['bollinger_mid'] = sma\n","            df['bollinger_bandwidth'] = (df['bollinger_upper'] - df['bollinger_lower']) / df['bollinger_mid'].replace(0, 1e-6)\n","            df['bollinger_pctb'] = (df['close'] - df['bollinger_lower']) / (df['bollinger_upper'] - df['bollinger_lower']).replace(0, 1e-6)\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating Bollinger Bands: {str(e)}\"); raise\n","\n","    def calculate_atr(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['atr_period']\n","            high_low = df['high'] - df['low']\n","            high_close = (df['high'] - df['close'].shift()).abs()\n","            low_close = (df['low'] - df['close'].shift()).abs()\n","            true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)\n","            # Use EWM for ATR (Wilder's smoothing)\n","            df['atr'] = true_range.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating ATR: {str(e)}\"); raise\n","\n","    # --- NEW: ADX Calculation ---\n","    def calculate_adx(self, df: pd.DataFrame) -> pd.DataFrame:\n","        \"\"\"Calculate ADX, +DI, -DI\"\"\"\n","        try:\n","            period = self.params['adx_period']\n","            if 'atr' not in df.columns: # Calculate ATR if not already present\n","                df = self.calculate_atr(df)\n","\n","            up_move = df['high'].diff()\n","            down_move = -df['low'].diff()\n","            plus_dm = ((up_move > down_move) & (up_move > 0)) * up_move\n","            minus_dm = ((down_move > up_move) & (down_move > 0)) * down_move\n","            plus_dm = plus_dm.fillna(0)\n","            minus_dm = minus_dm.fillna(0)\n","\n","            # Use Wilder's smoothing for DM and TR\n","            smooth_plus_dm = plus_dm.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            smooth_minus_dm = minus_dm.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            # TR is needed for smoothing, use the already calculated ATR column for consistency\n","            atr_smoothed = df['atr'].replace(0, 1e-6) # Use the calculated ATR\n","\n","            df['plus_di'] = 100 * (smooth_plus_dm / atr_smoothed)\n","            df['minus_di'] = 100 * (smooth_minus_dm / atr_smoothed)\n","            di_sum = (df['plus_di'] + df['minus_di']).replace(0, 1e-6)\n","            dx = 100 * (abs(df['plus_di'] - df['minus_di']) / di_sum)\n","            df['adx'] = dx.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","\n","            # Fill initial NaNs\n","            df[['plus_di', 'minus_di', 'adx']] = df[['plus_di', 'minus_di', 'adx']].fillna(0)\n","\n","            return df\n","        except Exception as e:\n","            logger.error(f\"Error calculating ADX: {str(e)}\")\n","            raise\n","\n","    # --- NEW: Volume SMA Calculation ---\n","    def calculate_volume_sma(self, df: pd.DataFrame) -> pd.DataFrame:\n","        \"\"\"Calculate Simple Moving Average on Volume\"\"\"\n","        try:\n","            period = self.params['vol_sma_period']\n","            df[f'vol_sma_{period}'] = df['volume'].rolling(window=period, min_periods=1).mean()\n","            return df\n","        except Exception as e:\n","            logger.error(f\"Error calculating Volume SMA: {str(e)}\")\n","            raise\n","\n","    def calculate_volume_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            df['obv'] = (np.sign(df['close'].diff()) * df['volume']).fillna(0).cumsum()\n","            df['obv_ema'] = df['obv'].ewm(span=self.params['obv_ema_period'], adjust=False).mean()\n","            if self.params['vwap_enabled']:\n","                # VWAP calculation needs careful handling, especially for intraday resets\n","                # Simple cumulative VWAP:\n","                df['vwap'] = (df['close'] * df['volume']).cumsum() / df['volume'].cumsum().replace(0, 1e-6)\n","                # For proper daily VWAP, reset calculation at the start of each day\n","                # This requires grouping by date, which is more complex here.\n","                # logger.warning(\"VWAP calculation is cumulative; for daily VWAP, implement daily reset.\")\n","            df = self.calculate_volume_sma(df) # Calculate Volume SMA here\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating volume indicators: {str(e)}\"); raise\n","\n","    def calculate_all_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            self.validate_dataframe(df)\n","            df = df.copy() # Work on a copy\n","            df = self.calculate_trend_indicators(df)\n","            df = self.calculate_macd(df)\n","            df = self.calculate_rsi(df)\n","            df = self.calculate_stochastic(df)\n","            df = self.calculate_bollinger_bands(df)\n","            df = self.calculate_atr(df) # ATR needed for ADX\n","            df = self.calculate_adx(df) # Calculate ADX\n","            df = self.calculate_volume_indicators(df) # Includes Vol SMA\n","            logger.info(f\"Successfully calculated indicators\")\n","            return df.dropna(axis=0, how='any') # Drop rows with initial NaNs from indicator calcs\n","        except Exception as e: logger.error(f\"Indicator calculation failed: {str(e)}\", exc_info=True); raise\n","\n","\n","# --- Parameter Dictionary (Strategy Logic Parameters Only) ---\n","# Indicator parameters are now defined in IndicatorCalculator.DEFAULT_PARAMS\n","PARAMS: Dict[str, Dict[str, Any]] = {\n","    'backtest': {\n","        'commission_pct': 0.0005,\n","        'slippage_pct': 0.0002,\n","        'filter_last_month': True\n","    },\n","    'core': {\n","        \"max_trade_duration\": 50,\n","        'exit_score_drop_threshold': 1.5,\n","        'use_score_drop_exit': True,\n","        'entry_score_threshold': 6.0,\n","        'use_fib_bounce_entry': True,\n","        'use_fib_bounce_sell': True,\n","        'fib_bounce_lookback': 3,\n","        'fib_bounce_long_zone': (0.5, 0.618),\n","        'fib_bounce_short_zone': (0.382, 0.5),\n","        'fib_bounce_confirmation_level': 0.5,\n","        'use_ema_bounce_buy': True,\n","        'use_ema_bounce_sell': True,\n","        'ema_bounce_lookback': 2,\n","        'ema_bounce_source_str': \"Fast EMA\", # Uses 'ema_fast' (mapped from ema_9)\n","        'use_bb_mid_bounce_buy': True,\n","        'use_bb_mid_bounce_sell': True,\n","        'bb_bounce_lookback': 2,\n","        'use_vol_breakout_buy': True,\n","        'use_vol_breakout_sell': True,\n","        'trailing_stop_type': \"atr\",\n","        'trailing_stop_pct': 0.02,\n","        'trailing_stop_atr_multiplier': 1.5,\n","        'profit_protection_levels': {\n","            'level1': {'profit_pct': 0.05, 'new_atr_mult': 1.0},\n","            'level2': {'profit_pct': 0.10, 'new_atr_mult': 0.5}\n","        }\n","    },\n","    'ema': { # Only keep params for strategy logic using EMAs\n","        'med_len': 14, # Length used for internal calculation if needed (e.g., trend check)\n","        'use_ema_exit': True\n","    },\n","    'bollinger': { # Only keep strategy logic params\n","        'use_bb_return_exit': True\n","    },\n","    'rsi': { # Only keep strategy logic params\n","        'rsi_buy_level': 55.0,\n","        'rsi_sell_level': 45.0,\n","        'rsi_confirm_fib': True,\n","        'rsi_confirm_ema': False,\n","        'rsi_confirm_bb': False,\n","        'rsi_confirm_level_buy': 40.0,\n","        'rsi_confirm_level_sell': 60.0,\n","        'use_rsi_div_exit': True\n","    },\n","    'macd': { # No MACD specific strategy params here, but keep section if needed later\n","    },\n","    'volume': { # Keep strategy logic params\n","        'vol_multiplier': 1.5,\n","        'use_vol_fade_exit': True\n","    },\n","    'atr': { # Keep strategy logic params\n","        'use_atr_stop': True\n","    },\n","    'fibonacci': {\n","        'use_fib_exit': True,\n","        'fib_lookback_exit': 30,\n","        'fib_extension_level': 1.618,\n","        'fib_pivot_lookback': 15,\n","        'fib_max_bars': 200\n","    },\n","    'trend': { # Keep strategy logic params\n","        'use_ema_trend_filter': True,\n","        'use_adx_filter': True,\n","        # 'adx_len': 14, # Defined in IndicatorCalculator\n","        'adx_threshold': 20.0,\n","        'use_adx_direction_filter': True\n","    },\n","    'score_weights': {\n","        'w_ema_trend': 2, 'w_ema_signal': 1, 'w_rsi_thresh': 1,\n","        'w_macd_signal': 1, 'w_macd_zero': 1, 'w_vol_break': 1,\n","        'w_adx_strength': 1, 'w_adx_direction': 1, 'w_fib_bounce': 2,\n","        'w_ema_bounce': 1, 'w_bb_bounce': 1,\n","    }\n","}\n","\n","\n","# --- TradeState Class ---\n","# (Keep the TradeState class definition as it was in strategy_merged_analyzer_v3)\n","class TradeState:\n","    \"\"\"Keeps track of the current trade status.\"\"\"\n","    def __init__(self):\n","        self.position = None\n","        self.entry_price = None\n","        self.entry_index = None\n","        self.trailing_stop = None\n","        self.highest_high_in_trade = None\n","        self.lowest_low_in_trade = None\n","        self.time_in_trade = 0\n","\n","    def reset(self):\n","        self.__init__()\n","\n","    def update_trailing_stop(self, current_low, current_high, current_close, atr):\n","        if self.position is None or atr is None or pd.isna(atr) or self.entry_price is None:\n","            return\n","\n","        stop_type = PARAMS['core']['trailing_stop_type']\n","        initial_atr_mult = PARAMS['core']['trailing_stop_atr_multiplier']\n","        stop_pct = PARAMS['core']['trailing_stop_pct']\n","        current_atr_mult = initial_atr_mult\n","\n","        if self.position == 'Long':\n","            if self.highest_high_in_trade is None or current_high > self.highest_high_in_trade:\n","                self.highest_high_in_trade = current_high\n","\n","            profit_pct = (current_close - self.entry_price) / self.entry_price if self.entry_price else 0\n","            for level_name, level_info in sorted(PARAMS['core']['profit_protection_levels'].items()):\n","                if profit_pct >= level_info['profit_pct']:\n","                    current_atr_mult = level_info['new_atr_mult']\n","\n","            if stop_type == \"percentage\":\n","                potential_stop = self.highest_high_in_trade * (1 - stop_pct) if self.highest_high_in_trade else None\n","            else:\n","                potential_stop = self.highest_high_in_trade - (atr * current_atr_mult) if self.highest_high_in_trade else None\n","\n","            if potential_stop is not None and (self.trailing_stop is None or potential_stop > self.trailing_stop):\n","                self.trailing_stop = potential_stop\n","\n","        elif self.position == 'Short':\n","            if self.lowest_low_in_trade is None or current_low < self.lowest_low_in_trade:\n","                self.lowest_low_in_trade = current_low\n","\n","            profit_pct = (self.entry_price - current_close) / self.entry_price if self.entry_price else 0\n","            for level_name, level_info in sorted(PARAMS['core']['profit_protection_levels'].items()):\n","                 if profit_pct >= level_info['profit_pct']:\n","                    current_atr_mult = level_info['new_atr_mult']\n","\n","            if stop_type == \"percentage\":\n","                potential_stop = self.lowest_low_in_trade * (1 + stop_pct) if self.lowest_low_in_trade else None\n","            else:\n","                potential_stop = self.lowest_low_in_trade + (atr * current_atr_mult) if self.lowest_low_in_trade else None\n","\n","            if potential_stop is not None and (self.trailing_stop is None or potential_stop < self.trailing_stop):\n","                self.trailing_stop = potential_stop\n","\n","\n","# --- Feature Calculation Functions (Fib, Score, Divergence, Targets) ---\n","# (Keep calculate_fibonacci_levels, calculate_score, calculate_rsi_divergence,\n","#  calculate_targets_for_trade functions as they were in strategy_merged_analyzer_v3,\n","#  but ensure calculate_score uses the correct indicator names after renaming)\n","\n","def calculate_score(df: pd.DataFrame) -> Tuple[pd.DataFrame, float]:\n","    logger.info(\"Calculating weighted trading score using provided indicators\")\n","    try:\n","        weights = PARAMS['score_weights']\n","        # Calculate total possible score dynamically based on enabled features in PARAMS\n","        total_possible_score = 0.0\n","        if PARAMS['trend']['use_ema_trend_filter']: total_possible_score += weights.get('w_ema_trend', 0)\n","        total_possible_score += weights.get('w_ema_signal', 0) # Assume always calculated\n","        total_possible_score += weights.get('w_rsi_thresh', 0) # Assume always calculated\n","        total_possible_score += weights.get('w_macd_signal', 0) # Assume always calculated\n","        total_possible_score += weights.get('w_macd_zero', 0) # Assume always calculated\n","        if PARAMS['core']['use_vol_breakout_buy'] or PARAMS['core']['use_vol_breakout_sell']: total_possible_score += weights.get('w_vol_break', 0)\n","        if PARAMS['trend']['use_adx_filter']: total_possible_score += weights.get('w_adx_strength', 0)\n","        if PARAMS['trend']['use_adx_direction_filter']: total_possible_score += weights.get('w_adx_direction', 0)\n","        if PARAMS['core']['use_fib_bounce_entry'] or PARAMS['core']['use_fib_bounce_sell']: total_possible_score += weights.get('w_fib_bounce', 0)\n","        if PARAMS['core']['use_ema_bounce_buy'] or PARAMS['core']['use_ema_bounce_sell']: total_possible_score += weights.get('w_ema_bounce', 0)\n","        if PARAMS['core']['use_bb_mid_bounce_buy'] or PARAMS['core']['use_bb_mid_bounce_sell']: total_possible_score += weights.get('w_bb_bounce', 0)\n","        total_possible_score = max(1.0, total_possible_score)\n","\n","        # --- Calculate Individual Condition Flags using provided/renamed columns ---\n","        # Ensure these columns exist after renaming!\n","        df['cond_ema_trend_buy'] = df['ema_med'] > df['ema_slow']\n","        df['cond_ema_trend_sell'] = df['ema_med'] < df['ema_slow']\n","        df['cond_ema_signal_buy'] = (df['ema_fast'] > df['ema_slow']) & (df['ema_fast'].shift() <= df['ema_slow'].shift())\n","        df['cond_ema_signal_sell'] = (df['ema_fast'] < df['ema_slow']) & (df['ema_fast'].shift() >= df['ema_slow'].shift())\n","        df['cond_rsi_buy'] = df['rsi'] > PARAMS['rsi']['rsi_buy_level']\n","        df['cond_rsi_sell'] = df['rsi'] < PARAMS['rsi']['rsi_sell_level']\n","        df['cond_macd_signal_buy'] = (df['macd'] > df['macd_signal']) & (df['macd'].shift() <= df['macd_signal'].shift())\n","        df['cond_macd_signal_sell'] = (df['macd'] < df['macd_signal']) & (df['macd'].shift() >= df['macd_signal'].shift())\n","        df['cond_macd_zero_buy'] = (df['macd'] > 0) & (df['macd'].shift() <= 0)\n","        df['cond_macd_zero_sell'] = (df['macd'] < 0) & (df['macd'].shift() >= 0)\n","        df['cond_vol_break_buy'] = (df['volume'] > df['vol_ma'] * PARAMS['volume']['vol_multiplier']) & (df['close'] > df['open']) # Uses calculated vol_ma\n","        df['cond_vol_break_sell'] = (df['volume'] > df['vol_ma'] * PARAMS['volume']['vol_multiplier']) & (df['close'] < df['open'])\n","        df['cond_adx_strength'] = df['adx'] > PARAMS['trend']['adx_threshold'] # Uses calculated adx\n","        df['cond_adx_dir_buy'] = df['plus_di'] > df['minus_di'] # Uses calculated di\n","        df['cond_adx_dir_sell'] = df['minus_di'] > df['plus_di']\n","        df['cond_fib_bounce_buy'] = False; df['cond_fib_bounce_sell'] = False\n","        df['cond_ema_bounce_buy'] = False; df['cond_ema_bounce_sell'] = False\n","        df['cond_bb_bounce_buy'] = False; df['cond_bb_bounce_sell'] = False\n","\n","        buy_score = pd.Series(0.0, index=df.index); sell_score = pd.Series(0.0, index=df.index)\n","        if PARAMS['trend']['use_ema_trend_filter']: buy_score += df['cond_ema_trend_buy'] * weights.get('w_ema_trend', 0); sell_score += df['cond_ema_trend_sell'] * weights.get('w_ema_trend', 0)\n","        buy_score += df['cond_ema_signal_buy'] * weights.get('w_ema_signal', 0); sell_score += df['cond_ema_signal_sell'] * weights.get('w_ema_signal', 0)\n","        buy_score += df['cond_rsi_buy'] * weights.get('w_rsi_thresh', 0); sell_score += df['cond_rsi_sell'] * weights.get('w_rsi_thresh', 0)\n","        buy_score += df['cond_macd_signal_buy'] * weights.get('w_macd_signal', 0); sell_score += df['cond_macd_signal_sell'] * weights.get('w_macd_signal', 0)\n","        buy_score += df['cond_macd_zero_buy'] * weights.get('w_macd_zero', 0); sell_score += df['cond_macd_zero_sell'] * weights.get('w_macd_zero', 0)\n","        if PARAMS['core']['use_vol_breakout_buy'] or PARAMS['core']['use_vol_breakout_sell']: buy_score += df['cond_vol_break_buy'] * weights.get('w_vol_break', 0); sell_score += df['cond_vol_break_sell'] * weights.get('w_vol_break', 0)\n","        if PARAMS['trend']['use_adx_filter']: buy_score += (df['cond_adx_strength'] & df['cond_adx_dir_buy']) * weights.get('w_adx_strength', 0); sell_score += (df['cond_adx_strength'] & df['cond_adx_dir_sell']) * weights.get('w_adx_strength', 0)\n","        if PARAMS['trend']['use_adx_direction_filter']: buy_score += df['cond_adx_dir_buy'] * weights.get('w_adx_direction', 0); sell_score += df['cond_adx_dir_sell'] * weights.get('w_adx_direction', 0)\n","        df['buy_score_raw'] = buy_score; df['sell_score_raw'] = sell_score\n","        df['scaled_score'] = 5.0\n","        logger.info(\"Finished initial score calculation\")\n","        return df, total_possible_score\n","    except Exception as e:\n","        logger.error(f\"Error in calculate_score: {str(e)}\", exc_info=True)\n","        raise\n","\n","def calculate_rsi_divergence(df: pd.DataFrame) -> pd.DataFrame:\n","    # This function now relies on the 'rsi' column being present\n","    logger.info(f\"Calculating RSI divergence\")\n","    try:\n","        if 'rsi' not in df.columns:\n","             logger.error(\"RSI column not found for divergence calculation.\")\n","             df['bullish_rsi_div'] = False; df['bearish_rsi_div'] = False\n","             return df\n","        lookback = 14 # Default or get from PARAMS if needed\n","        df['bullish_rsi_div'] = False; df['bearish_rsi_div'] = False\n","        df['price_low_roll'] = df['low'].rolling(window=lookback, closed='left').min()\n","        df['rsi_low_roll'] = df['rsi'].rolling(window=lookback, closed='left').min()\n","        df['price_high_roll'] = df['high'].rolling(window=lookback, closed='left').max()\n","        df['rsi_high_roll'] = df['rsi'].rolling(window=lookback, closed='left').max()\n","        df['bullish_rsi_div'] = (df['low'] < df['price_low_roll']) & (df['rsi'] > df['rsi_low_roll'])\n","        df['bearish_rsi_div'] = (df['high'] > df['price_high_roll']) & (df['rsi'] < df['rsi_high_roll'])\n","        df = df.drop(columns=['price_low_roll', 'rsi_low_roll', 'price_high_roll', 'rsi_high_roll'], errors='ignore')\n","        logger.info(\"Finished calculating RSI divergence\")\n","        return df\n","    except Exception as e:\n","        logger.error(f\"Error in calculate_rsi_divergence: {str(e)}\", exc_info=True)\n","        raise\n","\n","def calculate_targets_for_trade(df: pd.DataFrame, entry_idx: int, position: str, entry_price: float, initial_stop: float) -> pd.DataFrame:\n","    # This function relies on 'atr' column being present\n","    try:\n","        current_idx = df.index[entry_idx]\n","        if 'atr' not in df.columns:\n","             logger.warning(f\"ATR column missing, cannot calculate ATR/RR targets for trade at index {entry_idx}.\")\n","             return df\n","        atr = df.loc[current_idx, 'atr']\n","\n","        fib_lookback = PARAMS['fibonacci']['fib_lookback_exit']\n","        fib_ext_level = PARAMS['fibonacci']['fib_extension_level']\n","        use_fib_target = PARAMS['fibonacci']['use_fib_exit']\n","        atr_mult_target = PARAMS['atr'].get('atr_mult', 2.0) # Use .get with default\n","\n","        if pd.isna(atr) or pd.isna(entry_price) or pd.isna(initial_stop):\n","            logger.warning(f\"Cannot calculate targets for trade at index {entry_idx} due to NaN inputs.\")\n","            return df\n","\n","        target_price_long_col = df['target_price_long'].copy()\n","        target_price_short_col = df['target_price_short'].copy()\n","        fib_target_long_col = df['fib_target_long'].copy()\n","        fib_target_short_col = df['fib_target_short'].copy()\n","\n","        if position == 'Long':\n","            atr_target = entry_price + (atr * atr_mult_target)\n","            risk = entry_price - initial_stop\n","            rr_target = entry_price + (risk * 2) if risk > 0 else np.nan\n","            fib_target = np.nan\n","            if use_fib_target:\n","                lookback_start = max(0, entry_idx - fib_lookback)\n","                swing_low_series = df['low'].iloc[lookback_start : entry_idx]\n","                if not swing_low_series.empty:\n","                    swing_low_price = swing_low_series.min()\n","                    swing_range = entry_price - swing_low_price\n","                    if swing_range > 0: fib_target = entry_price + (swing_range * fib_ext_level)\n","            fib_target_long_col.loc[current_idx:] = fib_target\n","            valid_targets = [t for t in [atr_target, rr_target, fib_target] if pd.notna(t)]\n","            if valid_targets: target_price_long_col.loc[current_idx:] = min(valid_targets)\n","\n","        elif position == 'Short':\n","            atr_target = entry_price - (atr * atr_mult_target)\n","            risk = initial_stop - entry_price\n","            rr_target = entry_price - (risk * 2) if risk > 0 else np.nan\n","            fib_target = np.nan\n","            if use_fib_target:\n","                lookback_start = max(0, entry_idx - fib_lookback)\n","                swing_high_series = df['high'].iloc[lookback_start : entry_idx]\n","                if not swing_high_series.empty:\n","                    swing_high_price = swing_high_series.max()\n","                    swing_range = swing_high_price - entry_price\n","                    if swing_range > 0: fib_target = entry_price - (swing_range * fib_ext_level)\n","            fib_target_short_col.loc[current_idx:] = fib_target\n","            valid_targets = [t for t in [atr_target, rr_target, fib_target] if pd.notna(t)]\n","            if valid_targets: target_price_short_col.loc[current_idx:] = max(valid_targets)\n","\n","        df['target_price_long'] = target_price_long_col\n","        df['target_price_short'] = target_price_short_col\n","        df['fib_target_long'] = fib_target_long_col\n","        df['fib_target_short'] = fib_target_short_col\n","\n","        return df\n","    except Exception as e:\n","        logger.error(f\"Error calculating targets for trade at index {entry_idx}: {str(e)}\", exc_info=True)\n","        return df\n","\n","# --- Main Signal Processing Function (Uses Calculated Indicators) ---\n","def process_signals(df: pd.DataFrame) -> pd.DataFrame:\n","    logger.info(\"Starting signal processing using calculated indicators\")\n","    try:\n","        # --- Ensure necessary columns exist after renaming ---\n","        required_internal_cols = [\n","            'open', 'high', 'low', 'close', 'volume', 'atr', 'rsi',\n","            'macd', 'macd_signal', 'macd_hist',\n","            'ema_fast', 'ema_med', 'ema_slow', # Renamed/Calculated\n","            'bb_middle', 'bb_upper', 'bb_lower', # Renamed\n","            'vol_ma', # Calculated by IndicatorCalculator (vol_sma_50 renamed)\n","            'adx', 'plus_di', 'minus_di' # Calculated by IndicatorCalculator\n","        ]\n","        missing_cols = [col for col in required_internal_cols if col not in df.columns]\n","        if missing_cols:\n","            raise ValueError(f\"DataFrame missing required columns for signal processing: {missing_cols}\")\n","\n","        # --- Indicator calculations are now done *before* calling this function ---\n","        # --- Calculate Features needed only for signals (Fib, Score, Divergence) ---\n","        df = calculate_fibonacci_levels(df)\n","        df, total_possible_score = calculate_score(df) # Get total score calculated once\n","        df = calculate_rsi_divergence(df) # Uses provided RSI\n","\n","        # --- Initialize Signal Columns ---\n","        df['signal'] = 'Hold'; df['position'] = ''; df['entry_price'] = np.nan\n","        df['stop_loss'] = np.nan; df['trailing_stop'] = np.nan; df['exit_price'] = np.nan\n","        df['exit_reason'] = ''; df['entry_signal_type'] = ''\n","        df['target_price_long'] = np.nan; df['target_price_short'] = np.nan\n","        df['fib_target_long'] = np.nan; df['fib_target_short'] = np.nan\n","\n","        # --- Determine Safe Start Index (based on strategy lookbacks) ---\n","        start_index = max(\n","            (PARAMS['fibonacci']['fib_pivot_lookback'] * 2 + 1),\n","            PARAMS['fibonacci']['fib_lookback_exit'],\n","            PARAMS['core']['fib_bounce_lookback'],\n","            PARAMS['core']['ema_bounce_lookback'],\n","            PARAMS['core']['bb_bounce_lookback'],\n","            5 # Lookback for volume breakout price action check\n","        ) + 1\n","\n","        # Ensure start index is valid after potential dropna in indicator calc\n","        if start_index >= len(df):\n","             logger.warning(f\"Not enough data after indicator calculations. Required: {start_index}, Available: {len(df)}\")\n","             if 'scaled_score' not in df.columns: df['scaled_score'] = 5.0\n","             return df\n","\n","        logger.info(f\"Starting main processing loop from index {start_index}\")\n","        trade_state = TradeState()\n","        weights = PARAMS['score_weights']\n","        # total_possible_score is passed from calculate_score\n","\n","        # --- Main Processing Loop ---\n","        for i in range(start_index, len(df)):\n","            current_idx = df.index[i]; prev_idx = df.index[i-1]\n","            current = df.iloc[i]; prev = df.iloc[i-1]\n","            exit_triggered_this_bar = False; exit_price_this_bar = np.nan; exit_reason = ''\n","\n","            # --- I. Check for Exits ---\n","            if trade_state.position is not None:\n","                trade_state.time_in_trade += 1\n","                trade_state.update_trailing_stop(current['low'], current['high'], current['close'], current['atr'])\n","                df.loc[current_idx, 'trailing_stop'] = trade_state.trailing_stop\n","                potential_exit_price = current['close']\n","\n","                # Exit Priority: SL > Div > Target > Score > EMA > BB > Vol > Time\n","                if PARAMS['atr']['use_atr_stop'] and trade_state.trailing_stop is not None:\n","                    if trade_state.position == 'Long' and current['low'] <= trade_state.trailing_stop: exit_reason='Trailing Stop'; exit_price_this_bar = min(current['open'], trade_state.trailing_stop); exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and current['high'] >= trade_state.trailing_stop: exit_reason='Trailing Stop'; exit_price_this_bar = max(current['open'], trade_state.trailing_stop); exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['rsi']['use_rsi_div_exit']:\n","                    if trade_state.position == 'Long' and current['bearish_rsi_div']: exit_reason='RSI Div'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and current['bullish_rsi_div']: exit_reason='RSI Div'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['fibonacci']['use_fib_exit']:\n","                    fib_target_long = df.loc[current_idx, 'fib_target_long']; fib_target_short = df.loc[current_idx, 'fib_target_short']\n","                    if trade_state.position == 'Long' and pd.notna(fib_target_long) and current['high'] >= fib_target_long: exit_reason='Fib Target'; exit_price_this_bar = max(current['open'], fib_target_long); exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and pd.notna(fib_target_short) and current['low'] <= fib_target_short: exit_reason='Fib Target'; exit_price_this_bar = min(current['open'], fib_target_short); exit_triggered_this_bar = True\n","\n","                # Recalculate score for exit check\n","                buy_score_bar_exit = df.loc[current_idx, 'buy_score_raw']; sell_score_bar_exit = df.loc[current_idx, 'sell_score_raw']\n","                if df.loc[current_idx, 'cond_fib_bounce_buy']: buy_score_bar_exit += weights.get('w_fib_bounce', 0)\n","                if df.loc[current_idx, 'cond_fib_bounce_sell']: sell_score_bar_exit += weights.get('w_fib_bounce', 0)\n","                if df.loc[current_idx, 'cond_ema_bounce_buy']: buy_score_bar_exit += weights.get('w_ema_bounce', 0)\n","                if df.loc[current_idx, 'cond_ema_bounce_sell']: sell_score_bar_exit += weights.get('w_ema_bounce', 0)\n","                if df.loc[current_idx, 'cond_bb_bounce_buy']: buy_score_bar_exit += weights.get('w_bb_bounce', 0)\n","                if df.loc[current_idx, 'cond_bb_bounce_sell']: sell_score_bar_exit += weights.get('w_bb_bounce', 0)\n","                net_score_bar_exit = buy_score_bar_exit - sell_score_bar_exit\n","                scaled_score_bar_exit = max(0.0, min(10.0, ((net_score_bar_exit / total_possible_score) * 5.0) + 5.0))\n","                df.loc[current_idx, 'scaled_score'] = scaled_score_bar_exit # Update final score\n","\n","                if not exit_triggered_this_bar and PARAMS['core']['use_score_drop_exit']:\n","                    score_threshold = PARAMS['core']['exit_score_drop_threshold']\n","                    if trade_state.position == 'Long' and scaled_score_bar_exit < (5.0 - score_threshold): exit_reason=f'Score Drop ({scaled_score_bar_exit:.1f})'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and scaled_score_bar_exit > (5.0 + score_threshold): exit_reason=f'Score Drop ({scaled_score_bar_exit:.1f})'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['ema']['use_ema_exit']:\n","                    fast_ema_cross_med_sell = current['ema_fast'] < current['ema_med'] and prev['ema_fast'] >= prev['ema_med']; fast_ema_cross_med_buy = current['ema_fast'] > current['ema_med'] and prev['ema_fast'] <= prev['ema_med']\n","                    if trade_state.position == 'Long' and fast_ema_cross_med_sell: exit_reason='EMA Cross'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and fast_ema_cross_med_buy: exit_reason='EMA Cross'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['bollinger']['use_bb_return_exit']:\n","                    cross_under_bb_mid = current['close'] < current['bb_middle'] and prev['close'] >= prev['bb_middle']; cross_over_bb_mid = current['close'] > current['bb_middle'] and prev['close'] <= prev['bb_middle']\n","                    if trade_state.position == 'Long' and cross_under_bb_mid: exit_reason='BB Mid Exit'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and cross_over_bb_mid: exit_reason='BB Mid Exit'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['volume']['use_vol_fade_exit']:\n","                    low_vol = current['volume'] < df.loc[prev_idx, 'vol_ma']; pullback_long = current['close'] < current['ema_fast']; pullback_short = current['close'] > current['ema_fast']\n","                    if trade_state.position == 'Long' and low_vol and pullback_long: exit_reason='Vol Fade'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and low_vol and pullback_short: exit_reason='Vol Fade'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and trade_state.time_in_trade >= PARAMS['core']['max_trade_duration']: exit_reason='Time Exit'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","\n","                if exit_triggered_this_bar:\n","                    signal_prefix = 'Exit Long' if trade_state.position == 'Long' else 'Exit Short'\n","                    df.loc[current_idx, 'signal'] = signal_prefix\n","                    df.loc[current_idx, 'exit_reason'] = exit_reason\n","                    df.loc[current_idx, 'exit_price'] = exit_price_this_bar\n","                    trade_state.reset()\n","                    df.loc[current_idx:, ['target_price_long', 'target_price_short', 'fib_target_long', 'fib_target_short']] = np.nan\n","\n","            # --- II. Check for Entries ---\n","            if trade_state.position is None and not exit_triggered_this_bar:\n","                entry_signal = None; buy_score_bar = df.loc[current_idx, 'buy_score_raw']; sell_score_bar = df.loc[current_idx, 'sell_score_raw']\n","                df.loc[current_idx, ['cond_fib_bounce_buy', 'cond_fib_bounce_sell','cond_ema_bounce_buy', 'cond_ema_bounce_sell','cond_bb_bounce_buy', 'cond_bb_bounce_sell']] = False\n","\n","                # Calculate bounce/breakout conditions & update score\n","                fib_bounce_buy_cond = False; fib_bounce_sell_cond = False\n","                if PARAMS['core']['use_fib_bounce_entry'] or PARAMS['core']['use_fib_bounce_sell']:\n","                    lookback=PARAMS['core']['fib_bounce_lookback']; low_zone_long, high_zone_long = PARAMS['core']['fib_bounce_long_zone']; low_zone_short, high_zone_short = PARAMS['core']['fib_bounce_short_zone']; conf_level = PARAMS['core']['fib_bounce_confirmation_level']; rsi_conf = PARAMS['rsi']['rsi_confirm_fib']; rsi_buy_lvl, rsi_sell_lvl = PARAMS['rsi']['rsi_confirm_level_buy'], PARAMS['rsi']['rsi_confirm_level_sell']\n","                    if PARAMS['core']['use_fib_bounce_entry'] and current['is_uptrend_fib']:\n","                        fib_low_name = f'fib_{int(low_zone_long*1000)}'; fib_high_name = f'fib_{int(high_zone_long*1000)}'; fib_conf_name = f'fib_{int(conf_level*1000)}'\n","                        if fib_low_name in df.columns and fib_high_name in df.columns and fib_conf_name in df.columns:\n","                            fib_low = current[fib_low_name]; fib_high = current[fib_high_name]; fib_conf = current[fib_conf_name]\n","                            if pd.notna(fib_low) and pd.notna(fib_high) and pd.notna(fib_conf):\n","                                touched_zone = (df['low'].iloc[i-lookback:i] <= fib_high).any(); bounced_above = current['close'] > fib_conf; rsi_ok = not rsi_conf or (current['rsi'] > rsi_buy_lvl and current['rsi'] > prev['rsi'])\n","                                if touched_zone and bounced_above and rsi_ok: fib_bounce_buy_cond = True; df.loc[current_idx, 'cond_fib_bounce_buy'] = True; buy_score_bar += weights.get('w_fib_bounce', 0)\n","                    if PARAMS['core']['use_fib_bounce_sell'] and not current['is_uptrend_fib']:\n","                        fib_low_name = f'fib_{int(low_zone_short*1000)}'; fib_high_name = f'fib_{int(high_zone_short*1000)}'; fib_conf_name = f'fib_{int(conf_level*1000)}'\n","                        if fib_low_name in df.columns and fib_high_name in df.columns and fib_conf_name in df.columns:\n","                            fib_low = current[fib_low_name]; fib_high = current[fib_high_name]; fib_conf = current[fib_conf_name]\n","                            if pd.notna(fib_low) and pd.notna(fib_high) and pd.notna(fib_conf):\n","                                touched_zone = (df['high'].iloc[i-lookback:i] >= fib_low).any(); bounced_below = current['close'] < fib_conf; rsi_ok = not rsi_conf or (current['rsi'] < rsi_sell_lvl and current['rsi'] < prev['rsi'])\n","                                if touched_zone and bounced_below and rsi_ok: fib_bounce_sell_cond = True; df.loc[current_idx, 'cond_fib_bounce_sell'] = True; sell_score_bar += weights.get('w_fib_bounce', 0)\n","                ema_bounce_buy_cond = False; ema_bounce_sell_cond = False\n","                if PARAMS['core']['use_ema_bounce_buy'] or PARAMS['core']['use_ema_bounce_sell']:\n","                    lookback=PARAMS['core']['ema_bounce_lookback']; ema_source_col = 'ema_fast'; ema_source = df[ema_source_col]; rsi_conf = PARAMS['rsi']['rsi_confirm_ema']; rsi_buy_lvl, rsi_sell_lvl = PARAMS['rsi']['rsi_confirm_level_buy'], PARAMS['rsi']['rsi_confirm_level_sell']\n","                    if PARAMS['core']['use_ema_bounce_buy']:\n","                         touched_ema = (df['low'].iloc[i-lookback:i] <= ema_source.iloc[i-lookback:i]).any(); bounced_above = current['close'] > current[ema_source_col] and current['close'] > current['open']; rsi_ok = not rsi_conf or (current['rsi'] > rsi_buy_lvl and current['rsi'] > prev['rsi'])\n","                         if touched_ema and bounced_above and rsi_ok: ema_bounce_buy_cond = True; df.loc[current_idx, 'cond_ema_bounce_buy'] = True; buy_score_bar += weights.get('w_ema_bounce', 0)\n","                    if PARAMS['core']['use_ema_bounce_sell']:\n","                        touched_ema = (df['high'].iloc[i-lookback:i] >= ema_source.iloc[i-lookback:i]).any(); bounced_below = current['close'] < current[ema_source_col] and current['close'] < current['open']; rsi_ok = not rsi_conf or (current['rsi'] < rsi_sell_lvl and current['rsi'] < prev['rsi'])\n","                        if touched_ema and bounced_below and rsi_ok: ema_bounce_sell_cond = True; df.loc[current_idx, 'cond_ema_bounce_sell'] = True; sell_score_bar += weights.get('w_ema_bounce', 0)\n","                bb_bounce_buy_cond = False; bb_bounce_sell_cond = False\n","                if PARAMS['core']['use_bb_mid_bounce_buy'] or PARAMS['core']['use_bb_mid_bounce_sell']:\n","                    lookback=PARAMS['core']['bb_bounce_lookback']; bb_mid = df['bb_middle']; rsi_conf = PARAMS['rsi']['rsi_confirm_bb']; rsi_buy_lvl, rsi_sell_lvl = PARAMS['rsi']['rsi_confirm_level_buy'], PARAMS['rsi']['rsi_confirm_level_sell']\n","                    if PARAMS['core']['use_bb_mid_bounce_buy']:\n","                        touched_bb = (df['low'].iloc[i-lookback:i] <= bb_mid.iloc[i-lookback:i]).any(); bounced_above = current['close'] > current['bb_middle'] and current['close'] > current['open']; rsi_ok = not rsi_conf or (current['rsi'] > rsi_buy_lvl and current['rsi'] > prev['rsi'])\n","                        if touched_bb and bounced_above and rsi_ok: bb_bounce_buy_cond = True; df.loc[current_idx, 'cond_bb_bounce_buy'] = True; buy_score_bar += weights.get('w_bb_bounce', 0)\n","                    if PARAMS['core']['use_bb_mid_bounce_sell']:\n","                        touched_bb = (df['high'].iloc[i-lookback:i] >= bb_mid.iloc[i-lookback:i]).any(); bounced_below = current['close'] < current['bb_middle'] and current['close'] < current['open']; rsi_ok = not rsi_conf or (current['rsi'] < rsi_sell_lvl and current['rsi'] < prev['rsi'])\n","                        if touched_bb and bounced_below and rsi_ok: bb_bounce_sell_cond = True; df.loc[current_idx, 'cond_bb_bounce_sell'] = True; sell_score_bar += weights.get('w_bb_bounce', 0)\n","                vol_breakout_buy_cond = False; vol_breakout_sell_cond = False\n","                if PARAMS['core']['use_vol_breakout_buy'] or PARAMS['core']['use_vol_breakout_sell']:\n","                    high_vol = current['volume'] > current['vol_ma'] * PARAMS['volume']['vol_multiplier']; lookback_pa = 5\n","                    if i >= lookback_pa: recent_high = df['high'].iloc[i-lookback_pa:i].max(); recent_low = df['low'].iloc[i-lookback_pa:i].min()\n","                    else: recent_high = np.nan; recent_low = np.nan\n","                    if pd.notna(recent_high) and PARAMS['core']['use_vol_breakout_buy'] and high_vol and current['close'] > current['open'] and current['close'] > recent_high: vol_breakout_buy_cond = True\n","                    if pd.notna(recent_low) and PARAMS['core']['use_vol_breakout_sell'] and high_vol and current['close'] < current['open'] and current['close'] < recent_low: vol_breakout_sell_cond = True\n","\n","                # Final score calculation for the bar\n","                net_score_bar = buy_score_bar - sell_score_bar\n","                scaled_score_bar = max(0.0, min(10.0, ((net_score_bar / total_possible_score) * 5.0) + 5.0)) # Use pre-calculated total score\n","                df.loc[current_idx, 'scaled_score'] = scaled_score_bar\n","\n","                # Trend Filters\n","                trend_ok_buy = True; trend_ok_sell = True\n","                if PARAMS['trend']['use_ema_trend_filter']: trend_ok_buy &= current['cond_ema_trend_buy']; trend_ok_sell &= current['cond_ema_trend_sell']\n","                if PARAMS['trend']['use_adx_filter']: trend_ok_buy &= current['cond_adx_strength']; trend_ok_sell &= current['cond_adx_strength']\n","                if PARAMS['trend']['use_adx_direction_filter']: trend_ok_buy &= current['cond_adx_dir_buy']; trend_ok_sell &= current['cond_adx_dir_sell']\n","\n","                # Entry Decision\n","                entry_score_threshold = PARAMS['core']['entry_score_threshold']\n","                if trend_ok_buy and scaled_score_bar >= entry_score_threshold:\n","                    if fib_bounce_buy_cond: entry_signal = \"Fib Bounce Long\"\n","                    elif ema_bounce_buy_cond: entry_signal = \"EMA Bounce Long\"\n","                    elif bb_bounce_buy_cond: entry_signal = \"BB Bounce Long\"\n","                    elif vol_breakout_buy_cond: entry_signal = \"Vol Breakout Long\"\n","                    elif df.loc[current_idx,'cond_ema_signal_buy'] and df.loc[current_idx,'cond_rsi_buy']: entry_signal = \"Basic Long\"\n","                elif trend_ok_sell and scaled_score_bar <= (10.0 - entry_score_threshold):\n","                    if fib_bounce_sell_cond: entry_signal = \"Fib Bounce Short\"\n","                    elif ema_bounce_sell_cond: entry_signal = \"EMA Bounce Short\"\n","                    elif bb_bounce_sell_cond: entry_signal = \"BB Bounce Short\"\n","                    elif vol_breakout_sell_cond: entry_signal = \"Vol Breakout Short\"\n","                    elif df.loc[current_idx,'cond_ema_signal_sell'] and df.loc[current_idx,'cond_rsi_sell']: entry_signal = \"Basic Short\"\n","\n","                # Process Entry\n","                if entry_signal:\n","                    entry_price_adj = current['close'] * (1 + PARAMS['backtest']['slippage_pct']) if \"Long\" in entry_signal else current['close'] * (1 - PARAMS['backtest']['slippage_pct'])\n","                    trade_state.entry_price = entry_price_adj; trade_state.entry_index = i; trade_state.time_in_trade = 0\n","                    if \"Long\" in entry_signal:\n","                        trade_state.position = 'Long'; trade_state.highest_high_in_trade = current['high']\n","                        initial_stop = current['low'] - current['atr'] * PARAMS['core']['trailing_stop_atr_multiplier']\n","                        trade_state.trailing_stop = initial_stop; df.loc[current_idx, 'signal'] = 'Long'; df.loc[current_idx, 'stop_loss'] = initial_stop\n","                    elif \"Short\" in entry_signal:\n","                        trade_state.position = 'Short'; trade_state.lowest_low_in_trade = current['low']\n","                        initial_stop = current['high'] + current['atr'] * PARAMS['core']['trailing_stop_atr_multiplier']\n","                        trade_state.trailing_stop = initial_stop; df.loc[current_idx, 'signal'] = 'Short'; df.loc[current_idx, 'stop_loss'] = initial_stop\n","                    df.loc[current_idx, 'position'] = trade_state.position; df.loc[current_idx, 'entry_price'] = trade_state.entry_price\n","                    df.loc[current_idx, 'entry_signal_type'] = entry_signal; df.loc[current_idx, 'trailing_stop'] = trade_state.trailing_stop\n","                    df = calculate_targets_for_trade(df, i, trade_state.position, trade_state.entry_price, initial_stop)\n","\n","            # --- III. Update Position State ---\n","            if trade_state.position is not None and df.loc[current_idx, 'signal'] == 'Hold':\n","                df.loc[current_idx, 'position'] = trade_state.position\n","                df.loc[current_idx, 'entry_price'] = trade_state.entry_price\n","\n","        logger.info(\"Finished main processing loop\")\n","        return df\n","    except Exception as e:\n","        logger.error(f\"Error in process_signals: {str(e)}\", exc_info=True)\n","        raise\n","\n","# --- EnhancedSignalAnalyzer Class ---\n","# (Keep the EnhancedSignalAnalyzer class definition as it was in strategy_merged_analyzer_v3)\n","class EnhancedSignalAnalyzer:\n","    def __init__(self):\n","        self.trade_history = []\n","        self.summary_stats = defaultdict(float)\n","        self.entry_stats = defaultdict(lambda: defaultdict(float))\n","        self.exit_stats = defaultdict(lambda: defaultdict(float))\n","        self.signal_stats = defaultdict(lambda: defaultdict(float))\n","\n","    def analyze_trades(self, df: pd.DataFrame):\n","        logger.info(\"Analyzing generated trades for detailed statistics\")\n","        try:\n","            self.trade_history = []\n","            current_trade = None\n","            running_pnl = 0.0; peak_pnl = 0.0; max_drawdown = 0.0\n","            win_pnls = []; loss_pnls = []\n","            win_durations = []; loss_durations = []\n","            risk_rewards = []\n","            current_streak = 0; max_consec_wins = 0; max_consec_losses = 0\n","            current_streak_type = None\n","\n","            for i in range(len(df)):\n","                current_idx = df.index[i]\n","                signal = df.loc[current_idx, 'signal']\n","\n","                if signal in ['Long', 'Short'] and current_trade is None:\n","                    entry_price = df.loc[current_idx, 'entry_price']\n","                    stop_loss = df.loc[current_idx, 'stop_loss']\n","                    target_price_col = 'target_price_long' if signal == 'Long' else 'target_price_short'\n","                    target_price = df.loc[current_idx, target_price_col]\n","                    if pd.notna(entry_price) and pd.notna(stop_loss):\n","                        current_trade = {'entry_index': i, 'entry_idx_time': current_idx, 'entry_price': entry_price, 'position': signal, 'stop_loss': stop_loss, 'target_price': target_price, 'signal_type': df.loc[current_idx, 'entry_signal_type']}\n","                        if current_trade['position'] == 'Long': risk = current_trade['entry_price'] - current_trade['stop_loss']; reward = current_trade['target_price'] - current_trade['entry_price'] if pd.notna(current_trade['target_price']) else np.nan\n","                        else: risk = current_trade['stop_loss'] - current_trade['entry_price']; reward = current_trade['entry_price'] - current_trade['target_price'] if pd.notna(current_trade['target_price']) else np.nan\n","                        current_trade['risk_at_entry'] = risk; current_trade['reward_at_entry'] = reward\n","                        current_trade['risk_reward_ratio'] = reward / risk if risk > 0 and pd.notna(reward) else np.nan\n","\n","                elif current_trade and 'Exit' in signal:\n","                    exit_price = df.loc[current_idx, 'exit_price']\n","                    if pd.isna(exit_price): exit_price = df.loc[current_idx, 'close']; logger.warning(f\"Exit price NaN for trade entered on {current_trade['entry_idx_time'].date()}, using close price {exit_price:.2f}\")\n","                    exit_idx_time = current_idx; exit_reason = df.loc[current_idx, 'exit_reason']\n","                    if current_trade['position'] == 'Long': pnl_points = exit_price - current_trade['entry_price']\n","                    else: pnl_points = current_trade['entry_price'] - exit_price\n","                    commission = (current_trade['entry_price'] + exit_price) * PARAMS['backtest']['commission_pct']\n","                    net_pnl_points = pnl_points - commission\n","                    pct_change = (net_pnl_points / current_trade['entry_price']) * 100 if current_trade['entry_price'] else 0\n","                    duration_delta = exit_idx_time - current_trade['entry_idx_time']; duration_bars = i - current_trade['entry_index']\n","                    outcome = 'Win' if net_pnl_points > 0 else 'Loss'\n","                    trade_record = {**current_trade, 'exit_idx_time': exit_idx_time, 'exit_price': exit_price, 'pnl_points': net_pnl_points, 'pct_change': pct_change, 'duration_delta': duration_delta, 'duration_bars': duration_bars, 'outcome': outcome, 'exit_reason': exit_reason}\n","                    self.trade_history.append(trade_record)\n","                    self.summary_stats['total_trades'] += 1; self.summary_stats['total_pnl'] += net_pnl_points\n","                    if outcome == 'Win': self.summary_stats['winning_trades'] += 1; win_pnls.append(net_pnl_points); win_durations.append(duration_bars)\n","                    else: self.summary_stats['losing_trades'] += 1; loss_pnls.append(abs(net_pnl_points)); loss_durations.append(duration_bars)\n","                    if pd.notna(current_trade['risk_reward_ratio']): risk_rewards.append(current_trade['risk_reward_ratio'])\n","                    if outcome == current_streak_type: current_streak += 1\n","                    else: current_streak = 1; current_streak_type = outcome\n","                    if outcome == 'Win': max_consec_wins = max(max_consec_wins, current_streak)\n","                    else: max_consec_losses = max(max_consec_losses, current_streak)\n","                    running_pnl += net_pnl_points; peak_pnl = max(peak_pnl, running_pnl); drawdown = peak_pnl - running_pnl\n","                    self.summary_stats['max_drawdown_points'] = max(self.summary_stats.get('max_drawdown_points', 0.0), drawdown)\n","                    pos = current_trade['position']; sig_type = current_trade['signal_type']; exit_type = exit_reason\n","                    self.entry_stats[pos]['total'] += 1; self.entry_stats[pos]['total_pnl'] += net_pnl_points; self.entry_stats[pos]['total_duration_bars'] += duration_bars\n","                    if outcome == 'Win': self.entry_stats[pos]['success'] += 1\n","                    if exit_type == 'Trailing Stop' or exit_type == 'ATR Stop': self.entry_stats[pos]['sl_hit'] += 1\n","                    if exit_type == 'Fib Target' or exit_type == 'Target': self.entry_stats[pos]['target_hit'] += 1\n","                    self.exit_stats[exit_type]['total'] += 1; self.exit_stats[exit_type]['total_pnl'] += net_pnl_points; self.exit_stats[exit_type]['total_duration_bars'] += duration_bars\n","                    if outcome == 'Win': self.exit_stats[exit_type]['success'] += 1\n","                    self.signal_stats[sig_type]['total'] += 1; self.signal_stats[sig_type]['total_pnl'] += net_pnl_points\n","                    if outcome == 'Win': self.signal_stats[sig_type]['success'] += 1\n","                    current_trade = None\n","\n","            if self.summary_stats['total_trades'] > 0:\n","                avg_win = np.mean(win_pnls) if win_pnls else 0; avg_loss = np.mean(loss_pnls) if loss_pnls else 0\n","                self.summary_stats['win_rate'] = (self.summary_stats['winning_trades'] / self.summary_stats['total_trades']) * 100\n","                self.summary_stats['avg_win_points'] = avg_win; self.summary_stats['avg_loss_points'] = avg_loss\n","                self.summary_stats['profit_factor'] = abs(sum(win_pnls) / sum(loss_pnls)) if sum(loss_pnls) != 0 else np.inf\n","                self.summary_stats['expectancy_points'] = (avg_win * (self.summary_stats['win_rate']/100)) - (avg_loss * (1 - self.summary_stats['win_rate']/100))\n","                self.summary_stats['max_consec_wins'] = max_consec_wins; self.summary_stats['max_consec_losses'] = max_consec_losses\n","                self.summary_stats['avg_win_duration_bars'] = np.mean(win_durations) if win_durations else 0\n","                self.summary_stats['avg_loss_duration_bars'] = np.mean(loss_durations) if loss_durations else 0\n","                self.summary_stats['avg_risk_reward_ratio'] = np.nanmean(risk_rewards) if risk_rewards else np.nan\n","                health_score = min(100, max(0, (self.summary_stats['win_rate'] * 0.4) + (min(self.summary_stats['profit_factor'], 5) * 10 if pd.notna(self.summary_stats['profit_factor']) else 0) + (1 - (self.summary_stats['avg_loss_duration_bars']/self.summary_stats['avg_win_duration_bars'] if self.summary_stats['avg_win_duration_bars'] > 0 else 1) * 20) + (self.summary_stats['avg_risk_reward_ratio'] * 10 if pd.notna(self.summary_stats['avg_risk_reward_ratio']) else 0) ))\n","                self.summary_stats['health_score'] = health_score\n","\n","            for pos in list(self.entry_stats.keys()):\n","                if self.entry_stats[pos]['total'] > 0: self.entry_stats[pos]['avg_pnl'] = self.entry_stats[pos]['total_pnl'] / self.entry_stats[pos]['total']; self.entry_stats[pos]['avg_duration_bars'] = self.entry_stats[pos]['total_duration_bars'] / self.entry_stats[pos]['total']; self.entry_stats[pos]['win_rate'] = (self.entry_stats[pos]['success'] / self.entry_stats[pos]['total']) * 100; self.entry_stats[pos]['sl_rate'] = (self.entry_stats[pos]['sl_hit'] / self.entry_stats[pos]['total']) * 100; self.entry_stats[pos]['target_rate'] = (self.entry_stats[pos]['target_hit'] / self.entry_stats[pos]['total']) * 100\n","            for exit_type in list(self.exit_stats.keys()):\n","                 if self.exit_stats[exit_type]['total'] > 0: self.exit_stats[exit_type]['avg_pnl'] = self.exit_stats[exit_type]['total_pnl'] / self.exit_stats[exit_type]['total']; self.exit_stats[exit_type]['avg_duration_bars'] = self.exit_stats[exit_type]['total_duration_bars'] / self.exit_stats[exit_type]['total']; self.exit_stats[exit_type]['win_rate'] = (self.exit_stats[exit_type]['success'] / self.exit_stats[exit_type]['total']) * 100\n","            for sig_type in list(self.signal_stats.keys()):\n","                 if self.signal_stats[sig_type]['total'] > 0: self.signal_stats[sig_type]['avg_pnl'] = self.signal_stats[sig_type]['total_pnl'] / self.signal_stats[sig_type]['total']; self.signal_stats[sig_type]['win_rate'] = (self.signal_stats[sig_type]['success'] / self.signal_stats[sig_type]['total']) * 100\n","\n","            logger.info(\"Finished analyzing trades.\")\n","            return df\n","        except Exception as e:\n","            logger.error(f\"Error in analyze_trades: {str(e)}\", exc_info=True)\n","            raise\n","\n","    def print_summary(self):\n","        if not self.summary_stats or self.summary_stats['total_trades'] == 0:\n","             print(\"\\nNo trades to summarize.\")\n","             logger.info(\"No trades to summarize.\")\n","             return\n","        try:\n","            summary = [ f\"\\n=== ENHANCED TRADE SUMMARY ===\", f\"Total Trades: {int(self.summary_stats['total_trades'])}\", f\"Winning Trades: {int(self.summary_stats['winning_trades'])} ({self.summary_stats['win_rate']:.1f}%)\", f\"Losing Trades: {int(self.summary_stats['losing_trades'])}\", f\"Total P&L (Points): {self.summary_stats['total_pnl']:.2f}\", f\"Profit Factor: {self.summary_stats['profit_factor']:.2f}\", f\"Expectancy (Points): {self.summary_stats['expectancy_points']:.2f}\", f\"Max Drawdown (Points): {self.summary_stats['max_drawdown_points']:.2f}\", f\"Avg Win / Avg Loss (Points): {self.summary_stats['avg_win_points']:.2f} / {self.summary_stats['avg_loss_points']:.2f}\", f\"Max Consecutive Wins: {int(self.summary_stats['max_consec_wins'])}\", f\"Max Consecutive Losses: {int(self.summary_stats['max_consec_losses'])}\", f\"Avg Win Duration (Bars): {self.summary_stats['avg_win_duration_bars']:.1f}\", f\"Avg Loss Duration (Bars): {self.summary_stats['avg_loss_duration_bars']:.1f}\", f\"Avg Risk/Reward Ratio (at Entry): {self.summary_stats['avg_risk_reward_ratio']:.2f}:1\" if pd.notna(self.summary_stats['avg_risk_reward_ratio']) else \"N/A\", f\"Strategy Health Score: {self.summary_stats['health_score']:.1f}/100\", \"\\n=== ENTRY STATISTICS ===\", \"Position | Total | Win % | Avg P&L | Avg Dur | SL % | Target %\", \"-------------------------------------------------------------\"]\n","            for position, stats in self.entry_stats.items(): summary.append(f\"{position:8} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f} | {stats['avg_duration_bars']:7.1f} | {stats['sl_rate']:4.1f}% | {stats['target_rate']:6.1f}%\")\n","            summary.extend([\"\\n=== EXIT STATISTICS ===\", \"Exit Type           | Total | Win % | Avg P&L | Avg Dur\", \"------------------------------------------------------\"])\n","            for exit_type, stats in sorted(self.exit_stats.items()): summary.append(f\"{str(exit_type):19} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f} | {stats['avg_duration_bars']:7.1f}\")\n","            summary.extend([\"\\n=== SIGNAL TYPE STATISTICS ===\", \"Signal Type          | Total | Win % | Avg P&L\", \"---------------------------------------------\"])\n","            for signal_type, stats in sorted(self.signal_stats.items()):\n","                 if not signal_type: continue\n","                 summary.append(f\"{str(signal_type):20} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f}\")\n","\n","            print(\"\\n\".join(summary)); logger.info(\"\\n\".join(summary))\n","            health = self.summary_stats['health_score']\n","            if health >= 70: health_indicator = \" STRONG\"\n","            elif health >= 50: health_indicator = \" MODERATE\"\n","            else: health_indicator = \" WEAK\"\n","            print(f\"\\nStrategy Health: {health_indicator}\")\n","            if self.summary_stats['total_trades'] < 30: print(\"  Warning: Low sample size (<30 trades)\")\n","        except Exception as e:\n","            logger.error(f\"Error printing summary: {str(e)}\", exc_info=True)\n","            raise\n","\n","# --- Plotting Function ---\n","# (Keep the plot_signals function as it was in strategy_merged_analyzer_v3)\n","def plot_signals(df: pd.DataFrame, save_path: Optional[Path] = None):\n","    logger.info(\"Generating signal plot\")\n","    plt.style.use('seaborn-v0_8-darkgrid')\n","    fig, axes = plt.subplots(4, 1, sharex=True, figsize=(20, 15))\n","    if df.empty: logger.warning(\"Plotting skipped: DataFrame is empty.\"); return\n","\n","    ax1 = axes[0] # Price Chart\n","    ax1.plot(df['close'], label='Price', color='black', alpha=0.9, linewidth=1.0)\n","    if 'ema_fast' in df.columns: ax1.plot(df['ema_fast'], label=f\"EMA Fast\", alpha=0.6, linewidth=0.8)\n","    if 'ema_med' in df.columns: ax1.plot(df['ema_med'], label=f\"EMA Med ({PARAMS['ema']['med_len']})\", alpha=0.6, linewidth=0.8)\n","    if 'ema_slow' in df.columns: ax1.plot(df['ema_slow'], label=f\"EMA Slow\", alpha=0.6, linewidth=0.8)\n","    long_entries = df[df['signal'] == 'Long']; short_entries = df[df['signal'] == 'Short']\n","    long_exits = df[df['signal'].str.contains('Exit Long', na=False)]; short_exits = df[df['signal'].str.contains('Exit Short', na=False)]\n","    if not long_entries.empty: ax1.scatter(long_entries.index, long_entries['entry_price'], marker='^', color='lime', s=100, label='Long Entry', zorder=5, edgecolors='black')\n","    if not short_entries.empty: ax1.scatter(short_entries.index, short_entries['entry_price'], marker='v', color='red', s=100, label='Short Entry', zorder=5, edgecolors='black')\n","    # Plot exits at exit_price if available, otherwise close\n","    exit_long_prices = long_exits['exit_price'].fillna(long_exits['close'])\n","    exit_short_prices = short_exits['exit_price'].fillna(short_exits['close'])\n","    if not long_exits.empty: ax1.scatter(long_exits.index, exit_long_prices, marker='x', color='fuchsia', s=80, label='Exit', zorder=5)\n","    if not short_exits.empty: ax1.scatter(short_exits.index, exit_short_prices, marker='x', color='fuchsia', s=80, zorder=5)\n","    if 'trailing_stop' in df.columns: ax1.plot(df['trailing_stop'], label='Trailing Stop', linestyle='--', color='purple', alpha=0.7, linewidth=1.0)\n","    if 'target_price_long' in df.columns: ax1.scatter(df.index, df['target_price_long'], marker='_', color='blue', alpha=0.5, s=50, label='Long Target')\n","    if 'target_price_short' in df.columns: ax1.scatter(df.index, df['target_price_short'], marker='_', color='orange', alpha=0.5, s=50, label='Short Target')\n","    ax1.legend(loc='upper left'); ax1.set_title('Price, EMAs, Signals, Stops & Targets'); ax1.set_ylabel('Price'); ax1.grid(True, which='both', linestyle=':', linewidth=0.5)\n","\n","    ax_score = axes[1] # Score Chart\n","    if 'scaled_score' in df.columns:\n","        ax_score.plot(df['scaled_score'], label='Scaled Score (0-10)', color='teal', linewidth=1.5)\n","        ax_score.axhline(PARAMS['core']['entry_score_threshold'], color='green', linestyle='--', alpha=0.5, label=f'Long Entry Thresh')\n","        ax_score.axhline(10.0 - PARAMS['core']['entry_score_threshold'], color='red', linestyle='--', alpha=0.5, label=f'Short Entry Thresh')\n","        if PARAMS['core']['use_score_drop_exit']:\n","            ax_score.axhline(5.0 - PARAMS['core']['exit_score_drop_threshold'], color='red', linestyle=':', alpha=0.4, label=f'Long Exit Drop')\n","            ax_score.axhline(5.0 + PARAMS['core']['exit_score_drop_threshold'], color='green', linestyle=':', alpha=0.4, label=f'Short Exit Drop')\n","        ax_score.set_ylim(0, 10); ax_score.legend(loc='upper left'); ax_score.set_title('Confidence Score'); ax_score.set_ylabel('Score'); ax_score.grid(True, which='both', linestyle=':', linewidth=0.5)\n","    else: ax_score.set_title('Confidence Score (Not Calculated)'); ax_score.grid(True)\n","\n","    ax_rsi = axes[2] # RSI Chart\n","    if 'rsi' in df.columns:\n","        ax_rsi.plot(df['rsi'], label='RSI', color='orange', linewidth=1.0)\n","        ax_rsi.axhline(50, linestyle='--', color='gray', alpha=0.5); ax_rsi.axhline(PARAMS['rsi']['rsi_buy_level'], linestyle=':', color='green', alpha=0.4); ax_rsi.axhline(PARAMS['rsi']['rsi_sell_level'], linestyle=':', color='red', alpha=0.4)\n","        if 'bullish_rsi_div' in df.columns and 'bearish_rsi_div' in df.columns:\n","            bull_div = df[df['bullish_rsi_div']]; bear_div = df[df['bearish_rsi_div']]\n","            if not bull_div.empty: ax_rsi.scatter(bull_div.index, bull_div['rsi'] * 0.98, marker='^', color='cyan', s=50, label='Bullish Div', zorder=5)\n","            if not bear_div.empty: ax_rsi.scatter(bear_div.index, bear_div['rsi'] * 1.02, marker='v', color='magenta', s=50, label='Bearish Div', zorder=5)\n","        ax_rsi.legend(loc='upper left'); ax_rsi.set_title('RSI & Divergence'); ax_rsi.set_ylabel('RSI'); ax_rsi.grid(True, which='both', linestyle=':', linewidth=0.5)\n","    else: ax_rsi.set_title('RSI (Not Calculated)'); ax_rsi.grid(True)\n","\n","    ax_macd = axes[3] # MACD Chart\n","    if 'macd' in df.columns and 'macd_signal' in df.columns and 'macd_hist' in df.columns:\n","        ax_macd.plot(df['macd'], label='MACD', color='blue', linewidth=1.0); ax_macd.plot(df['macd_signal'], label='Signal', color='red', alpha=0.8, linewidth=1.0)\n","        colors = ['g' if v >= 0 else 'r' for v in df['macd_hist']]; ax_macd.bar(df.index, df['macd_hist'], label='Histogram', color=colors, alpha=0.5)\n","        ax_macd.axhline(0, linestyle='--', color='gray', alpha=0.5); ax_macd.legend(loc='upper left'); ax_macd.set_title('MACD'); ax_macd.set_ylabel('MACD'); ax_macd.grid(True, which='both', linestyle=':', linewidth=0.5)\n","    else: ax_macd.set_title('MACD (Not Calculated)'); ax_macd.grid(True)\n","\n","    axes[-1].tick_params(axis='x', rotation=45)\n","    plt.xlabel('Date')\n","    plt.tight_layout(rect=[0, 0.03, 1, 0.97])\n","    fig.suptitle('Trading Strategy Signals and Indicators', fontsize=16)\n","\n","    if save_path: plt.savefig(save_path, dpi=150); logger.info(f\"Saved signal plot to {save_path}\")\n","    else: plt.show()\n","    plt.close(fig)\n","\n","# --- Command Line Argument Parsing ---\n","def parse_args():\n","    parser = argparse.ArgumentParser(description='Calculate indicators, generate signals, and calculate detailed stats.')\n","    parser.add_argument('--input', type=str, default=str(DEFAULT_INPUT_FILE), help=f'Input RAW OHLCV CSV (default: {DEFAULT_INPUT_FILE})')\n","    parser.add_argument('--output', type=str, default=str(DEFAULT_OUTPUT_FILE), help=f'Output CSV (default: {DEFAULT_OUTPUT_FILE})')\n","    parser.add_argument('--plot', type=str, default=str(DEFAULT_PLOT_FILE), help=f'Plot image path (default: {DEFAULT_PLOT_FILE})')\n","    parser.add_argument('--no-plot', action='store_true', help='Disable generating plot')\n","    parser.add_argument('--full-history', action='store_true', help='Run on full history')\n","    return parser.parse_args()\n","\n","# --- Main Execution Block ---\n","if __name__ == \"__main__\":\n","    args = parse_args()\n","    input_file = Path(args.input); output_file = Path(args.output); plot_file = Path(args.plot)\n","\n","    try:\n","        output_file.parent.mkdir(parents=True, exist_ok=True)\n","        if not args.no_plot: plot_file.parent.mkdir(parents=True, exist_ok=True)\n","\n","        logger.info(f\"Loading data from {input_file}\")\n","        if not input_file.exists(): raise FileNotFoundError(f\"Input file not found: {input_file}\")\n","        # Load raw data\n","        df_raw = pd.read_csv(input_file, parse_dates=['datetime'], index_col='datetime')\n","        if df_raw.empty: raise pd.errors.EmptyDataError(\"Input file is empty.\")\n","        # Initial validation for OHLCV\n","        required_ohlcv = ['open', 'high', 'low', 'close', 'volume']\n","        if not all(col in df_raw.columns for col in required_ohlcv): raise ValueError(f\"Input CSV must contain OHLCV columns: {', '.join(required_ohlcv)}\")\n","\n","        # --- Calculate Indicators ---\n","        logger.info(\"Calculating all indicators...\")\n","        calculator = IndicatorCalculator() # Use default params or pass custom dict\n","        df_with_indicators = calculator.calculate_all_indicators(df_raw)\n","        logger.info(f\"Indicators calculated. DataFrame shape: {df_with_indicators.shape}\")\n","        if df_with_indicators.empty:\n","             logger.warning(\"DataFrame empty after indicator calculation (likely due to NaNs). Exiting.\")\n","             sys.exit(0)\n","\n","\n","        # --- Rename columns for strategy logic ---\n","        # Map names from IndicatorCalculator output to names expected by process_signals\n","        rename_map = {\n","            'ema_9': 'ema_fast',\n","            'ema_14': 'ema_med', # EMA 14 calculated by calculator now\n","            'ema_21': 'ema_slow',\n","            'bollinger_mid': 'bb_middle',\n","            'bollinger_upper': 'bb_upper',\n","            'bollinger_lower': 'bb_lower',\n","            'vol_sma_50': 'vol_ma', # Map calculated volume SMA\n","            # Keep macd, macd_signal, macd_hist, rsi, atr, adx, plus_di, minus_di as is (names match)\n","        }\n","        df_renamed = df_with_indicators.rename(columns=rename_map)\n","        logger.info(\"Renamed calculated indicator columns for internal use.\")\n","\n","        # --- Verify all columns needed for process_signals exist ---\n","        required_internal_cols = [\n","            'open', 'high', 'low', 'close', 'volume', 'atr', 'rsi',\n","            'macd', 'macd_signal', 'macd_hist',\n","            'ema_fast', 'ema_med', 'ema_slow',\n","            'bb_middle', 'bb_upper', 'bb_lower',\n","            'vol_ma', 'adx', 'plus_di', 'minus_di'\n","        ]\n","        missing_internal_cols = [col for col in required_internal_cols if col not in df_renamed.columns]\n","        if missing_internal_cols:\n","            raise ValueError(f\"DataFrame missing required columns after calculation/rename for signal processing: {missing_internal_cols}\")\n","\n","\n","        # --- Filter Data ---\n","        if PARAMS['backtest']['filter_last_month'] and not args.full_history:\n","            if not df_renamed.empty:\n","                last_date = df_renamed.index.max(); one_month_prior = last_date - pd.DateOffset(months=1)\n","                df = df_renamed.loc[one_month_prior:].copy()\n","                logger.info(f\"Filtered data from {df.index.min().date()} to {df.index.max().date()}.\")\n","            else: df = df_renamed # Should not happen if initial load worked\n","        else: df = df_renamed.copy(); logger.info(f\"Using full data history from {df.index.min().date()} to {df.index.max().date()}.\")\n","\n","        if df.empty:\n","             logger.warning(\"DataFrame empty after filtering. Skipping processing.\")\n","             df_processed = df; analyzer = None\n","        else:\n","            logger.info(\"Processing signals using calculated indicators...\")\n","            df_processed = process_signals(df) # Generate signals\n","\n","            logger.info(\"Analyzing trades...\")\n","            analyzer = EnhancedSignalAnalyzer() # Instantiate analyzer\n","            analyzer.analyze_trades(df_processed) # Analyze the processed df\n","            analyzer.print_summary() # Print detailed stats\n","\n","        logger.info(f\"Saving results to {output_file}\")\n","        df_processed.to_csv(output_file) # Save df with signals & indicators\n","\n","        # --- Plotting ---\n","        if not args.no_plot and not df_processed.empty:\n","            plot_signals(df_processed, plot_file)\n","        elif not args.no_plot and df_processed.empty:\n","             logger.warning(\"Plotting skipped as no data.\")\n","\n","        logger.info(\"Processing completed successfully\")\n","        sys.exit(0)\n","\n","    except FileNotFoundError as e: logger.error(str(e)); sys.exit(1)\n","    except pd.errors.EmptyDataError as e: logger.error(f\"Input file '{input_file}' empty/corrupt.\"); sys.exit(1)\n","    except ValueError as e: logger.error(f\"Data validation error: {str(e)}\"); sys.exit(1)\n","    except Exception as e: logger.error(f\"Unexpected error: {str(e)}\", exc_info=True); sys.exit(1)"],"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":176},"id":"oTRBjpeKVycx","executionInfo":{"status":"error","timestamp":1743712187452,"user_tz":-330,"elapsed":354,"user":{"displayName":"CHANDRA SHEKHAR","userId":"04101457621295165703"}},"outputId":"8ba1243d-dce7-4206-add0-a7bc5977fd78"},"execution_count":5,"outputs":[{"output_type":"stream","name":"stderr","text":["usage: colab_kernel_launcher.py [-h] [--input INPUT] [--output OUTPUT] [--plot PLOT] [--no-plot]\n","                                [--full-history]\n","colab_kernel_launcher.py: error: unrecognized arguments: -f /root/.local/share/jupyter/runtime/kernel-a25e29b8-4e61-4a16-a1d5-4190dd1283fc.json\n"]},{"output_type":"error","ename":"SystemExit","evalue":"2","traceback":["An exception has occurred, use %tb to see the full traceback.\n","\u001b[0;31mSystemExit\u001b[0m\u001b[0;31m:\u001b[0m 2\n"]},{"output_type":"stream","name":"stderr","text":["/usr/local/lib/python3.11/dist-packages/IPython/core/interactiveshell.py:3561: UserWarning: To exit: use 'exit', 'quit', or Ctrl-D.\n","  warn(\"To exit: use 'exit', 'quit', or Ctrl-D.\", stacklevel=1)\n"]}]},{"cell_type":"code","source":[],"metadata":{"id":"F1ptUjXSWAI6"},"execution_count":null,"outputs":[]}],"metadata":{"colab":{"provenance":[]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}