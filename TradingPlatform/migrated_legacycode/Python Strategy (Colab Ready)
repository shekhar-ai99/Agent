{"cells":[{"cell_type":"code","source":["import numpy as np\n","import pandas as pd\n","import os\n","import logging\n","import matplotlib.pyplot as plt\n","from typing import Dict, Any, Optional, Tuple, List\n","from pathlib import Path\n","# import argparse # Removed for Colab\n","from datetime import timedelta\n","from collections import defaultdict # Needed for EnhancedSignalAnalyzer\n","import sys # Needed for exit code in main\n","\n","# Initialize logging\n","logging.basicConfig(\n","    level=logging.INFO,\n","    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n","    handlers=[\n","        logging.FileHandler('signals_calculator_analyzer.log'), # Log file name\n","        logging.StreamHandler()\n","    ]\n",")\n","logger = logging.getLogger(__name__)\n","\n","# Configuration (Defaults - less relevant when paths are hardcoded below)\n","DATA_FOLDER = Path(\"data\")\n","DEFAULT_INPUT_FILE = DATA_FOLDER / \"nifty_historical_data.csv\"\n","DEFAULT_OUTPUT_FILE = DATA_FOLDER / \"nifty_signals_final_calculated.csv\"\n","DEFAULT_PLOT_FILE = DATA_FOLDER / \"signals_plot_calculated.png\"\n","\n","# --- IndicatorCalculator Class ---\n","class IndicatorCalculator:\n","    \"\"\"Enhanced technical indicator calculator with complete implementations\"\"\"\n","\n","    DEFAULT_PARAMS = {\n","        'sma_periods': [20, 50, 200],\n","        'ema_periods': [9, 14, 21, 50], # Added 14 for ema_med\n","        'macd_params': (12, 26, 9),\n","        'rsi_period': 14,\n","        'stochastic_period': 14,\n","        'bollinger_period': 20,\n","        'bollinger_std': 2,\n","        'atr_period': 14,\n","        'adx_period': 14, # Added ADX period\n","        'vol_sma_period': 50, # Added Volume SMA period\n","        'obv_ema_period': 21,\n","        'vwap_enabled': True\n","    }\n","\n","    def __init__(self, params: Optional[Dict] = None):\n","        self.params = {**self.DEFAULT_PARAMS, **(params or {})}\n","        self._validate_params()\n","\n","    def _validate_params(self) -> None:\n","        periods_to_check = [\n","            *self.params['sma_periods'], *self.params['ema_periods'],\n","            self.params['rsi_period'], self.params['stochastic_period'],\n","            self.params['bollinger_period'], self.params['atr_period'],\n","            self.params['adx_period'], self.params['vol_sma_period']\n","        ]\n","        if any(p <= 0 for p in periods_to_check): raise ValueError(\"All periods must be positive integers\")\n","        if self.params['bollinger_std'] <= 0: raise ValueError(\"Bollinger standard deviation must be positive\")\n","\n","    def validate_dataframe(self, df: pd.DataFrame) -> None:\n","        required_columns = ['open', 'high', 'low', 'close', 'volume']\n","        missing = [col for col in required_columns if col not in df.columns]\n","        if missing: raise ValueError(f\"Missing required columns: {missing}\")\n","        for col in required_columns:\n","            if not pd.api.types.is_numeric_dtype(df[col]): raise ValueError(f\"Column {col} must be numeric\")\n","        min_period = max([p for p in self.params.values() if isinstance(p, int) and p > 0] + [max(p) for p in self.params.values() if isinstance(p, list) and p])\n","        if len(df) < min_period: logger.warning(f\"Limited data points ({len(df)}) may affect indicator accuracy (min {min_period} recommended)\")\n","        if (df['high'] < df['low']).any(): raise ValueError(\"High price cannot be less than low price\")\n","        if (df['close'] > df['high']).any() or (df['close'] < df['low']).any(): raise ValueError(\"Close price must be between high and low\")\n","        if (df['volume'] < 0).any(): raise ValueError(\"Volume cannot be negative\")\n","\n","    def calculate_trend_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            for period in self.params['sma_periods']: df[f'sma_{period}'] = df['close'].rolling(window=period, min_periods=1).mean()\n","            for period in self.params['ema_periods']: df[f'ema_{period}'] = df['close'].ewm(span=period, adjust=False, min_periods=1).mean()\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating trend indicators: {str(e)}\"); raise\n","\n","    def calculate_macd(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            fast, slow, signal = self.params['macd_params']\n","            ema_fast = df['close'].ewm(span=fast, adjust=False, min_periods=1).mean()\n","            ema_slow = df['close'].ewm(span=slow, adjust=False, min_periods=1).mean()\n","            df['macd'] = ema_fast - ema_slow\n","            df['macd_signal'] = df['macd'].ewm(span=signal, adjust=False, min_periods=1).mean()\n","            df['macd_hist'] = df['macd'] - df['macd_signal']\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating MACD: {str(e)}\"); raise\n","\n","    def calculate_rsi(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['rsi_period']; delta = df['close'].diff()\n","            if len(delta) < period: logger.warning(f\"Insufficient data for RSI ({len(delta)} points)\"); df['rsi'] = np.nan; return df\n","            gain = delta.where(delta > 0, 0.0); loss = -delta.where(delta < 0, 0.0)\n","            avg_gain = gain.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            avg_loss = loss.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            rs = avg_gain / avg_loss.replace(0, 1e-6)\n","            df['rsi'] = 100.0 - (100.0 / (1.0 + rs))\n","            df['rsi'] = df['rsi'].fillna(50); df['rsi'] = df['rsi'].clip(0, 100)\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating RSI: {str(e)}\"); raise\n","\n","    def calculate_stochastic(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['stochastic_period']\n","            low_min = df['low'].rolling(window=period, min_periods=1).min()\n","            high_max = df['high'].rolling(window=period, min_periods=1).max()\n","            df['stochastic_k'] = 100 * ((df['close'] - low_min) / (high_max - low_min).replace(0, 1e-6))\n","            df['stochastic_d'] = df['stochastic_k'].rolling(window=3, min_periods=1).mean()\n","            df['stochastic_k'] = df['stochastic_k'].fillna(50); df['stochastic_d'] = df['stochastic_d'].fillna(50)\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating Stochastic: {str(e)}\"); raise\n","\n","    def calculate_bollinger_bands(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['bollinger_period']; std_dev = self.params['bollinger_std']\n","            sma = df['close'].rolling(window=period, min_periods=1).mean()\n","            rolling_std = df['close'].rolling(window=period, min_periods=1).std()\n","            df['bollinger_upper'] = sma + (std_dev * rolling_std)\n","            df['bollinger_lower'] = sma - (std_dev * rolling_std)\n","            df['bollinger_mid'] = sma\n","            df['bollinger_bandwidth'] = (df['bollinger_upper'] - df['bollinger_lower']) / df['bollinger_mid'].replace(0, 1e-6)\n","            df['bollinger_pctb'] = (df['close'] - df['bollinger_lower']) / (df['bollinger_upper'] - df['bollinger_lower']).replace(0, 1e-6)\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating Bollinger Bands: {str(e)}\"); raise\n","\n","    def calculate_atr(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['atr_period']\n","            high_low = df['high'] - df['low']\n","            high_close = (df['high'] - df['close'].shift()).abs()\n","            low_close = (df['low'] - df['close'].shift()).abs()\n","            true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)\n","            df['atr'] = true_range.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating ATR: {str(e)}\"); raise\n","\n","    def calculate_adx(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['adx_period']\n","            if 'atr' not in df.columns: df = self.calculate_atr(df)\n","            up_move = df['high'].diff(); down_move = -df['low'].diff()\n","            plus_dm = ((up_move > down_move) & (up_move > 0)) * up_move\n","            minus_dm = ((down_move > up_move) & (down_move > 0)) * down_move\n","            plus_dm = plus_dm.fillna(0); minus_dm = minus_dm.fillna(0)\n","            smooth_plus_dm = plus_dm.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            smooth_minus_dm = minus_dm.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            atr_smoothed = df['atr'].replace(0, 1e-6)\n","            df['plus_di'] = 100 * (smooth_plus_dm / atr_smoothed)\n","            df['minus_di'] = 100 * (smooth_minus_dm / atr_smoothed)\n","            di_sum = (df['plus_di'] + df['minus_di']).replace(0, 1e-6)\n","            dx = 100 * (abs(df['plus_di'] - df['minus_di']) / di_sum)\n","            df['adx'] = dx.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            df[['plus_di', 'minus_di', 'adx']] = df[['plus_di', 'minus_di', 'adx']].fillna(0)\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating ADX: {str(e)}\"); raise\n","\n","    def calculate_volume_sma(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['vol_sma_period']\n","            df[f'vol_sma_{period}'] = df['volume'].rolling(window=period, min_periods=1).mean()\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating Volume SMA: {str(e)}\"); raise\n","\n","    def calculate_volume_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            df['obv'] = (np.sign(df['close'].diff()) * df['volume']).fillna(0).cumsum()\n","            df['obv_ema'] = df['obv'].ewm(span=self.params['obv_ema_period'], adjust=False).mean()\n","            if self.params['vwap_enabled']:\n","                df['vwap'] = (df['close'] * df['volume']).cumsum() / df['volume'].cumsum().replace(0, 1e-6)\n","            df = self.calculate_volume_sma(df)\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating volume indicators: {str(e)}\"); raise\n","\n","    def calculate_all_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            self.validate_dataframe(df)\n","            df = df.copy()\n","            df = self.calculate_trend_indicators(df)\n","            df = self.calculate_macd(df)\n","            df = self.calculate_rsi(df)\n","            df = self.calculate_stochastic(df)\n","            df = self.calculate_bollinger_bands(df)\n","            df = self.calculate_atr(df)\n","            df = self.calculate_adx(df)\n","            df = self.calculate_volume_indicators(df)\n","            logger.info(f\"Successfully calculated indicators\")\n","            max_lookback = max([p for p in self.params.values() if isinstance(p, int) and p > 0] + [max(p) for p in self.params.values() if isinstance(p, list) and p])\n","            df = df.iloc[max_lookback:].copy()\n","            logger.info(f\"Dropped initial {max_lookback} rows with NaNs, final shape: {df.shape}\")\n","            return df\n","        except Exception as e: logger.error(f\"Indicator calculation failed: {str(e)}\", exc_info=True); raise\n","\n","\n","# --- Strategy Parameters ---\n","PARAMS: Dict[str, Dict[str, Any]] = {\n","    'backtest': { 'commission_pct': 0.0005, 'slippage_pct': 0.0002, 'filter_last_month': True },\n","    'core': { \"max_trade_duration\": 50, 'exit_score_drop_threshold': 1.5, 'use_score_drop_exit': True, 'entry_score_threshold': 6.0, 'use_fib_bounce_entry': True, 'use_fib_bounce_sell': True, 'fib_bounce_lookback': 3, 'fib_bounce_long_zone': (0.5, 0.618), 'fib_bounce_short_zone': (0.382, 0.5), 'fib_bounce_confirmation_level': 0.5, 'use_ema_bounce_buy': True, 'use_ema_bounce_sell': True, 'ema_bounce_lookback': 2, 'ema_bounce_source_str': \"Fast EMA\", 'use_bb_mid_bounce_buy': True, 'use_bb_mid_bounce_sell': True, 'bb_bounce_lookback': 2, 'use_vol_breakout_buy': True, 'use_vol_breakout_sell': True, 'trailing_stop_type': \"atr\", 'trailing_stop_pct': 0.02, 'trailing_stop_atr_multiplier': 1.5, 'profit_protection_levels': {'level1': {'profit_pct': 0.05, 'new_atr_mult': 1.0}, 'level2': {'profit_pct': 0.10, 'new_atr_mult': 0.5}}},\n","    'ema': { 'med_len': 14, 'use_ema_exit': True },\n","    'bollinger': { 'use_bb_return_exit': True },\n","    'rsi': { 'rsi_buy_level': 55.0, 'rsi_sell_level': 45.0, 'rsi_confirm_fib': True, 'rsi_confirm_ema': False, 'rsi_confirm_bb': False, 'rsi_confirm_level_buy': 40.0, 'rsi_confirm_level_sell': 60.0, 'use_rsi_div_exit': True },\n","    'macd': {},\n","    'volume': { 'vol_multiplier': 1.5, 'use_vol_fade_exit': True },\n","    'atr': { 'use_atr_stop': True },\n","    'fibonacci': { 'use_fib_exit': True, 'fib_lookback_exit': 30, 'fib_extension_level': 1.618, 'fib_pivot_lookback': 15, 'fib_max_bars': 200 },\n","    'trend': { 'use_ema_trend_filter': True, 'use_adx_filter': True, 'adx_threshold': 20.0, 'use_adx_direction_filter': True },\n","    'score_weights': { 'w_ema_trend': 2, 'w_ema_signal': 1, 'w_rsi_thresh': 1, 'w_macd_signal': 1, 'w_macd_zero': 1, 'w_vol_break': 1, 'w_adx_strength': 1, 'w_adx_direction': 1, 'w_fib_bounce': 2, 'w_ema_bounce': 1, 'w_bb_bounce': 1, }\n","}\n","\n","\n","# --- TradeState Class ---\n","class TradeState:\n","    def __init__(self): self.position = None; self.entry_price = None; self.entry_index = None; self.trailing_stop = None; self.highest_high_in_trade = None; self.lowest_low_in_trade = None; self.time_in_trade = 0\n","    def reset(self): self.__init__()\n","    def update_trailing_stop(self, current_low, current_high, current_close, atr):\n","        if self.position is None or atr is None or pd.isna(atr) or self.entry_price is None: return\n","        stop_type = PARAMS['core']['trailing_stop_type']; initial_atr_mult = PARAMS['core']['trailing_stop_atr_multiplier']; stop_pct = PARAMS['core']['trailing_stop_pct']; current_atr_mult = initial_atr_mult\n","        if self.position == 'Long':\n","            if self.highest_high_in_trade is None or current_high > self.highest_high_in_trade: self.highest_high_in_trade = current_high\n","            profit_pct = (current_close - self.entry_price) / self.entry_price if self.entry_price else 0\n","            for level_name, level_info in sorted(PARAMS['core']['profit_protection_levels'].items()):\n","                if profit_pct >= level_info['profit_pct']: current_atr_mult = level_info['new_atr_mult']\n","            if stop_type == \"percentage\": potential_stop = self.highest_high_in_trade * (1 - stop_pct) if self.highest_high_in_trade else None\n","            else: potential_stop = self.highest_high_in_trade - (atr * current_atr_mult) if self.highest_high_in_trade else None\n","            if potential_stop is not None and (self.trailing_stop is None or potential_stop > self.trailing_stop): self.trailing_stop = potential_stop\n","        elif self.position == 'Short':\n","            if self.lowest_low_in_trade is None or current_low < self.lowest_low_in_trade: self.lowest_low_in_trade = current_low\n","            profit_pct = (self.entry_price - current_close) / self.entry_price if self.entry_price else 0\n","            for level_name, level_info in sorted(PARAMS['core']['profit_protection_levels'].items()):\n","                 if profit_pct >= level_info['profit_pct']: current_atr_mult = level_info['new_atr_mult']\n","            if stop_type == \"percentage\": potential_stop = self.lowest_low_in_trade * (1 + stop_pct) if self.lowest_low_in_trade else None\n","            else: potential_stop = self.lowest_low_in_trade + (atr * current_atr_mult) if self.lowest_low_in_trade else None\n","            if potential_stop is not None and (self.trailing_stop is None or potential_stop < self.trailing_stop): self.trailing_stop = potential_stop\n","\n","\n","# --- Feature Calculation Functions ---\n","def calculate_fibonacci_levels(df: pd.DataFrame) -> pd.DataFrame:\n","    logger.debug(\"Calculating Fibonacci levels (strategy feature)\")\n","    try:\n","        lookback = PARAMS['fibonacci']['fib_pivot_lookback']; max_bars = PARAMS['fibonacci']['fib_max_bars']\n","        df['rolling_high'] = df['high'].rolling(window=2 * lookback + 1, center=True, min_periods=lookback//2+1).max()\n","        df['rolling_low'] = df['low'].rolling(window=2 * lookback + 1, center=True, min_periods=lookback//2+1).min()\n","        df['is_pivot_high'] = df['high'] == df['rolling_high']; df['is_pivot_low'] = df['low'] == df['rolling_low']\n","        df['last_pivot_high_price'] = df.loc[df['is_pivot_high'], 'high'].ffill().shift()\n","        df['last_pivot_high_idx'] = df.loc[df['is_pivot_high']].index.to_series().ffill().shift()\n","        df['last_pivot_low_price'] = df.loc[df['is_pivot_low'], 'low'].ffill().shift()\n","        df['last_pivot_low_idx'] = df.loc[df['is_pivot_low']].index.to_series().ffill().shift()\n","        current_bar_indices = np.arange(len(df))\n","        df['last_pivot_high_idx_num'] = df['last_pivot_high_idx'].apply(lambda x: df.index.get_loc(x) if pd.notna(x) and x in df.index else np.nan)\n","        df['last_pivot_low_idx_num'] = df['last_pivot_low_idx'].apply(lambda x: df.index.get_loc(x) if pd.notna(x) and x in df.index else np.nan)\n","        high_too_old = (current_bar_indices - df['last_pivot_high_idx_num']) > max_bars\n","        low_too_old = (current_bar_indices - df['last_pivot_low_idx_num']) > max_bars\n","        df.loc[high_too_old, ['last_pivot_high_price', 'last_pivot_high_idx', 'last_pivot_high_idx_num']] = np.nan\n","        df.loc[low_too_old, ['last_pivot_low_price', 'last_pivot_low_idx', 'last_pivot_low_idx_num']] = np.nan\n","        df['last_pivot_high_idx_num'] = df['last_pivot_high_idx_num'].fillna(-1)\n","        df['last_pivot_low_idx_num'] = df['last_pivot_low_idx_num'].fillna(-1)\n","        is_uptrend_fib = (df['last_pivot_high_idx_num'] > df['last_pivot_low_idx_num'])\n","        swing_high = np.where(is_uptrend_fib, df['last_pivot_high_price'], df['last_pivot_low_price'])\n","        swing_low = np.where(is_uptrend_fib, df['last_pivot_low_price'], df['last_pivot_high_price'])\n","        fib_range = swing_high - swing_low; fib_range[fib_range <= 0] = np.nan\n","        level_0 = np.where(is_uptrend_fib, swing_low, swing_high); level_100 = np.where(is_uptrend_fib, swing_high, swing_low)\n","        df['fib_0'] = level_0; df['fib_236'] = level_0 + fib_range * 0.236; df['fib_382'] = level_0 + fib_range * 0.382\n","        df['fib_500'] = level_0 + fib_range * 0.500; df['fib_618'] = level_0 + fib_range * 0.618; df['fib_786'] = level_0 + fib_range * 0.786\n","        df['fib_100'] = level_100; df['is_uptrend_fib'] = is_uptrend_fib\n","        df = df.drop(columns=[ 'rolling_high', 'rolling_low', 'is_pivot_high', 'is_pivot_low', 'last_pivot_high_price', 'last_pivot_high_idx', 'last_pivot_low_price', 'last_pivot_low_idx', 'last_pivot_high_idx_num', 'last_pivot_low_idx_num'], errors='ignore')\n","        return df\n","    except Exception as e: logger.error(f\"Error in calculate_fibonacci_levels: {str(e)}\", exc_info=True); raise\n","\n","def calculate_score(df: pd.DataFrame) -> Tuple[pd.DataFrame, float]:\n","    logger.debug(\"Calculating weighted trading score\")\n","    try:\n","        weights = PARAMS['score_weights']; total_possible_score = 0.0\n","        if PARAMS['trend']['use_ema_trend_filter']: total_possible_score += weights.get('w_ema_trend', 0)\n","        total_possible_score += weights.get('w_ema_signal', 0); total_possible_score += weights.get('w_rsi_thresh', 0)\n","        total_possible_score += weights.get('w_macd_signal', 0); total_possible_score += weights.get('w_macd_zero', 0)\n","        if PARAMS['core']['use_vol_breakout_buy'] or PARAMS['core']['use_vol_breakout_sell']: total_possible_score += weights.get('w_vol_break', 0)\n","        if PARAMS['trend']['use_adx_filter']: total_possible_score += weights.get('w_adx_strength', 0)\n","        if PARAMS['trend']['use_adx_direction_filter']: total_possible_score += weights.get('w_adx_direction', 0)\n","        if PARAMS['core']['use_fib_bounce_entry'] or PARAMS['core']['use_fib_bounce_sell']: total_possible_score += weights.get('w_fib_bounce', 0)\n","        if PARAMS['core']['use_ema_bounce_buy'] or PARAMS['core']['use_ema_bounce_sell']: total_possible_score += weights.get('w_ema_bounce', 0)\n","        if PARAMS['core']['use_bb_mid_bounce_buy'] or PARAMS['core']['use_bb_mid_bounce_sell']: total_possible_score += weights.get('w_bb_bounce', 0)\n","        total_possible_score = max(1.0, total_possible_score)\n","        df['cond_ema_trend_buy'] = df['ema_med'] > df['ema_slow']; df['cond_ema_trend_sell'] = df['ema_med'] < df['ema_slow']\n","        df['cond_ema_signal_buy'] = (df['ema_fast'] > df['ema_slow']) & (df['ema_fast'].shift() <= df['ema_slow'].shift()); df['cond_ema_signal_sell'] = (df['ema_fast'] < df['ema_slow']) & (df['ema_fast'].shift() >= df['ema_slow'].shift())\n","        df['cond_rsi_buy'] = df['rsi'] > PARAMS['rsi']['rsi_buy_level']; df['cond_rsi_sell'] = df['rsi'] < PARAMS['rsi']['rsi_sell_level']\n","        df['cond_macd_signal_buy'] = (df['macd'] > df['macd_signal']) & (df['macd'].shift() <= df['macd_signal'].shift()); df['cond_macd_signal_sell'] = (df['macd'] < df['macd_signal']) & (df['macd'].shift() >= df['macd_signal'].shift())\n","        df['cond_macd_zero_buy'] = (df['macd'] > 0) & (df['macd'].shift() <= 0); df['cond_macd_zero_sell'] = (df['macd'] < 0) & (df['macd'].shift() >= 0)\n","        df['cond_vol_break_buy'] = (df['volume'] > df['vol_ma'] * PARAMS['volume']['vol_multiplier']) & (df['close'] > df['open']); df['cond_vol_break_sell'] = (df['volume'] > df['vol_ma'] * PARAMS['volume']['vol_multiplier']) & (df['close'] < df['open'])\n","        df['cond_adx_strength'] = df['adx'] > PARAMS['trend']['adx_threshold']; df['cond_adx_dir_buy'] = df['plus_di'] > df['minus_di']; df['cond_adx_dir_sell'] = df['minus_di'] > df['plus_di']\n","        df['cond_fib_bounce_buy'] = False; df['cond_fib_bounce_sell'] = False; df['cond_ema_bounce_buy'] = False; df['cond_ema_bounce_sell'] = False; df['cond_bb_bounce_buy'] = False; df['cond_bb_bounce_sell'] = False\n","        buy_score = pd.Series(0.0, index=df.index); sell_score = pd.Series(0.0, index=df.index)\n","        if PARAMS['trend']['use_ema_trend_filter']: buy_score += df['cond_ema_trend_buy'] * weights.get('w_ema_trend', 0); sell_score += df['cond_ema_trend_sell'] * weights.get('w_ema_trend', 0)\n","        buy_score += df['cond_ema_signal_buy'] * weights.get('w_ema_signal', 0); sell_score += df['cond_ema_signal_sell'] * weights.get('w_ema_signal', 0)\n","        buy_score += df['cond_rsi_buy'] * weights.get('w_rsi_thresh', 0); sell_score += df['cond_rsi_sell'] * weights.get('w_rsi_thresh', 0)\n","        buy_score += df['cond_macd_signal_buy'] * weights.get('w_macd_signal', 0); sell_score += df['cond_macd_signal_sell'] * weights.get('w_macd_signal', 0)\n","        buy_score += df['cond_macd_zero_buy'] * weights.get('w_macd_zero', 0); sell_score += df['cond_macd_zero_sell'] * weights.get('w_macd_zero', 0)\n","        if PARAMS['core']['use_vol_breakout_buy'] or PARAMS['core']['use_vol_breakout_sell']: buy_score += df['cond_vol_break_buy'] * weights.get('w_vol_break', 0); sell_score += df['cond_vol_break_sell'] * weights.get('w_vol_break', 0)\n","        if PARAMS['trend']['use_adx_filter']: buy_score += (df['cond_adx_strength'] & df['cond_adx_dir_buy']) * weights.get('w_adx_strength', 0); sell_score += (df['cond_adx_strength'] & df['cond_adx_dir_sell']) * weights.get('w_adx_strength', 0)\n","        if PARAMS['trend']['use_adx_direction_filter']: buy_score += df['cond_adx_dir_buy'] * weights.get('w_adx_direction', 0); sell_score += df['cond_adx_dir_sell'] * weights.get('w_adx_direction', 0)\n","        df['buy_score_raw'] = buy_score; df['sell_score_raw'] = sell_score\n","        df['scaled_score'] = 5.0\n","        return df, total_possible_score\n","    except Exception as e: logger.error(f\"Error in calculate_score: {str(e)}\", exc_info=True); raise\n","\n","def calculate_rsi_divergence(df: pd.DataFrame) -> pd.DataFrame:\n","    logger.debug(f\"Calculating RSI divergence\")\n","    try:\n","        if 'rsi' not in df.columns: logger.error(\"RSI column missing\"); df['bullish_rsi_div'] = False; df['bearish_rsi_div'] = False; return df\n","        lookback = 14\n","        df['bullish_rsi_div'] = False; df['bearish_rsi_div'] = False\n","        df['price_low_roll'] = df['low'].rolling(window=lookback, closed='left').min()\n","        df['rsi_low_roll'] = df['rsi'].rolling(window=lookback, closed='left').min()\n","        df['price_high_roll'] = df['high'].rolling(window=lookback, closed='left').max()\n","        df['rsi_high_roll'] = df['rsi'].rolling(window=lookback, closed='left').max()\n","        df['bullish_rsi_div'] = (df['low'] < df['price_low_roll']) & (df['rsi'] > df['rsi_low_roll'])\n","        df['bearish_rsi_div'] = (df['high'] > df['price_high_roll']) & (df['rsi'] < df['rsi_high_roll'])\n","        df = df.drop(columns=['price_low_roll', 'rsi_low_roll', 'price_high_roll', 'rsi_high_roll'], errors='ignore')\n","        return df\n","    except Exception as e: logger.error(f\"Error in calculate_rsi_divergence: {str(e)}\", exc_info=True); raise\n","\n","def calculate_targets_for_trade(df: pd.DataFrame, entry_idx: int, position: str, entry_price: float, initial_stop: float) -> pd.DataFrame:\n","    try:\n","        current_idx = df.index[entry_idx]\n","        if 'atr' not in df.columns: logger.warning(f\"ATR missing, cannot calc targets for trade {entry_idx}.\"); return df\n","        atr = df.loc[current_idx, 'atr']\n","        fib_lookback = PARAMS['fibonacci']['fib_lookback_exit']; fib_ext_level = PARAMS['fibonacci']['fib_extension_level']; use_fib_target = PARAMS['fibonacci']['use_fib_exit']; atr_mult_target = PARAMS['atr'].get('atr_mult', 2.0)\n","        if pd.isna(atr) or pd.isna(entry_price) or pd.isna(initial_stop): logger.warning(f\"NaN inputs for target calc at {entry_idx}.\"); return df\n","        target_price_long_col = df['target_price_long'].copy(); target_price_short_col = df['target_price_short'].copy(); fib_target_long_col = df['fib_target_long'].copy(); fib_target_short_col = df['fib_target_short'].copy()\n","        if position == 'Long':\n","            atr_target = entry_price + (atr * atr_mult_target); risk = entry_price - initial_stop; rr_target = entry_price + (risk * 2) if risk > 0 else np.nan; fib_target = np.nan\n","            if use_fib_target:\n","                lookback_start = max(0, entry_idx - fib_lookback); swing_low_series = df['low'].iloc[lookback_start : entry_idx]\n","                if not swing_low_series.empty: swing_low_price = swing_low_series.min(); swing_range = entry_price - swing_low_price;\n","                if swing_range > 0: fib_target = entry_price + (swing_range * fib_ext_level)\n","            fib_target_long_col.loc[current_idx:] = fib_target; valid_targets = [t for t in [atr_target, rr_target, fib_target] if pd.notna(t)];\n","            if valid_targets: target_price_long_col.loc[current_idx:] = min(valid_targets)\n","        elif position == 'Short':\n","            atr_target = entry_price - (atr * atr_mult_target); risk = initial_stop - entry_price; rr_target = entry_price - (risk * 2) if risk > 0 else np.nan; fib_target = np.nan\n","            if use_fib_target:\n","                lookback_start = max(0, entry_idx - fib_lookback); swing_high_series = df['high'].iloc[lookback_start : entry_idx]\n","                if not swing_high_series.empty: swing_high_price = swing_high_series.max(); swing_range = swing_high_price - entry_price;\n","                if swing_range > 0: fib_target = entry_price - (swing_range * fib_ext_level)\n","            fib_target_short_col.loc[current_idx:] = fib_target; valid_targets = [t for t in [atr_target, rr_target, fib_target] if pd.notna(t)];\n","            if valid_targets: target_price_short_col.loc[current_idx:] = max(valid_targets)\n","        df['target_price_long'] = target_price_long_col; df['target_price_short'] = target_price_short_col; df['fib_target_long'] = fib_target_long_col; df['fib_target_short'] = fib_target_short_col\n","        return df\n","    except Exception as e: logger.error(f\"Error calculating targets for trade at index {entry_idx}: {str(e)}\", exc_info=True); return df\n","\n","# --- Main Signal Processing Function ---\n","def process_signals(df: pd.DataFrame) -> pd.DataFrame:\n","    logger.info(\"Starting signal processing using calculated indicators\")\n","    try:\n","        required_internal_cols = ['open', 'high', 'low', 'close', 'volume', 'atr', 'rsi', 'macd', 'macd_signal', 'macd_hist', 'ema_fast', 'ema_med', 'ema_slow', 'bb_middle', 'bb_upper', 'bb_lower', 'vol_ma', 'adx', 'plus_di', 'minus_di']\n","        missing_cols = [col for col in required_internal_cols if col not in df.columns]\n","        if missing_cols: raise ValueError(f\"DataFrame missing required columns for signal processing: {missing_cols}\")\n","\n","        df = calculate_fibonacci_levels(df)\n","        df, total_possible_score = calculate_score(df)\n","        df = calculate_rsi_divergence(df)\n","\n","        df['signal'] = 'Hold'; df['position'] = ''; df['entry_price'] = np.nan; df['stop_loss'] = np.nan; df['trailing_stop'] = np.nan; df['exit_price'] = np.nan; df['exit_reason'] = ''; df['entry_signal_type'] = ''; df['target_price_long'] = np.nan; df['target_price_short'] = np.nan; df['fib_target_long'] = np.nan; df['fib_target_short'] = np.nan\n","\n","        start_index = max( (PARAMS['fibonacci']['fib_pivot_lookback'] * 2 + 1), PARAMS['fibonacci']['fib_lookback_exit'], PARAMS['core']['fib_bounce_lookback'], PARAMS['core']['ema_bounce_lookback'], PARAMS['core']['bb_bounce_lookback'], 5 ) + 1\n","        if start_index >= len(df): logger.warning(f\"Not enough data. Required: {start_index}, Available: {len(df)}\"); return df\n","\n","        logger.info(f\"Starting main processing loop from index {start_index}\")\n","        trade_state = TradeState(); weights = PARAMS['score_weights']\n","\n","        for i in range(start_index, len(df)):\n","            current_idx = df.index[i]; prev_idx = df.index[i-1]; current = df.iloc[i]; prev = df.iloc[i-1]\n","            exit_triggered_this_bar = False; exit_price_this_bar = np.nan; exit_reason = ''\n","\n","            # --- I. Check for Exits ---\n","            if trade_state.position is not None:\n","                trade_state.time_in_trade += 1; trade_state.update_trailing_stop(current['low'], current['high'], current['close'], current['atr']); df.loc[current_idx, 'trailing_stop'] = trade_state.trailing_stop; potential_exit_price = current['close']\n","                if PARAMS['atr']['use_atr_stop'] and trade_state.trailing_stop is not None:\n","                    if trade_state.position == 'Long' and current['low'] <= trade_state.trailing_stop: exit_reason='Trailing Stop'; exit_price_this_bar = min(current['open'], trade_state.trailing_stop); exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and current['high'] >= trade_state.trailing_stop: exit_reason='Trailing Stop'; exit_price_this_bar = max(current['open'], trade_state.trailing_stop); exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['rsi']['use_rsi_div_exit']:\n","                    if trade_state.position == 'Long' and current['bearish_rsi_div']: exit_reason='RSI Div'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and current['bullish_rsi_div']: exit_reason='RSI Div'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['fibonacci']['use_fib_exit']:\n","                    fib_target_long = df.loc[current_idx, 'fib_target_long']; fib_target_short = df.loc[current_idx, 'fib_target_short']\n","                    if trade_state.position == 'Long' and pd.notna(fib_target_long) and current['high'] >= fib_target_long: exit_reason='Fib Target'; exit_price_this_bar = max(current['open'], fib_target_long); exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and pd.notna(fib_target_short) and current['low'] <= fib_target_short: exit_reason='Fib Target'; exit_price_this_bar = min(current['open'], fib_target_short); exit_triggered_this_bar = True\n","                buy_score_bar_exit = df.loc[current_idx, 'buy_score_raw']; sell_score_bar_exit = df.loc[current_idx, 'sell_score_raw']\n","                if df.loc[current_idx, 'cond_fib_bounce_buy']: buy_score_bar_exit += weights.get('w_fib_bounce', 0)\n","                if df.loc[current_idx, 'cond_fib_bounce_sell']: sell_score_bar_exit += weights.get('w_fib_bounce', 0)\n","                if df.loc[current_idx, 'cond_ema_bounce_buy']: buy_score_bar_exit += weights.get('w_ema_bounce', 0)\n","                if df.loc[current_idx, 'cond_ema_bounce_sell']: sell_score_bar_exit += weights.get('w_ema_bounce', 0)\n","                if df.loc[current_idx, 'cond_bb_bounce_buy']: buy_score_bar_exit += weights.get('w_bb_bounce', 0)\n","                if df.loc[current_idx, 'cond_bb_bounce_sell']: sell_score_bar_exit += weights.get('w_bb_bounce', 0)\n","                net_score_bar_exit = buy_score_bar_exit - sell_score_bar_exit; scaled_score_bar_exit = max(0.0, min(10.0, ((net_score_bar_exit / total_possible_score) * 5.0) + 5.0)); df.loc[current_idx, 'scaled_score'] = scaled_score_bar_exit\n","                if not exit_triggered_this_bar and PARAMS['core']['use_score_drop_exit']:\n","                    score_threshold = PARAMS['core']['exit_score_drop_threshold']\n","                    if trade_state.position == 'Long' and scaled_score_bar_exit < (5.0 - score_threshold): exit_reason=f'Score Drop ({scaled_score_bar_exit:.1f})'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and scaled_score_bar_exit > (5.0 + score_threshold): exit_reason=f'Score Drop ({scaled_score_bar_exit:.1f})'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['ema']['use_ema_exit']:\n","                    fast_ema_cross_med_sell = current['ema_fast'] < current['ema_med'] and prev['ema_fast'] >= prev['ema_med']; fast_ema_cross_med_buy = current['ema_fast'] > current['ema_med'] and prev['ema_fast'] <= prev['ema_med']\n","                    if trade_state.position == 'Long' and fast_ema_cross_med_sell: exit_reason='EMA Cross'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and fast_ema_cross_med_buy: exit_reason='EMA Cross'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['bollinger']['use_bb_return_exit']:\n","                    cross_under_bb_mid = current['close'] < current['bb_middle'] and prev['close'] >= prev['bb_middle']; cross_over_bb_mid = current['close'] > current['bb_middle'] and prev['close'] <= prev['bb_middle']\n","                    if trade_state.position == 'Long' and cross_under_bb_mid: exit_reason='BB Mid Exit'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and cross_over_bb_mid: exit_reason='BB Mid Exit'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and PARAMS['volume']['use_vol_fade_exit']:\n","                    low_vol = current['volume'] < df.loc[prev_idx, 'vol_ma']; pullback_long = current['close'] < current['ema_fast']; pullback_short = current['close'] > current['ema_fast']\n","                    if trade_state.position == 'Long' and low_vol and pullback_long: exit_reason='Vol Fade'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                    elif trade_state.position == 'Short' and low_vol and pullback_short: exit_reason='Vol Fade'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if not exit_triggered_this_bar and trade_state.time_in_trade >= PARAMS['core']['max_trade_duration']: exit_reason='Time Exit'; exit_price_this_bar = potential_exit_price; exit_triggered_this_bar = True\n","                if exit_triggered_this_bar: signal_prefix = 'Exit Long' if trade_state.position == 'Long' else 'Exit Short'; df.loc[current_idx, 'signal'] = signal_prefix; df.loc[current_idx, 'exit_reason'] = exit_reason; df.loc[current_idx, 'exit_price'] = exit_price_this_bar; trade_state.reset(); df.loc[current_idx:, ['target_price_long', 'target_price_short', 'fib_target_long', 'fib_target_short']] = np.nan\n","\n","            # --- II. Check for Entries ---\n","            if trade_state.position is None and not exit_triggered_this_bar:\n","                entry_signal = None; buy_score_bar = df.loc[current_idx, 'buy_score_raw']; sell_score_bar = df.loc[current_idx, 'sell_score_raw']\n","                df.loc[current_idx, ['cond_fib_bounce_buy', 'cond_fib_bounce_sell','cond_ema_bounce_buy', 'cond_ema_bounce_sell','cond_bb_bounce_buy', 'cond_bb_bounce_sell']] = False\n","                fib_bounce_buy_cond = False; fib_bounce_sell_cond = False\n","                if PARAMS['core']['use_fib_bounce_entry'] or PARAMS['core']['use_fib_bounce_sell']:\n","                    lookback=PARAMS['core']['fib_bounce_lookback']; low_zone_long, high_zone_long = PARAMS['core']['fib_bounce_long_zone']; low_zone_short, high_zone_short = PARAMS['core']['fib_bounce_short_zone']; conf_level = PARAMS['core']['fib_bounce_confirmation_level']; rsi_conf = PARAMS['rsi']['rsi_confirm_fib']; rsi_buy_lvl, rsi_sell_lvl = PARAMS['rsi']['rsi_confirm_level_buy'], PARAMS['rsi']['rsi_confirm_level_sell']\n","                    if PARAMS['core']['use_fib_bounce_entry'] and current['is_uptrend_fib']:\n","                        fib_low_name = f'fib_{int(low_zone_long*1000)}'; fib_high_name = f'fib_{int(high_zone_long*1000)}'; fib_conf_name = f'fib_{int(conf_level*1000)}'\n","                        if fib_low_name in df.columns and fib_high_name in df.columns and fib_conf_name in df.columns:\n","                            fib_low = current[fib_low_name]; fib_high = current[fib_high_name]; fib_conf = current[fib_conf_name]\n","                            if pd.notna(fib_low) and pd.notna(fib_high) and pd.notna(fib_conf):\n","                                touched_zone = (df['low'].iloc[i-lookback:i] <= fib_high).any(); bounced_above = current['close'] > fib_conf; rsi_ok = not rsi_conf or (current['rsi'] > rsi_buy_lvl and current['rsi'] > prev['rsi'])\n","                                if touched_zone and bounced_above and rsi_ok: fib_bounce_buy_cond = True; df.loc[current_idx, 'cond_fib_bounce_buy'] = True; buy_score_bar += weights.get('w_fib_bounce', 0)\n","                    if PARAMS['core']['use_fib_bounce_sell'] and not current['is_uptrend_fib']:\n","                        fib_low_name = f'fib_{int(low_zone_short*1000)}'; fib_high_name = f'fib_{int(high_zone_short*1000)}'; fib_conf_name = f'fib_{int(conf_level*1000)}'\n","                        if fib_low_name in df.columns and fib_high_name in df.columns and fib_conf_name in df.columns:\n","                            fib_low = current[fib_low_name]; fib_high = current[fib_high_name]; fib_conf = current[fib_conf_name]\n","                            if pd.notna(fib_low) and pd.notna(fib_high) and pd.notna(fib_conf):\n","                                touched_zone = (df['high'].iloc[i-lookback:i] >= fib_low).any(); bounced_below = current['close'] < fib_conf; rsi_ok = not rsi_conf or (current['rsi'] < rsi_sell_lvl and current['rsi'] < prev['rsi'])\n","                                if touched_zone and bounced_below and rsi_ok: fib_bounce_sell_cond = True; df.loc[current_idx, 'cond_fib_bounce_sell'] = True; sell_score_bar += weights.get('w_fib_bounce', 0)\n","                ema_bounce_buy_cond = False; ema_bounce_sell_cond = False\n","                if PARAMS['core']['use_ema_bounce_buy'] or PARAMS['core']['use_ema_bounce_sell']:\n","                    lookback=PARAMS['core']['ema_bounce_lookback']; ema_source_col = 'ema_fast'; ema_source = df[ema_source_col]; rsi_conf = PARAMS['rsi']['rsi_confirm_ema']; rsi_buy_lvl, rsi_sell_lvl = PARAMS['rsi']['rsi_confirm_level_buy'], PARAMS['rsi']['rsi_confirm_level_sell']\n","                    if PARAMS['core']['use_ema_bounce_buy']:\n","                         touched_ema = (df['low'].iloc[i-lookback:i] <= ema_source.iloc[i-lookback:i]).any(); bounced_above = current['close'] > current[ema_source_col] and current['close'] > current['open']; rsi_ok = not rsi_conf or (current['rsi'] > rsi_buy_lvl and current['rsi'] > prev['rsi'])\n","                         if touched_ema and bounced_above and rsi_ok: ema_bounce_buy_cond = True; df.loc[current_idx, 'cond_ema_bounce_buy'] = True; buy_score_bar += weights.get('w_ema_bounce', 0)\n","                    if PARAMS['core']['use_ema_bounce_sell']:\n","                        touched_ema = (df['high'].iloc[i-lookback:i] >= ema_source.iloc[i-lookback:i]).any(); bounced_below = current['close'] < current[ema_source_col] and current['close'] < current['open']; rsi_ok = not rsi_conf or (current['rsi'] < rsi_sell_lvl and current['rsi'] < prev['rsi'])\n","                        if touched_ema and bounced_below and rsi_ok: ema_bounce_sell_cond = True; df.loc[current_idx, 'cond_ema_bounce_sell'] = True; sell_score_bar += weights.get('w_ema_bounce', 0)\n","                bb_bounce_buy_cond = False; bb_bounce_sell_cond = False\n","                if PARAMS['core']['use_bb_mid_bounce_buy'] or PARAMS['core']['use_bb_mid_bounce_sell']:\n","                    lookback=PARAMS['core']['bb_bounce_lookback']; bb_mid = df['bb_middle']; rsi_conf = PARAMS['rsi']['rsi_confirm_bb']; rsi_buy_lvl, rsi_sell_lvl = PARAMS['rsi']['rsi_confirm_level_buy'], PARAMS['rsi']['rsi_confirm_level_sell']\n","                    if PARAMS['core']['use_bb_mid_bounce_buy']:\n","                        touched_bb = (df['low'].iloc[i-lookback:i] <= bb_mid.iloc[i-lookback:i]).any(); bounced_above = current['close'] > current['bb_middle'] and current['close'] > current['open']; rsi_ok = not rsi_conf or (current['rsi'] > rsi_buy_lvl and current['rsi'] > prev['rsi'])\n","                        if touched_bb and bounced_above and rsi_ok: bb_bounce_buy_cond = True; df.loc[current_idx, 'cond_bb_bounce_buy'] = True; buy_score_bar += weights.get('w_bb_bounce', 0)\n","                    if PARAMS['core']['use_bb_mid_bounce_sell']:\n","                        touched_bb = (df['high'].iloc[i-lookback:i] >= bb_mid.iloc[i-lookback:i]).any(); bounced_below = current['close'] < current['bb_middle'] and current['close'] < current['open']; rsi_ok = not rsi_conf or (current['rsi'] < rsi_sell_lvl and current['rsi'] < prev['rsi'])\n","                        if touched_bb and bounced_below and rsi_ok: bb_bounce_sell_cond = True; df.loc[current_idx, 'cond_bb_bounce_sell'] = True; sell_score_bar += weights.get('w_bb_bounce', 0)\n","                vol_breakout_buy_cond = False; vol_breakout_sell_cond = False\n","                if PARAMS['core']['use_vol_breakout_buy'] or PARAMS['core']['use_vol_breakout_sell']:\n","                    high_vol = current['volume'] > current['vol_ma'] * PARAMS['volume']['vol_multiplier']; lookback_pa = 5\n","                    if i >= lookback_pa: recent_high = df['high'].iloc[i-lookback_pa:i].max(); recent_low = df['low'].iloc[i-lookback_pa:i].min()\n","                    else: recent_high = np.nan; recent_low = np.nan\n","                    if pd.notna(recent_high) and PARAMS['core']['use_vol_breakout_buy'] and high_vol and current['close'] > current['open'] and current['close'] > recent_high: vol_breakout_buy_cond = True\n","                    if pd.notna(recent_low) and PARAMS['core']['use_vol_breakout_sell'] and high_vol and current['close'] < current['open'] and current['close'] < recent_low: vol_breakout_sell_cond = True\n","\n","                net_score_bar = buy_score_bar - sell_score_bar; scaled_score_bar = max(0.0, min(10.0, ((net_score_bar / total_possible_score) * 5.0) + 5.0)); df.loc[current_idx, 'scaled_score'] = scaled_score_bar\n","                trend_ok_buy = True; trend_ok_sell = True\n","                if PARAMS['trend']['use_ema_trend_filter']: trend_ok_buy &= current['cond_ema_trend_buy']; trend_ok_sell &= current['cond_ema_trend_sell']\n","                if PARAMS['trend']['use_adx_filter']: trend_ok_buy &= current['cond_adx_strength']; trend_ok_sell &= current['cond_adx_strength']\n","                if PARAMS['trend']['use_adx_direction_filter']: trend_ok_buy &= current['cond_adx_dir_buy']; trend_ok_sell &= current['cond_adx_dir_sell']\n","                entry_score_threshold = PARAMS['core']['entry_score_threshold']\n","                if trend_ok_buy and scaled_score_bar >= entry_score_threshold:\n","                    if fib_bounce_buy_cond: entry_signal = \"Fib Bounce Long\"\n","                    elif ema_bounce_buy_cond: entry_signal = \"EMA Bounce Long\"\n","                    elif bb_bounce_buy_cond: entry_signal = \"BB Bounce Long\"\n","                    elif vol_breakout_buy_cond: entry_signal = \"Vol Breakout Long\"\n","                    elif df.loc[current_idx,'cond_ema_signal_buy'] and df.loc[current_idx,'cond_rsi_buy']: entry_signal = \"Basic Long\"\n","                elif trend_ok_sell and scaled_score_bar <= (10.0 - entry_score_threshold):\n","                    if fib_bounce_sell_cond: entry_signal = \"Fib Bounce Short\"\n","                    elif ema_bounce_sell_cond: entry_signal = \"EMA Bounce Short\"\n","                    elif bb_bounce_sell_cond: entry_signal = \"BB Bounce Short\"\n","                    elif vol_breakout_sell_cond: entry_signal = \"Vol Breakout Short\"\n","                    elif df.loc[current_idx,'cond_ema_signal_sell'] and df.loc[current_idx,'cond_rsi_sell']: entry_signal = \"Basic Short\"\n","\n","                if entry_signal:\n","                    entry_price_adj = current['close'] * (1 + PARAMS['backtest']['slippage_pct']) if \"Long\" in entry_signal else current['close'] * (1 - PARAMS['backtest']['slippage_pct'])\n","                    trade_state.entry_price = entry_price_adj; trade_state.entry_index = i; trade_state.time_in_trade = 0\n","                    if \"Long\" in entry_signal:\n","                        trade_state.position = 'Long'; trade_state.highest_high_in_trade = current['high']\n","                        initial_stop = current['low'] - current['atr'] * PARAMS['core']['trailing_stop_atr_multiplier']\n","                        trade_state.trailing_stop = initial_stop; df.loc[current_idx, 'signal'] = 'Long'; df.loc[current_idx, 'stop_loss'] = initial_stop\n","                    elif \"Short\" in entry_signal:\n","                        trade_state.position = 'Short'; trade_state.lowest_low_in_trade = current['low']\n","                        initial_stop = current['high'] + current['atr'] * PARAMS['core']['trailing_stop_atr_multiplier']\n","                        trade_state.trailing_stop = initial_stop; df.loc[current_idx, 'signal'] = 'Short'; df.loc[current_idx, 'stop_loss'] = initial_stop\n","                    df.loc[current_idx, 'position'] = trade_state.position; df.loc[current_idx, 'entry_price'] = trade_state.entry_price\n","                    df.loc[current_idx, 'entry_signal_type'] = entry_signal; df.loc[current_idx, 'trailing_stop'] = trade_state.trailing_stop\n","                    df = calculate_targets_for_trade(df, i, trade_state.position, trade_state.entry_price, initial_stop)\n","\n","            # --- III. Update Position State ---\n","            if trade_state.position is not None and df.loc[current_idx, 'signal'] == 'Hold':\n","                df.loc[current_idx, 'position'] = trade_state.position\n","                df.loc[current_idx, 'entry_price'] = trade_state.entry_price\n","\n","        logger.info(\"Finished main processing loop\")\n","        return df\n","    except Exception as e: logger.error(f\"Error in process_signals: {str(e)}\", exc_info=True); raise\n","\n","# --- EnhancedSignalAnalyzer Class ---\n","class EnhancedSignalAnalyzer:\n","    def __init__(self):\n","        self.trade_history = []\n","        self.summary_stats = defaultdict(float)\n","        self.entry_stats = defaultdict(lambda: defaultdict(float))\n","        self.exit_stats = defaultdict(lambda: defaultdict(float))\n","        self.signal_stats = defaultdict(lambda: defaultdict(float))\n","\n","    def analyze_trades(self, df: pd.DataFrame):\n","        logger.info(\"Analyzing generated trades for detailed statistics\")\n","        try:\n","            self.trade_history = []\n","            current_trade = None\n","            running_pnl = 0.0; peak_pnl = 0.0; max_drawdown = 0.0\n","            win_pnls = []; loss_pnls = []\n","            win_durations = []; loss_durations = []\n","            risk_rewards = []\n","            current_streak = 0; max_consec_wins = 0; max_consec_losses = 0\n","            current_streak_type = None\n","\n","            for i in range(len(df)):\n","                current_idx = df.index[i]\n","                signal = df.loc[current_idx, 'signal']\n","\n","                if signal in ['Long', 'Short'] and current_trade is None:\n","                    entry_price = df.loc[current_idx, 'entry_price']\n","                    stop_loss = df.loc[current_idx, 'stop_loss']\n","                    target_price_col = 'target_price_long' if signal == 'Long' else 'target_price_short'\n","                    target_price = df.loc[current_idx, target_price_col]\n","                    if pd.notna(entry_price) and pd.notna(stop_loss):\n","                        current_trade = {'entry_index': i, 'entry_idx_time': current_idx, 'entry_price': entry_price, 'position': signal, 'stop_loss': stop_loss, 'target_price': target_price, 'signal_type': df.loc[current_idx, 'entry_signal_type']}\n","                        if current_trade['position'] == 'Long': risk = current_trade['entry_price'] - current_trade['stop_loss']; reward = current_trade['target_price'] - current_trade['entry_price'] if pd.notna(current_trade['target_price']) else np.nan\n","                        else: risk = current_trade['stop_loss'] - current_trade['entry_price']; reward = current_trade['entry_price'] - current_trade['target_price'] if pd.notna(current_trade['target_price']) else np.nan\n","                        current_trade['risk_at_entry'] = risk; current_trade['reward_at_entry'] = reward\n","                        current_trade['risk_reward_ratio'] = reward / risk if risk > 0 and pd.notna(reward) else np.nan\n","\n","                elif current_trade and 'Exit' in signal:\n","                    exit_price = df.loc[current_idx, 'exit_price']\n","                    if pd.isna(exit_price): exit_price = df.loc[current_idx, 'close']; logger.warning(f\"Exit price NaN for trade entered on {current_trade['entry_idx_time'].date()}, using close price {exit_price:.2f}\")\n","                    exit_idx_time = current_idx; exit_reason = df.loc[current_idx, 'exit_reason']\n","                    if current_trade['position'] == 'Long': pnl_points = exit_price - current_trade['entry_price']\n","                    else: pnl_points = current_trade['entry_price'] - exit_price\n","                    commission = (current_trade['entry_price'] + exit_price) * PARAMS['backtest']['commission_pct']\n","                    net_pnl_points = pnl_points - commission\n","                    pct_change = (net_pnl_points / current_trade['entry_price']) * 100 if current_trade['entry_price'] else 0\n","                    duration_delta = exit_idx_time - current_trade['entry_idx_time']; duration_bars = i - current_trade['entry_index']\n","                    outcome = 'Win' if net_pnl_points > 0 else 'Loss'\n","                    trade_record = {**current_trade, 'exit_idx_time': exit_idx_time, 'exit_price': exit_price, 'pnl_points': net_pnl_points, 'pct_change': pct_change, 'duration_delta': duration_delta, 'duration_bars': duration_bars, 'outcome': outcome, 'exit_reason': exit_reason}\n","                    self.trade_history.append(trade_record)\n","                    self.summary_stats['total_trades'] += 1; self.summary_stats['total_pnl'] += net_pnl_points\n","                    if outcome == 'Win': self.summary_stats['winning_trades'] += 1; win_pnls.append(net_pnl_points); win_durations.append(duration_bars)\n","                    else: self.summary_stats['losing_trades'] += 1; loss_pnls.append(abs(net_pnl_points)); loss_durations.append(duration_bars)\n","                    if pd.notna(current_trade['risk_reward_ratio']): risk_rewards.append(current_trade['risk_reward_ratio'])\n","                    if outcome == current_streak_type: current_streak += 1\n","                    else: current_streak = 1; current_streak_type = outcome\n","                    if outcome == 'Win': max_consec_wins = max(max_consec_wins, current_streak)\n","                    else: max_consec_losses = max(max_consec_losses, current_streak)\n","                    running_pnl += net_pnl_points; peak_pnl = max(peak_pnl, running_pnl); drawdown = peak_pnl - running_pnl\n","                    self.summary_stats['max_drawdown_points'] = max(self.summary_stats.get('max_drawdown_points', 0.0), drawdown)\n","                    pos = current_trade['position']; sig_type = current_trade['signal_type']; exit_type = exit_reason\n","                    self.entry_stats[pos]['total'] += 1; self.entry_stats[pos]['total_pnl'] += net_pnl_points; self.entry_stats[pos]['total_duration_bars'] += duration_bars\n","                    if outcome == 'Win': self.entry_stats[pos]['success'] += 1\n","                    if exit_type == 'Trailing Stop' or exit_type == 'ATR Stop': self.entry_stats[pos]['sl_hit'] += 1\n","                    if exit_type == 'Fib Target' or exit_type == 'Target': self.entry_stats[pos]['target_hit'] += 1\n","                    self.exit_stats[exit_type]['total'] += 1; self.exit_stats[exit_type]['total_pnl'] += net_pnl_points; self.exit_stats[exit_type]['total_duration_bars'] += duration_bars\n","                    if outcome == 'Win': self.exit_stats[exit_type]['success'] += 1\n","                    self.signal_stats[sig_type]['total'] += 1; self.signal_stats[sig_type]['total_pnl'] += net_pnl_points\n","                    if outcome == 'Win': self.signal_stats[sig_type]['success'] += 1\n","                    current_trade = None\n","\n","            if self.summary_stats['total_trades'] > 0:\n","                avg_win = np.mean(win_pnls) if win_pnls else 0; avg_loss = np.mean(loss_pnls) if loss_pnls else 0\n","                self.summary_stats['win_rate'] = (self.summary_stats['winning_trades'] / self.summary_stats['total_trades']) * 100\n","                self.summary_stats['avg_win_points'] = avg_win; self.summary_stats['avg_loss_points'] = avg_loss\n","                self.summary_stats['profit_factor'] = abs(sum(win_pnls) / sum(loss_pnls)) if sum(loss_pnls) != 0 else np.inf\n","                self.summary_stats['expectancy_points'] = (avg_win * (self.summary_stats['win_rate']/100)) - (avg_loss * (1 - self.summary_stats['win_rate']/100))\n","                self.summary_stats['max_consec_wins'] = max_consec_wins; self.summary_stats['max_consec_losses'] = max_consec_losses\n","                self.summary_stats['avg_win_duration_bars'] = np.mean(win_durations) if win_durations else 0\n","                self.summary_stats['avg_loss_duration_bars'] = np.mean(loss_durations) if loss_durations else 0\n","                self.summary_stats['avg_risk_reward_ratio'] = np.nanmean(risk_rewards) if risk_rewards else np.nan\n","                health_score = min(100, max(0, (self.summary_stats['win_rate'] * 0.4) + (min(self.summary_stats['profit_factor'], 5) * 10 if pd.notna(self.summary_stats['profit_factor']) else 0) + (1 - (self.summary_stats['avg_loss_duration_bars']/self.summary_stats['avg_win_duration_bars'] if self.summary_stats['avg_win_duration_bars'] > 0 else 1) * 20) + (self.summary_stats['avg_risk_reward_ratio'] * 10 if pd.notna(self.summary_stats['avg_risk_reward_ratio']) else 0) ))\n","                self.summary_stats['health_score'] = health_score\n","\n","            for pos in list(self.entry_stats.keys()):\n","                if self.entry_stats[pos]['total'] > 0: self.entry_stats[pos]['avg_pnl'] = self.entry_stats[pos]['total_pnl'] / self.entry_stats[pos]['total']; self.entry_stats[pos]['avg_duration_bars'] = self.entry_stats[pos]['total_duration_bars'] / self.entry_stats[pos]['total']; self.entry_stats[pos]['win_rate'] = (self.entry_stats[pos]['success'] / self.entry_stats[pos]['total']) * 100; self.entry_stats[pos]['sl_rate'] = (self.entry_stats[pos]['sl_hit'] / self.entry_stats[pos]['total']) * 100; self.entry_stats[pos]['target_rate'] = (self.entry_stats[pos]['target_hit'] / self.entry_stats[pos]['total']) * 100\n","            for exit_type in list(self.exit_stats.keys()):\n","                 if self.exit_stats[exit_type]['total'] > 0: self.exit_stats[exit_type]['avg_pnl'] = self.exit_stats[exit_type]['total_pnl'] / self.exit_stats[exit_type]['total']; self.exit_stats[exit_type]['avg_duration_bars'] = self.exit_stats[exit_type]['total_duration_bars'] / self.exit_stats[exit_type]['total']; self.exit_stats[exit_type]['win_rate'] = (self.exit_stats[exit_type]['success'] / self.exit_stats[exit_type]['total']) * 100\n","            for sig_type in list(self.signal_stats.keys()):\n","                 if self.signal_stats[sig_type]['total'] > 0: self.signal_stats[sig_type]['avg_pnl'] = self.signal_stats[sig_type]['total_pnl'] / self.signal_stats[sig_type]['total']; self.signal_stats[sig_type]['win_rate'] = (self.signal_stats[sig_type]['success'] / self.signal_stats[sig_type]['total']) * 100\n","\n","            logger.info(\"Finished analyzing trades.\")\n","            return df\n","        except Exception as e:\n","            logger.error(f\"Error in analyze_trades: {str(e)}\", exc_info=True)\n","            raise\n","\n","    def print_summary(self):\n","        if not self.summary_stats or self.summary_stats['total_trades'] == 0:\n","             print(\"\\nNo trades to summarize.\")\n","             logger.info(\"No trades to summarize.\")\n","             return\n","        try:\n","            summary = [ f\"\\n=== ENHANCED TRADE SUMMARY ===\", f\"Total Trades: {int(self.summary_stats['total_trades'])}\", f\"Winning Trades: {int(self.summary_stats['winning_trades'])} ({self.summary_stats['win_rate']:.1f}%)\", f\"Losing Trades: {int(self.summary_stats['losing_trades'])}\", f\"Total P&L (Points): {self.summary_stats['total_pnl']:.2f}\", f\"Profit Factor: {self.summary_stats['profit_factor']:.2f}\", f\"Expectancy (Points): {self.summary_stats['expectancy_points']:.2f}\", f\"Max Drawdown (Points): {self.summary_stats['max_drawdown_points']:.2f}\", f\"Avg Win / Avg Loss (Points): {self.summary_stats['avg_win_points']:.2f} / {self.summary_stats['avg_loss_points']:.2f}\", f\"Max Consecutive Wins: {int(self.summary_stats['max_consec_wins'])}\", f\"Max Consecutive Losses: {int(self.summary_stats['max_consec_losses'])}\", f\"Avg Win Duration (Bars): {self.summary_stats['avg_win_duration_bars']:.1f}\", f\"Avg Loss Duration (Bars): {self.summary_stats['avg_loss_duration_bars']:.1f}\", f\"Avg Risk/Reward Ratio (at Entry): {self.summary_stats['avg_risk_reward_ratio']:.2f}:1\" if pd.notna(self.summary_stats['avg_risk_reward_ratio']) else \"N/A\", f\"Strategy Health Score: {self.summary_stats['health_score']:.1f}/100\", \"\\n=== ENTRY STATISTICS ===\", \"Position | Total | Win % | Avg P&L | Avg Dur | SL % | Target %\", \"-------------------------------------------------------------\"]\n","            for position, stats in self.entry_stats.items(): summary.append(f\"{position:8} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f} | {stats['avg_duration_bars']:7.1f} | {stats['sl_rate']:4.1f}% | {stats['target_rate']:6.1f}%\")\n","            summary.extend([\"\\n=== EXIT STATISTICS ===\", \"Exit Type           | Total | Win % | Avg P&L | Avg Dur\", \"------------------------------------------------------\"])\n","            for exit_type, stats in sorted(self.exit_stats.items()): summary.append(f\"{str(exit_type):19} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f} | {stats['avg_duration_bars']:7.1f}\")\n","            summary.extend([\"\\n=== SIGNAL TYPE STATISTICS ===\", \"Signal Type          | Total | Win % | Avg P&L\", \"---------------------------------------------\"])\n","            for signal_type, stats in sorted(self.signal_stats.items()):\n","                 if not signal_type: continue\n","                 summary.append(f\"{str(signal_type):20} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f}\")\n","\n","            print(\"\\n\".join(summary)); logger.info(\"\\n\".join(summary))\n","            health = self.summary_stats['health_score']\n","            if health >= 70: health_indicator = \" STRONG\"\n","            elif health >= 50: health_indicator = \" MODERATE\"\n","            else: health_indicator = \" WEAK\"\n","            print(f\"\\nStrategy Health: {health_indicator}\")\n","            if self.summary_stats['total_trades'] < 30: print(\"  Warning: Low sample size (<30 trades)\")\n","        except Exception as e:\n","            logger.error(f\"Error printing summary: {str(e)}\", exc_info=True)\n","            raise\n","\n","# --- Plotting Function ---\n","def plot_signals(df: pd.DataFrame, save_path: Optional[Path] = None):\n","    logger.info(\"Generating signal plot\")\n","    plt.style.use('seaborn-v0_8-darkgrid')\n","    fig, axes = plt.subplots(4, 1, sharex=True, figsize=(20, 15))\n","    if df.empty: logger.warning(\"Plotting skipped: DataFrame is empty.\"); return\n","\n","    ax1 = axes[0] # Price Chart\n","    ax1.plot(df['close'], label='Price', color='black', alpha=0.9, linewidth=1.0)\n","    if 'ema_fast' in df.columns: ax1.plot(df['ema_fast'], label=f\"EMA Fast\", alpha=0.6, linewidth=0.8)\n","    if 'ema_med' in df.columns: ax1.plot(df['ema_med'], label=f\"EMA Med ({PARAMS['ema']['med_len']})\", alpha=0.6, linewidth=0.8)\n","    if 'ema_slow' in df.columns: ax1.plot(df['ema_slow'], label=f\"EMA Slow\", alpha=0.6, linewidth=0.8)\n","    long_entries = df[df['signal'] == 'Long']; short_entries = df[df['signal'] == 'Short']\n","    long_exits = df[df['signal'].str.contains('Exit Long', na=False)]; short_exits = df[df['signal'].str.contains('Exit Short', na=False)]\n","    if not long_entries.empty: ax1.scatter(long_entries.index, long_entries['entry_price'], marker='^', color='lime', s=100, label='Long Entry', zorder=5, edgecolors='black')\n","    if not short_entries.empty: ax1.scatter(short_entries.index, short_entries['entry_price'], marker='v', color='red', s=100, label='Short Entry', zorder=5, edgecolors='black')\n","    exit_long_prices = long_exits['exit_price'].fillna(long_exits['close']); exit_short_prices = short_exits['exit_price'].fillna(short_exits['close'])\n","    if not long_exits.empty: ax1.scatter(long_exits.index, exit_long_prices, marker='x', color='fuchsia', s=80, label='Exit', zorder=5)\n","    if not short_exits.empty: ax1.scatter(short_exits.index, exit_short_prices, marker='x', color='fuchsia', s=80, zorder=5)\n","    if 'trailing_stop' in df.columns: ax1.plot(df['trailing_stop'], label='Trailing Stop', linestyle='--', color='purple', alpha=0.7, linewidth=1.0)\n","    if 'target_price_long' in df.columns: ax1.scatter(df.index, df['target_price_long'], marker='_', color='blue', alpha=0.5, s=50, label='Long Target')\n","    if 'target_price_short' in df.columns: ax1.scatter(df.index, df['target_price_short'], marker='_', color='orange', alpha=0.5, s=50, label='Short Target')\n","    ax1.legend(loc='upper left'); ax1.set_title('Price, EMAs, Signals, Stops & Targets'); ax1.set_ylabel('Price'); ax1.grid(True, which='both', linestyle=':', linewidth=0.5)\n","\n","    ax_score = axes[1] # Score Chart\n","    if 'scaled_score' in df.columns:\n","        ax_score.plot(df['scaled_score'], label='Scaled Score (0-10)', color='teal', linewidth=1.5)\n","        ax_score.axhline(PARAMS['core']['entry_score_threshold'], color='green', linestyle='--', alpha=0.5, label=f'Long Entry Thresh')\n","        ax_score.axhline(10.0 - PARAMS['core']['entry_score_threshold'], color='red', linestyle='--', alpha=0.5, label=f'Short Entry Thresh')\n","        if PARAMS['core']['use_score_drop_exit']:\n","            ax_score.axhline(5.0 - PARAMS['core']['exit_score_drop_threshold'], color='red', linestyle=':', alpha=0.4, label=f'Long Exit Drop')\n","            ax_score.axhline(5.0 + PARAMS['core']['exit_score_drop_threshold'], color='green', linestyle=':', alpha=0.4, label=f'Short Exit Drop')\n","        ax_score.set_ylim(0, 10); ax_score.legend(loc='upper left'); ax_score.set_title('Confidence Score'); ax_score.set_ylabel('Score'); ax_score.grid(True, which='both', linestyle=':', linewidth=0.5)\n","    else: ax_score.set_title('Confidence Score (Not Calculated)'); ax_score.grid(True)\n","\n","    ax_rsi = axes[2] # RSI Chart\n","    if 'rsi' in df.columns:\n","        ax_rsi.plot(df['rsi'], label='RSI', color='orange', linewidth=1.0)\n","        ax_rsi.axhline(50, linestyle='--', color='gray', alpha=0.5); ax_rsi.axhline(PARAMS['rsi']['rsi_buy_level'], linestyle=':', color='green', alpha=0.4); ax_rsi.axhline(PARAMS['rsi']['rsi_sell_level'], linestyle=':', color='red', alpha=0.4)\n","        if 'bullish_rsi_div' in df.columns and 'bearish_rsi_div' in df.columns:\n","            bull_div = df[df['bullish_rsi_div']]; bear_div = df[df['bearish_rsi_div']]\n","            if not bull_div.empty: ax_rsi.scatter(bull_div.index, bull_div['rsi'] * 0.98, marker='^', color='cyan', s=50, label='Bullish Div', zorder=5)\n","            if not bear_div.empty: ax_rsi.scatter(bear_div.index, bear_div['rsi'] * 1.02, marker='v', color='magenta', s=50, label='Bearish Div', zorder=5)\n","        ax_rsi.legend(loc='upper left'); ax_rsi.set_title('RSI & Divergence'); ax_rsi.set_ylabel('RSI'); ax_rsi.grid(True, which='both', linestyle=':', linewidth=0.5)\n","    else: ax_rsi.set_title('RSI (Not Calculated)'); ax_rsi.grid(True)\n","\n","    ax_macd = axes[3] # MACD Chart\n","    if 'macd' in df.columns and 'macd_signal' in df.columns and 'macd_hist' in df.columns:\n","        ax_macd.plot(df['macd'], label='MACD', color='blue', linewidth=1.0); ax_macd.plot(df['macd_signal'], label='Signal', color='red', alpha=0.8, linewidth=1.0)\n","        colors = ['g' if v >= 0 else 'r' for v in df['macd_hist']]; ax_macd.bar(df.index, df['macd_hist'], label='Histogram', color=colors, alpha=0.5)\n","        ax_macd.axhline(0, linestyle='--', color='gray', alpha=0.5); ax_macd.legend(loc='upper left'); ax_macd.set_title('MACD'); ax_macd.set_ylabel('MACD'); ax_macd.grid(True, which='both', linestyle=':', linewidth=0.5)\n","    else: ax_macd.set_title('MACD (Not Calculated)'); ax_macd.grid(True)\n","\n","    axes[-1].tick_params(axis='x', rotation=45)\n","    plt.xlabel('Date')\n","    plt.tight_layout(rect=[0, 0.03, 1, 0.97])\n","    fig.suptitle('Trading Strategy Signals and Indicators', fontsize=16)\n","\n","    if save_path: plt.savefig(save_path, dpi=150); logger.info(f\"Saved signal plot to {save_path}\")\n","    else: plt.show()\n","    plt.close(fig)\n","\n","# --- Command Line Argument Parsing ---\n","# Keep parse_args function for potential local execution, but don't call it directly in Colab\n","def parse_args():\n","    parser = argparse.ArgumentParser(description='Calculate indicators, generate signals, and calculate detailed stats.')\n","    parser.add_argument('--input', type=str, default=str(DEFAULT_INPUT_FILE), help=f'Input RAW OHLCV CSV (default: {DEFAULT_INPUT_FILE})')\n","    parser.add_argument('--output', type=str, default=str(DEFAULT_OUTPUT_FILE), help=f'Output CSV (default: {DEFAULT_OUTPUT_FILE})')\n","    parser.add_argument('--plot', type=str, default=str(DEFAULT_PLOT_FILE), help=f'Plot image path (default: {DEFAULT_PLOT_FILE})')\n","    parser.add_argument('--no-plot', action='store_true', help='Disable generating plot')\n","    parser.add_argument('--full-history', action='store_true', help='Run on full history')\n","    return parser.parse_args()\n","\n","# --- Main Execution Block ---\n","if __name__ == \"__main__\":\n","\n","    # --- Define Paths and Options Directly for Colab ---\n","    # V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V\n","    # EDIT THESE LINES FOR YOUR COLAB SETUP:\n","    input_file = Path('/content/nifty_historical_data.csv') # <-- CHANGE 'nifty_ohlcv.csv' TO YOUR UPLOADED FILE NAME\n","    output_file = Path('/content/nifty_signals_final_calculated.csv') # Output file path in Colab\n","    plot_file = Path('/content/signals_plot_calculated.png') # Plot file path in Colab\n","    run_no_plot = False # Set to True if you DON'T want the plot image saved\n","    run_full_history = False # Set to True if you want to use ALL data, False for last month\n","    # ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^\n","\n","    try:\n","        output_file.parent.mkdir(parents=True, exist_ok=True)\n","        if not run_no_plot: plot_file.parent.mkdir(parents=True, exist_ok=True)\n","\n","        logger.info(f\"Loading data from {input_file}\")\n","        if not input_file.exists(): raise FileNotFoundError(f\"Input file not found: {input_file}. Make sure you uploaded it and the path is correct.\")\n","        df_raw = pd.read_csv(input_file, parse_dates=['datetime'], index_col='datetime')\n","        if df_raw.empty: raise pd.errors.EmptyDataError(\"Input file is empty.\")\n","        required_ohlcv = ['open', 'high', 'low', 'close', 'volume']\n","        if not all(col in df_raw.columns for col in required_ohlcv): raise ValueError(f\"Input CSV must contain OHLCV columns: {', '.join(required_ohlcv)}\")\n","\n","        logger.info(\"Calculating all indicators...\")\n","        calculator = IndicatorCalculator()\n","        df_with_indicators = calculator.calculate_all_indicators(df_raw)\n","        logger.info(f\"Indicators calculated. DataFrame shape: {df_with_indicators.shape}\")\n","        if df_with_indicators.empty:\n","             logger.warning(\"DataFrame empty after indicator calculation. Exiting.\")\n","             sys.exit(0)\n","\n","        rename_map = {\n","            'ema_9': 'ema_fast', 'ema_14': 'ema_med', 'ema_21': 'ema_slow',\n","            'bollinger_mid': 'bb_middle', 'bollinger_upper': 'bb_upper', 'bollinger_lower': 'bb_lower',\n","            'vol_sma_50': 'vol_ma',\n","        }\n","        df_renamed = df_with_indicators.rename(columns=rename_map)\n","        logger.info(\"Renamed calculated indicator columns for internal use.\")\n","\n","        required_internal_cols = ['open', 'high', 'low', 'close', 'volume', 'atr', 'rsi', 'macd', 'macd_signal', 'macd_hist', 'ema_fast', 'ema_med', 'ema_slow', 'bb_middle', 'bb_upper', 'bb_lower', 'vol_ma', 'adx', 'plus_di', 'minus_di']\n","        missing_internal_cols = [col for col in required_internal_cols if col not in df_renamed.columns]\n","        if missing_internal_cols: raise ValueError(f\"DataFrame missing required columns after calculation/rename: {missing_internal_cols}\")\n","\n","        if PARAMS['backtest']['filter_last_month'] and not run_full_history: # Use run_full_history variable\n","            if not df_renamed.empty:\n","                last_date = df_renamed.index.max(); one_month_prior = last_date - pd.DateOffset(months=1)\n","                df = df_renamed.loc[one_month_prior:].copy()\n","                logger.info(f\"Filtered data from {df.index.min().date()} to {df.index.max().date()}.\")\n","            else: df = df_renamed\n","        else: df = df_renamed.copy(); logger.info(f\"Using full data history from {df.index.min().date()} to {df.index.max().date()}.\")\n","\n","        if df.empty:\n","             logger.warning(\"DataFrame empty after filtering. Skipping processing.\")\n","             df_processed = df; analyzer = None\n","        else:\n","            logger.info(\"Processing signals using calculated indicators...\")\n","            df_processed = process_signals(df)\n","            logger.info(\"Analyzing trades...\")\n","            analyzer = EnhancedSignalAnalyzer()\n","            analyzer.analyze_trades(df_processed)\n","            analyzer.print_summary()\n","\n","        logger.info(f\"Saving results to {output_file}\")\n","        df_processed.to_csv(output_file)\n","\n","        if not run_no_plot and not df_processed.empty: # Use run_no_plot variable\n","            plot_signals(df_processed, plot_file)\n","        elif not run_no_plot and df_processed.empty:\n","             logger.warning(\"Plotting skipped as no data.\")\n","\n","        logger.info(\"Processing completed successfully\")\n","        # Use return instead of sys.exit in Colab if running as part of a larger notebook\n","        # sys.exit(0)\n","\n","    except FileNotFoundError as e: logger.error(str(e))#; sys.exit(1)\n","    except pd.errors.EmptyDataError as e: logger.error(f\"Input file '{input_file}' empty/corrupt.\")#; sys.exit(1)\n","    except ValueError as e: logger.error(f\"Data validation error: {str(e)}\")#; sys.exit(1)\n","    except Exception as e: logger.error(f\"Unexpected error: {str(e)}\", exc_info=True)#; sys.exit(1)"],"outputs":[{"output_type":"stream","name":"stdout","text":["\n","=== ENHANCED TRADE SUMMARY ===\n","Total Trades: 3\n","Winning Trades: 0 (0.0%)\n","Losing Trades: 3\n","Total P&L (Points): -126.32\n","Profit Factor: 0.00\n","Expectancy (Points): -42.11\n","Max Drawdown (Points): 126.32\n","Avg Win / Avg Loss (Points): 0.00 / 42.11\n","Max Consecutive Wins: 0\n","Max Consecutive Losses: 3\n","Avg Win Duration (Bars): 0.0\n","Avg Loss Duration (Bars): 6.0\n","Avg Risk/Reward Ratio (at Entry): 0.80:1\n","Strategy Health Score: 0.0/100\n","\n","=== ENTRY STATISTICS ===\n","Position | Total | Win % | Avg P&L | Avg Dur | SL % | Target %\n","-------------------------------------------------------------\n","Short    |     3 |   0.0% |  -42.11 |     6.0 | 66.7% |    0.0%\n","\n","=== EXIT STATISTICS ===\n","Exit Type           | Total | Win % | Avg P&L | Avg Dur\n","------------------------------------------------------\n","BB Mid Exit         |     1 |   0.0% |  -28.85 |     6.0\n","Trailing Stop       |     2 |   0.0% |  -48.73 |     6.0\n","\n","=== SIGNAL TYPE STATISTICS ===\n","Signal Type          | Total | Win % | Avg P&L\n","---------------------------------------------\n","BB Bounce Short      |     1 |   0.0% |  -28.85\n","EMA Bounce Short     |     2 |   0.0% |  -48.73\n","\n","Strategy Health:  WEAK\n","  Warning: Low sample size (<30 trades)\n"]}],"execution_count":4,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"JmHcSHJ8Yl45","executionInfo":{"status":"ok","timestamp":1743713367967,"user_tz":-330,"elapsed":2926,"user":{"displayName":"CHANDRA SHEKHAR","userId":"04101457621295165703"}},"outputId":"894d7944-5145-4832-ad4e-4ee33b8dcd83"}}],"metadata":{"colab":{"provenance":[],"history_visible":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}