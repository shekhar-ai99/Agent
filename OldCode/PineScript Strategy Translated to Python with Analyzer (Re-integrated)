{"cells":[{"cell_type":"code","source":"import numpy as np\nimport pandas as pd\nimport os\nimport logging\nimport matplotlib.pyplot as plt\nfrom typing import Dict, Any, Optional, Tuple, List\nfrom pathlib import Path\nimport argparse\nfrom datetime import timedelta\nfrom collections import defaultdict # Needed for EnhancedSignalAnalyzer\nimport sys\nimport math # For score calculation\n\n# Initialize logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('pinescript_strategy_analyzer.log'), # Log file name\n        logging.StreamHandler()\n    ]\n)\nlogger = logging.getLogger(__name__)\n\n# Configuration\nDATA_FOLDER = Path(\"data\")\nDEFAULT_INPUT_FILE = DATA_FOLDER / \"nifty_ohlcv.csv\"\nDEFAULT_OUTPUT_FILE = DATA_FOLDER / \"pinescript_strategy_analyzer_output.csv\"\nDEFAULT_PLOT_FILE = DATA_FOLDER / \"pinescript_strategy_analyzer_plot.png\"\n\n# --- IndicatorCalculator Class (Calculates base indicators) ---\nclass IndicatorCalculator:\n    DEFAULT_PARAMS = {\n        'ema_periods': [9, 14, 21], # Corresponds to fast, med, slow\n        'macd_params': (12, 26, 9),\n        'rsi_period': 14,\n        'bollinger_period': 20,\n        'bollinger_std': 2,\n        'atr_period': 14,\n        'adx_period': 14,\n        'vol_sma_period': 50,\n    }\n\n    def __init__(self, params: Optional[Dict] = None):\n        self.params = {**self.DEFAULT_PARAMS, **(params or {})}\n        # Add derived lengths for easier access if needed elsewhere\n        self.params['emaFastLen'] = self.params['ema_periods'][0]\n        self.params['emaMedLen'] = self.params['ema_periods'][1]\n        self.params['emaSlowLen'] = self.params['ema_periods'][2]\n        self.params['bbLen'] = self.params['bollinger_period']\n        self.params['rsiLen'] = self.params['rsi_period']\n        self.params['atrLen'] = self.params['atr_period']\n        self.params['adxLen'] = self.params['adx_period']\n        self.params['volMALen'] = self.params['vol_sma_period']\n        self._validate_params()\n\n    def _validate_params(self) -> None:\n        periods_to_check = [\n            *self.params['ema_periods'], self.params['rsi_period'],\n            self.params['bollinger_period'], self.params['atr_period'],\n            self.params['adx_period'], self.params['vol_sma_period']\n        ]\n        if any(p <= 0 for p in periods_to_check): raise ValueError(\"All periods must be positive integers\")\n        if self.params['bollinger_std'] <= 0: raise ValueError(\"Bollinger standard deviation must be positive\")\n\n    def validate_dataframe(self, df: pd.DataFrame) -> None:\n        required_columns = ['open', 'high', 'low', 'close', 'volume']\n        missing = [col for col in required_columns if col not in df.columns]\n        if missing: raise ValueError(f\"Missing required columns: {missing}\")\n        for col in required_columns:\n            if not pd.api.types.is_numeric_dtype(df[col]): raise ValueError(f\"Column {col} must be numeric\")\n        min_period = max([p for p in self.params.values() if isinstance(p, int) and p > 0] + [max(p) for p in self.params.values() if isinstance(p, list) and p])\n        if len(df) < min_period: logger.warning(f\"Limited data points ({len(df)}) may affect indicator accuracy (min {min_period} recommended)\")\n        if (df['high'] < df['low']).any(): raise ValueError(\"High price cannot be less than low price\")\n        if (df['close'] > df['high']).any() or (df['close'] < df['low']).any(): raise ValueError(\"Close price must be between high and low\")\n        if (df['volume'] < 0).any(): raise ValueError(\"Volume cannot be negative\")\n\n    def calculate_emas(self, df: pd.DataFrame) -> pd.DataFrame:\n        try:\n            df['emaFast'] = df['close'].ewm(span=self.params['emaFastLen'], adjust=False, min_periods=1).mean()\n            df['emaMed'] = df['close'].ewm(span=self.params['emaMedLen'], adjust=False, min_periods=1).mean()\n            df['emaSlow'] = df['close'].ewm(span=self.params['emaSlowLen'], adjust=False, min_periods=1).mean()\n            return df\n        except Exception as e: logger.error(f\"Error calculating EMAs: {str(e)}\"); raise\n\n    def calculate_macd(self, df: pd.DataFrame) -> pd.DataFrame:\n        try:\n            fast, slow, signal = self.params['macd_params']\n            ema_fast = df['close'].ewm(span=fast, adjust=False, min_periods=1).mean()\n            ema_slow = df['close'].ewm(span=slow, adjust=False, min_periods=1).mean()\n            df['macdLine'] = ema_fast - ema_slow\n            df['signalLine'] = df['macdLine'].ewm(span=signal, adjust=False, min_periods=1).mean()\n            df['histLine'] = df['macdLine'] - df['signalLine']\n            return df\n        except Exception as e: logger.error(f\"Error calculating MACD: {str(e)}\"); raise\n\n    def calculate_rsi(self, df: pd.DataFrame) -> pd.DataFrame:\n        try:\n            period = self.params['rsiLen']; delta = df['close'].diff()\n            if len(delta) < period: logger.warning(f\"Insufficient data for RSI ({len(delta)} points)\"); df['priceRsi'] = np.nan; return df\n            gain = delta.where(delta > 0, 0.0); loss = -delta.where(delta < 0, 0.0)\n            avg_gain = gain.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n            avg_loss = loss.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n            rs = avg_gain / avg_loss.replace(0, 1e-6)\n            df['priceRsi'] = 100.0 - (100.0 / (1.0 + rs))\n            df['priceRsi'] = df['priceRsi'].fillna(50); df['priceRsi'] = df['priceRsi'].clip(0, 100)\n            return df\n        except Exception as e: logger.error(f\"Error calculating RSI: {str(e)}\"); raise\n\n    def calculate_bollinger_bands(self, df: pd.DataFrame) -> pd.DataFrame:\n        try:\n            period = self.params['bbLen']; std_dev = self.params['bollinger_std']\n            sma = df['close'].rolling(window=period, min_periods=1).mean()\n            rolling_std = df['close'].rolling(window=period, min_periods=1).std()\n            df['bbUpper'] = sma + (std_dev * rolling_std)\n            df['bbLower'] = sma - (std_dev * rolling_std)\n            df['bbMiddle'] = sma\n            return df\n        except Exception as e: logger.error(f\"Error calculating Bollinger Bands: {str(e)}\"); raise\n\n    def calculate_atr(self, df: pd.DataFrame) -> pd.DataFrame:\n        try:\n            period = self.params['atrLen']\n            high_low = df['high'] - df['low']\n            high_close = (df['high'] - df['close'].shift()).abs()\n            low_close = (df['low'] - df['close'].shift()).abs()\n            true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)\n            df['atrVal'] = true_range.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n            return df\n        except Exception as e: logger.error(f\"Error calculating ATR: {str(e)}\"); raise\n\n    def calculate_adx(self, df: pd.DataFrame) -> pd.DataFrame:\n        try:\n            period = self.params['adxLen']\n            if 'atrVal' not in df.columns: df = self.calculate_atr(df)\n            up_move = df['high'].diff(); down_move = -df['low'].diff()\n            plus_dm = ((up_move > down_move) & (up_move > 0)) * up_move\n            minus_dm = ((down_move > up_move) & (down_move > 0)) * down_move\n            plus_dm = plus_dm.fillna(0); minus_dm = minus_dm.fillna(0)\n            smooth_plus_dm = plus_dm.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n            smooth_minus_dm = minus_dm.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n            atr_smoothed = df['atrVal'].replace(0, 1e-6)\n            df['diPos'] = 100 * (smooth_plus_dm / atr_smoothed)\n            df['diNeg'] = 100 * (smooth_minus_dm / atr_smoothed)\n            di_sum = (df['diPos'] + df['diNeg']).replace(0, 1e-6)\n            dx = 100 * (abs(df['diPos'] - df['diNeg']) / di_sum)\n            df['adxVal'] = dx.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n            df[['diPos', 'diNeg', 'adxVal']] = df[['diPos', 'diNeg', 'adxVal']].fillna(0)\n            return df\n        except Exception as e: logger.error(f\"Error calculating ADX: {str(e)}\"); raise\n\n    def calculate_volume_sma(self, df: pd.DataFrame) -> pd.DataFrame:\n        try:\n            period = self.params['volMALen']\n            df['volMA'] = df['volume'].rolling(window=period, min_periods=1).mean()\n            return df\n        except Exception as e: logger.error(f\"Error calculating Volume SMA: {str(e)}\"); raise\n\n    def calculate_all_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n        try:\n            self.validate_dataframe(df)\n            df = df.copy()\n            logger.info(\"Calculating EMAs...\")\n            df = self.calculate_emas(df)\n            logger.info(\"Calculating MACD...\")\n            df = self.calculate_macd(df)\n            logger.info(\"Calculating RSI...\")\n            df = self.calculate_rsi(df)\n            logger.info(\"Calculating Bollinger Bands...\")\n            df = self.calculate_bollinger_bands(df)\n            logger.info(\"Calculating ATR...\")\n            df = self.calculate_atr(df)\n            logger.info(\"Calculating ADX...\")\n            df = self.calculate_adx(df)\n            logger.info(\"Calculating Volume SMA...\")\n            df = self.calculate_volume_sma(df)\n            logger.info(f\"Successfully calculated indicators\")\n            max_lookback = max([p for p in self.params.values() if isinstance(p, int) and p > 0] + [max(p) for p in self.params.values() if isinstance(p, list) and p])\n            max_lookback = max(1, max_lookback)\n            if max_lookback < len(df):\n                df = df.iloc[max_lookback:].copy()\n                logger.info(f\"Dropped initial {max_lookback} rows with NaNs, final shape: {df.shape}\")\n            else:\n                 logger.warning(f\"Not enough rows ({len(df)}) to drop initial NaNs ({max_lookback}). DataFrame might be empty or contain NaNs.\")\n                 df = df.iloc[0:0]\n            return df\n        except Exception as e: logger.error(f\"Indicator calculation failed: {str(e)}\", exc_info=True); raise\n\n\n# --- Strategy Parameters (Derived from PineScript Inputs) ---\nPARAMS: Dict[str, Dict[str, Any]] = {\n    'backtest': { 'commission_pct': 0.0005, 'slippage_pct': 0.0002, 'filter_last_month': True },\n    'core': { \"max_trade_duration\": 50, 'exitScoreDropThreshold': 1.5, 'useFibBounceEntry': True, 'useFibBounceSell': True, 'fibBounceLookback': 3, 'useEmaBounceBuy': True, 'useEmaBounceSell': True, 'emaBounceLookback': 2, 'emaBounceSource': \"Fast EMA\", 'useBbMidBounceBuy': True, 'useBbMidBounceSell': True, 'bbBounceLookback': 2, 'useVolBreakoutBuy': True, 'useVolBreakoutSell': True, 'trailing_stop_type': \"atr\", 'trailing_stop_pct': 0.02, 'trailing_stop_atr_multiplier': 2.0, # Default from PineScript atrMult\n              'profit_protection_levels': {'level1': {'profit_pct': 0.05, 'new_atr_mult': 1.0}, 'level2': {'profit_pct': 0.10, 'new_atr_mult': 0.5}}}, # Keep profit protection example\n    'ema': { 'useEmaExit': True }, # Lengths defined in IndicatorCalculator\n    'bollinger': { 'useBBReturnExit': True }, # Length/StdDev defined in IndicatorCalculator\n    'rsi': { 'rsiBuyLevel': 55.0, 'rsiSellLevel': 45.0, 'useRsiDivExit': False, 'rsiConfirmFibBounce': True, 'rsiConfirmEmaBounce': False, 'rsiConfirmBbBounce': False, 'rsi_confirm_level_buy': 40.0, 'rsi_confirm_level_sell': 60.0 }, # Length defined in IndicatorCalculator\n    'macd': {}, # Lengths defined in IndicatorCalculator\n    'volume': { 'volMultiplier': 1.5, 'useVolFadeExit': True }, # Length defined in IndicatorCalculator\n    'atr': { 'useAtrStop': True }, # Length defined in IndicatorCalculator\n    'fibonacci': { 'useFibExit': True, 'fibLookbackExit': 30, 'fibExtensionLevel': 1.618, 'fibPivotLookback': 15, 'fibMaxBars': 200 },\n    'trend': { 'useEmaTrendFilter': True, 'useAdxFilter': True, 'adxThreshold': 20.0, 'useAdxDirectionFilter': True }, # Length defined in IndicatorCalculator\n    'score_weights': { 'wEmaTrend': 2, 'wEmaSignal': 1, 'wRsiThresh': 1, 'wMacdSignal': 1, 'wMacdZero': 1, 'wVolBreak': 1, 'wAdxStrength': 1, 'wAdxDirection': 1, 'wHtfTrend': 0, # HTF not implemented, set weight to 0\n                       'wFibBounce': 2, 'wEmaBounce': 1, 'wBbBounce': 1, }\n}\n\n# --- TradeState Class ---\nclass TradeState:\n    def __init__(self):\n        self.position = None # 'Long', 'Short', or None\n        self.entry_price = np.nan\n        self.entry_index = -1\n        self.stopLossLevel = np.nan # Matches PineScript var name\n        self.fibTargetLevelExit = np.nan # Matches PineScript var name\n        self.highest_high_in_trade = np.nan\n        self.lowest_low_in_trade = np.nan\n        self.time_in_trade = 0\n\n    def reset(self):\n        self.__init__()\n\n    def update_trailing_stop(self, current_low, current_high, atrVal):\n        \"\"\"Updates the ATR trailing stop loss based on PineScript logic.\"\"\"\n        if self.position is None or pd.isna(atrVal) or pd.isna(self.stopLossLevel):\n            return # No position or ATR/initial SL not available\n\n        atr_mult = PARAMS['core']['trailing_stop_atr_multiplier']\n\n        if self.position == 'Long':\n            newStopLong = current_low - atrVal * atr_mult\n            self.stopLossLevel = max(self.stopLossLevel, newStopLong)\n        elif self.position == 'Short':\n            newStopShort = current_high + atrVal * atr_mult\n            self.stopLossLevel = min(self.stopLossLevel, newStopShort)\n\n\n# --- Feature Calculation Functions ---\ndef calculate_fibonacci_levels(df: pd.DataFrame) -> pd.DataFrame:\n    logger.debug(\"Calculating Fibonacci levels (strategy feature)\")\n    try:\n        lookback = PARAMS['fibonacci']['fibPivotLookback']; max_bars = PARAMS['fibonacci']['fibMaxBars']\n        df['rolling_high'] = df['high'].rolling(window=2 * lookback + 1, center=True, min_periods=lookback//2+1).max()\n        df['rolling_low'] = df['low'].rolling(window=2 * lookback + 1, center=True, min_periods=lookback//2+1).min()\n        df['is_pivot_high'] = df['high'] == df['rolling_high']; df['is_pivot_low'] = df['low'] == df['rolling_low']\n        df['last_pivot_high_price'] = df.loc[df['is_pivot_high'], 'high'].ffill().shift()\n        df['last_pivot_high_idx'] = df.loc[df['is_pivot_high']].index.to_series().ffill().shift()\n        df['last_pivot_low_price'] = df.loc[df['is_pivot_low'], 'low'].ffill().shift()\n        df['last_pivot_low_idx'] = df.loc[df['is_pivot_low']].index.to_series().ffill().shift()\n        current_bar_indices = np.arange(len(df))\n        # Handle potential KeyError if index not found after filtering/dropna\n        df['last_pivot_high_idx_num'] = df['last_pivot_high_idx'].apply(lambda x: df.index.get_loc(x) if pd.notna(x) and x in df.index else np.nan)\n        df['last_pivot_low_idx_num'] = df['last_pivot_low_idx'].apply(lambda x: df.index.get_loc(x) if pd.notna(x) and x in df.index else np.nan)\n        high_too_old = (current_bar_indices - df['last_pivot_high_idx_num']) > max_bars\n        low_too_old = (current_bar_indices - df['last_pivot_low_idx_num']) > max_bars\n        df.loc[high_too_old, ['last_pivot_high_price', 'last_pivot_high_idx', 'last_pivot_high_idx_num']] = np.nan\n        df.loc[low_too_old, ['last_pivot_low_price', 'last_pivot_low_idx', 'last_pivot_low_idx_num']] = np.nan\n        df['last_pivot_high_idx_num'] = df['last_pivot_high_idx_num'].fillna(-1)\n        df['last_pivot_low_idx_num'] = df['last_pivot_low_idx_num'].fillna(-1)\n        is_uptrend_fib = (df['last_pivot_high_idx_num'] > df['last_pivot_low_idx_num'])\n        swing_high = np.where(is_uptrend_fib, df['last_pivot_high_price'], df['last_pivot_low_price'])\n        swing_low = np.where(is_uptrend_fib, df['last_pivot_low_price'], df['last_pivot_high_price'])\n        fib_range = swing_high - swing_low; fib_range[fib_range <= 0] = np.nan\n        level_0 = np.where(is_uptrend_fib, swing_low, swing_high); level_100 = np.where(is_uptrend_fib, swing_high, swing_low)\n        df['fib_0'] = level_0; df['fib_236'] = level_0 + fib_range * 0.236; df['fib_382'] = level_0 + fib_range * 0.382\n        df['fib_500'] = level_0 + fib_range * 0.500; df['fib_618'] = level_0 + fib_range * 0.618; df['fib_786'] = level_0 + fib_range * 0.786\n        df['fib_100'] = level_100; df['is_uptrend_fib'] = is_uptrend_fib\n        df = df.drop(columns=[ 'rolling_high', 'rolling_low', 'is_pivot_high', 'is_pivot_low', 'last_pivot_high_price', 'last_pivot_high_idx', 'last_pivot_low_price', 'last_pivot_low_idx', 'last_pivot_high_idx_num', 'last_pivot_low_idx_num'], errors='ignore')\n        return df\n    except Exception as e: logger.error(f\"Error in calculate_fibonacci_levels: {str(e)}\", exc_info=True); raise\n\ndef calculate_rsi_divergence(df: pd.DataFrame) -> pd.DataFrame:\n    logger.debug(f\"Calculating RSI divergence\")\n    try:\n        if 'priceRsi' not in df.columns: logger.error(\"RSI column 'priceRsi' missing\"); df['bullish_rsi_div'] = False; df['bearish_rsi_div'] = False; return df\n        lookback = 5 ; rsi_lookback = 2 # Matching PineScript divergence pivot settings\n        df['bullish_rsi_div'] = False; df['bearish_rsi_div'] = False\n        df['price_low_roll'] = df['low'].rolling(window=lookback, closed='left').min()\n        df['rsi_low_roll'] = df['priceRsi'].rolling(window=lookback, closed='left').min()\n        df['price_high_roll'] = df['high'].rolling(window=lookback, closed='left').max()\n        df['rsi_high_roll'] = df['priceRsi'].rolling(window=lookback, closed='left').max()\n        df['bullish_rsi_div'] = (df['low'] < df['price_low_roll']) & (df['priceRsi'] > df['rsi_low_roll'])\n        df['bearish_rsi_div'] = (df['high'] > df['price_high_roll']) & (df['priceRsi'] < df['rsi_high_roll'])\n        df = df.drop(columns=['price_low_roll', 'rsi_low_roll', 'price_high_roll', 'rsi_high_roll'], errors='ignore')\n        return df\n    except Exception as e: logger.error(f\"Error in calculate_rsi_divergence: {str(e)}\", exc_info=True); raise\n\n# --- Main Signal Processing Function (Translated from PineScript - Syntax Corrected) ---\ndef process_signals(df: pd.DataFrame) -> pd.DataFrame:\n    logger.info(\"Starting PineScript strategy signal processing\")\n    try:\n        required_cols = ['open', 'high', 'low', 'close', 'volume', 'atrVal', 'priceRsi', 'macdLine', 'signalLine', 'histLine', 'emaFast', 'emaMed', 'emaSlow', 'bbMiddle', 'bbUpper', 'bbLower', 'volMA', 'adxVal', 'diPos', 'diNeg']\n        missing_cols = [col for col in required_cols if col not in df.columns]\n        if missing_cols: raise ValueError(f\"DataFrame missing required columns for signal processing: {missing_cols}\")\n\n        df = calculate_fibonacci_levels(df)\n        df = calculate_rsi_divergence(df)\n\n        df['signal'] = 'Hold'; df['position'] = ''; df['entry_price'] = np.nan; df['stop_loss'] = np.nan; df['trailing_stop'] = np.nan; df['exit_price'] = np.nan; df['exit_reason'] = ''; df['entry_signal_type'] = ''; df['scaled_score'] = 5.0\n\n        start_index = max( PARAMS['fibonacci']['fibPivotLookback'] * 2 + 1, PARAMS['fibonacci']['fibLookbackExit'], PARAMS['core']['fibBounceLookback'], PARAMS['core']['emaBounceLookback'], PARAMS['core']['bbBounceLookback'], 5 ) + 1\n        # Ensure start index is valid relative to the current DataFrame length\n        start_index = max(0, start_index - df.index.get_loc(df.index[0])) # Adjust start index relative to potentially shortened df\n        if start_index >= len(df): logger.warning(f\"Not enough data after dropping NaNs. Required: {start_index}, Available: {len(df)}\"); return df\n\n        logger.info(f\"Starting main processing loop from index {start_index}\")\n        trade_state = TradeState(); weights = PARAMS['score_weights']\n        total_possible_score = sum(w for k, w in weights.items() if k != 'wHtfTrend'); total_possible_score = max(1.0, total_possible_score)\n\n        for i in range(start_index, len(df)):\n            current_idx = df.index[i]; prev_idx = df.index[i-1]; current = df.iloc[i]; prev = df.iloc[i-1]\n            exit_triggered_this_bar = False; exit_price_this_bar = np.nan; exit_reason_bar = ''\n            wasInLong = trade_state.position == 'Long'; wasInShort = trade_state.position == 'Short'\n\n            # Base Conditions\n            condEmaFastSlowCrossBuy = current['emaFast'] > current['emaSlow'] and prev['emaFast'] <= prev['emaSlow']; condEmaFastSlowCrossSell = current['emaFast'] < current['emaSlow'] and prev['emaFast'] >= prev['emaSlow']\n            condEmaFastMedCrossBuy = current['emaFast'] > current['emaMed'] and prev['emaFast'] <= prev['emaMed']; condEmaFastMedCrossSell = current['emaFast'] < current['emaMed'] and prev['emaFast'] >= prev['emaMed']\n            condBbReturnMeanBuy = current['close'] > current['bbMiddle'] and prev['close'] <= prev['bbMiddle']; condBbReturnMeanSell = current['close'] < current['bbMiddle'] and prev['close'] >= prev['bbMiddle']\n            condRsiBuy = current['priceRsi'] > PARAMS['rsi']['rsiBuyLevel']; condRsiSell = current['priceRsi'] < PARAMS['rsi']['rsiSellLevel']\n            condMacdSignalCrossBuy = current['macdLine'] > current['signalLine'] and prev['macdLine'] <= prev['signalLine']; condMacdSignalCrossSell = current['macdLine'] < current['signalLine'] and prev['macdLine'] >= prev['signalLine']\n            condMacdZeroCrossBuy = current['macdLine'] > 0 and prev['macdLine'] <= 0; condMacdZeroCrossSell = current['macdLine'] < 0 and prev['macdLine'] >= 0\n            condHighVol = current['volume'] > current['volMA'] * PARAMS['volume']['volMultiplier']\n            condVolBreakoutBuy = condHighVol and current['close'] > current['open'] and current['close'] > current['emaSlow']; condVolBreakoutSell = condHighVol and current['close'] < current['open'] and current['close'] < current['emaSlow']\n            condVolFadeLong = current['close'] < current['emaFast'] and current['volume'] < current['volMA']; condVolFadeShort = current['close'] > current['emaFast'] and current['volume'] < current['volMA']\n\n            # Filters\n            condEmaTrendOkBuy = not PARAMS['trend']['useEmaTrendFilter'] or current['emaMed'] > current['emaSlow']; condEmaTrendOkSell = not PARAMS['trend']['useEmaTrendFilter'] or current['emaMed'] < current['emaSlow']\n            condAdxStrengthOk = not PARAMS['trend']['useAdxFilter'] or current['adxVal'] > PARAMS['trend']['adxThreshold']\n            condAdxDirectionOkBuy = not PARAMS['trend']['useAdxDirectionFilter'] or current['diPos'] > current['diNeg']; condAdxDirectionOkSell = not PARAMS['trend']['useAdxDirectionFilter'] or current['diNeg'] > current['diPos']\n            condAdxFilterOkBuy = condAdxStrengthOk and condAdxDirectionOkBuy; condAdxFilterOkSell = condAdxStrengthOk and condAdxDirectionOkSell\n            allFiltersOkBuy = condEmaTrendOkBuy and condAdxFilterOkBuy; allFiltersOkSell = condEmaTrendOkSell and condAdxFilterOkSell\n\n            # Dynamic Conditions\n            condFibBounceBuy = False; condFibBounceSell = False\n            if PARAMS['core']['useFibBounceEntry'] or PARAMS['core']['useFibBounceSell']:\n                lookback=PARAMS['core']['fibBounceLookback']; rsi_conf = PARAMS['rsi']['rsiConfirmFibBounce']\n                if PARAMS['core']['useFibBounceEntry'] and current['is_uptrend_fib']:\n                    level_618 = current['fib_618']; level_500 = current['fib_500']\n                    if pd.notna(level_618) and pd.notna(level_500):\n                        touched_zone = (df['low'].iloc[i-lookback:i] <= level_618).any(); bounced_above = current['close'] > level_500; rsi_ok = not rsi_conf or (current['priceRsi'] > 40 and current['priceRsi'] > prev['priceRsi'])\n                        if touched_zone and bounced_above and rsi_ok: condFibBounceBuy = True\n                if PARAMS['core']['useFibBounceSell'] and not current['is_uptrend_fib']:\n                    level_382 = current['fib_382']; level_500 = current['fib_500']\n                    if pd.notna(level_382) and pd.notna(level_500):\n                        touched_zone = (df['high'].iloc[i-lookback:i] >= level_382).any(); bounced_below = current['close'] < level_500; rsi_ok = not rsi_conf or (current['priceRsi'] < 60 and current['priceRsi'] < prev['priceRsi'])\n                        if touched_zone and bounced_below and rsi_ok: condFibBounceSell = True\n            condEmaBounceBuy = False; condEmaBounceSell = False\n            if PARAMS['core']['useEmaBounceBuy'] or PARAMS['core']['useEmaBounceSell']:\n                lookback=PARAMS['core']['emaBounceLookback']; ema_source_col = 'emaFast' if PARAMS['core']['emaBounceSource'] == \"Fast EMA\" else 'emaMed'; ema_source = df[ema_source_col]; rsi_conf = PARAMS['rsi']['rsiConfirmEmaBounce']\n                if PARAMS['core']['useEmaBounceBuy']:\n                    aboveEmaBefore = df[ema_source_col].iloc[i-(lookback+1)] < df['close'].iloc[i-(lookback+1)] if i > lookback else False\n                    touched_ema = (df['low'].iloc[i-lookback:i] <= ema_source.iloc[i-lookback:i]).any(); bounced_above = current['close'] > current[ema_source_col] and current['close'] > current['open']; rsi_ok = not rsi_conf or (current['priceRsi'] > 40 and current['priceRsi'] > prev['priceRsi'])\n                    if aboveEmaBefore and touched_ema and bounced_above and rsi_ok: condEmaBounceBuy = True\n                if PARAMS['core']['useEmaBounceSell']:\n                    belowEmaBefore = df[ema_source_col].iloc[i-(lookback+1)] > df['close'].iloc[i-(lookback+1)] if i > lookback else False\n                    touched_ema = (df['high'].iloc[i-lookback:i] >= ema_source.iloc[i-lookback:i]).any(); bounced_below = current['close'] < current[ema_source_col] and current['close'] < current['open']; rsi_ok = not rsi_conf or (current['priceRsi'] < 60 and current['priceRsi'] < prev['priceRsi'])\n                    if belowEmaBefore and touched_ema and bounced_below and rsi_ok: condEmaBounceSell = True\n            condBbMidBounceBuy = False; condBbMidBounceSell = False\n            if PARAMS['core']['useBbMidBounceBuy'] or PARAMS['core']['useBbMidBounceSell']:\n                lookback=PARAMS['core']['bbBounceLookback']; bb_mid = df['bbMiddle']; rsi_conf = PARAMS['rsi']['rsiConfirmBbBounce']\n                if PARAMS['core']['useBbMidBounceBuy']:\n                    touched_bb = (df['low'].iloc[i-lookback:i] <= bb_mid.iloc[i-lookback:i]).any(); bounced_above = current['close'] > current['bbMiddle'] and current['close'] > current['open']; rsi_ok = not rsi_conf or (current['priceRsi'] > 40 and current['priceRsi'] > prev['priceRsi'])\n                    if touched_bb and bounced_above and rsi_ok: condBbMidBounceBuy = True\n                if PARAMS['core']['useBbMidBounceSell']:\n                    touched_bb = (df['high'].iloc[i-lookback:i] >= bb_mid.iloc[i-lookback:i]).any(); bounced_below = current['close'] < current['bbMiddle'] and current['close'] < current['open']; rsi_ok = not rsi_conf or (current['priceRsi'] < 60 and current['priceRsi'] < prev['priceRsi'])\n                    if touched_bb and bounced_below and rsi_ok: condBbMidBounceSell = True\n            condVolBreakoutBuy = condVolBreakoutBuy # Already calculated\n            condVolBreakoutSell = condVolBreakoutSell # Already calculated\n\n            # Score Calculation\n            buyScore_bar = 0.0; sellScore_bar = 0.0\n            if condEmaTrendOkBuy: buyScore_bar += weights['wEmaTrend'];\n            elif condEmaTrendOkSell: sellScore_bar += weights['wEmaTrend']\n            if condEmaFastSlowCrossBuy: buyScore_bar += weights['wEmaSignal']\n            if condEmaFastSlowCrossSell: sellScore_bar += weights['wEmaSignal']\n            if condRsiBuy: buyScore_bar += weights['wRsiThresh']\n            if condRsiSell: sellScore_bar += weights['wRsiThresh']\n            if condMacdSignalCrossBuy: buyScore_bar += weights['wMacdSignal']\n            if condMacdSignalCrossSell: sellScore_bar += weights['wMacdSignal']\n            if condMacdZeroCrossBuy: buyScore_bar += weights['wMacdZero']\n            if condMacdZeroCrossSell: sellScore_bar += weights['wMacdZero']\n            if condVolBreakoutBuy: buyScore_bar += weights['wVolBreak']\n            if condVolBreakoutSell: sellScore_bar += weights['wVolBreak']\n            if condAdxStrengthOk:\n                if condAdxDirectionOkBuy: buyScore_bar += weights['wAdxStrength']\n                if condAdxDirectionOkSell: sellScore_bar += weights['wAdxStrength']\n            if condAdxDirectionOkBuy: buyScore_bar += weights['wAdxDirection']\n            if condAdxDirectionOkSell: sellScore_bar += weights['wAdxDirection']\n            if condFibBounceBuy: buyScore_bar += weights['wFibBounce']\n            if condFibBounceSell: sellScore_bar += weights['wFibBounce']\n            if condEmaBounceBuy: buyScore_bar += weights['wEmaBounce']\n            if condEmaBounceSell: sellScore_bar += weights['wEmaBounce']\n            if condBbMidBounceBuy: buyScore_bar += weights['wBbBounce']\n            if condBbMidBounceSell: sellScore_bar += weights['wBbBounce']\n            netScore = buyScore_bar - sellScore_bar; scaledScore = max(0.0, min(10.0, ((netScore / total_possible_score) * 5.0) + 5.0)); df.loc[current_idx, 'scaled_score'] = scaledScore\n\n            # RSI Div Exit Conditions\n            condRsiBullDivExit = PARAMS['rsi']['useRsiDivExit'] and current['bearish_rsi_div']; condRsiBearDivExit = PARAMS['rsi']['useRsiDivExit'] and current['bullish_rsi_div']\n\n            # --- I. Check for Exits ---\n            if wasInLong:\n                atrStopHitLong = PARAMS['atr']['useAtrStop'] and current['close'] < trade_state.stopLossLevel\n                fibHitLong = PARAMS['fibonacci']['useFibExit'] and pd.notna(trade_state.fibTargetLevelExit) and current['high'] >= trade_state.fibTargetLevelExit\n                scoreDropExitLong = scaledScore < (5.0 - PARAMS['core']['exitScoreDropThreshold'])\n                emaExitLong = PARAMS['ema']['useEmaExit'] and condEmaFastMedCrossSell\n                bbExitLong = PARAMS['bollinger']['useBBReturnExit'] and condBbReturnMeanSell\n                volExitLong = PARAMS['volume']['useVolFadeExit'] and condVolFadeLong\n                rsiDivExitLong = condRsiBullDivExit\n                if atrStopHitLong: exit_reason_bar = \"ATR SL\"; exit_price_this_bar = min(current['open'], trade_state.stopLossLevel); exit_triggered_this_bar = True\n                elif fibHitLong: exit_reason_bar = \"Fib Tgt\"; exit_price_this_bar = max(current['open'], trade_state.fibTargetLevelExit); exit_triggered_this_bar = True\n                elif scoreDropExitLong: exit_reason_bar = f\"Score Drop ({scaledScore:.1f})\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n                elif emaExitLong: exit_reason_bar = \"EMA Cross\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n                elif bbExitLong: exit_reason_bar = \"BB Mid Exit\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n                elif volExitLong: exit_reason_bar = \"Vol Fade\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n                elif rsiDivExitLong: exit_reason_bar = \"RSI Div\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n                if exit_triggered_this_bar: df.loc[current_idx, 'signal'] = 'Exit Long'; df.loc[current_idx, 'exit_reason'] = exit_reason_bar; df.loc[current_idx, 'exit_price'] = exit_price_this_bar; trade_state.reset()\n            elif wasInShort:\n                atrStopHitShort = PARAMS['atr']['useAtrStop'] and current['close'] > trade_state.stopLossLevel\n                fibHitShort = PARAMS['fibonacci']['useFibExit'] and pd.notna(trade_state.fibTargetLevelExit) and current['low'] <= trade_state.fibTargetLevelExit\n                scoreDropExitShort = scaledScore > (5.0 + PARAMS['core']['exitScoreDropThreshold'])\n                emaExitShort = PARAMS['ema']['useEmaExit'] and condEmaFastMedCrossBuy\n                bbExitShort = PARAMS['bollinger']['useBBReturnExit'] and condBbReturnMeanBuy\n                volExitShort = PARAMS['volume']['useVolFadeExit'] and condVolFadeShort\n                rsiDivExitShort = condRsiBearDivExit\n                if atrStopHitShort: exit_reason_bar = \"ATR SL\"; exit_price_this_bar = max(current['open'], trade_state.stopLossLevel); exit_triggered_this_bar = True\n                elif fibHitShort: exit_reason_bar = \"Fib Tgt\"; exit_price_this_bar = min(current['open'], trade_state.fibTargetLevelExit); exit_triggered_this_bar = True\n                elif scoreDropExitShort: exit_reason_bar = f\"Score Drop ({scaledScore:.1f})\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n                elif emaExitShort: exit_reason_bar = \"EMA Cross\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n                elif bbExitShort: exit_reason_bar = \"BB Mid Exit\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n                elif volExitShort: exit_reason_bar = \"Vol Fade\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n                elif rsiDivExitShort: exit_reason_bar = \"RSI Div\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n                if exit_triggered_this_bar: df.loc[current_idx, 'signal'] = 'Exit Short'; df.loc[current_idx, 'exit_reason'] = exit_reason_bar; df.loc[current_idx, 'exit_price'] = exit_price_this_bar; trade_state.reset()\n\n            # --- II. Check for Entries ---\n            if trade_state.position is None and not exit_triggered_this_bar:\n                isPotentialEmaBuy = condEmaFastSlowCrossBuy and allFiltersOkBuy; isPotentialFibBuy = condFibBounceBuy and allFiltersOkBuy; isPotentialEmaBounceBuy = condEmaBounceBuy and allFiltersOkBuy; isPotentialBbMidBounceBuy = condBbMidBounceBuy and allFiltersOkBuy; isPotentialVolBuy = PARAMS['core']['useVolBreakoutBuy'] and condVolBreakoutBuy and allFiltersOkBuy\n                isPotentialEmaSell = condEmaFastSlowCrossSell and allFiltersOkSell; isPotentialFibSell = condFibBounceSell and allFiltersOkSell; isPotentialEmaBounceSell = condEmaBounceSell and allFiltersOkSell; isPotentialBbMidBounceSell = condBbMidBounceSell and allFiltersOkSell; isPotentialVolSell = PARAMS['core']['useVolBreakoutSell'] and condVolBreakoutSell and allFiltersOkSell\n                plotSignalBuy = isPotentialEmaBuy or isPotentialFibBuy or isPotentialEmaBounceBuy or isPotentialBbMidBounceBuy or isPotentialVolBuy\n                plotSignalSell = isPotentialEmaSell or isPotentialFibSell or isPotentialEmaBounceSell or isPotentialBbMidBounceSell or isPotentialVolSell\n                entry_signal_type = np.nan\n                if isPotentialBbMidBounceBuy: entry_signal_type = \"BB Bounce Long\";\n                if isPotentialEmaBounceBuy: entry_signal_type = \"EMA Bounce Long\";\n                if isPotentialVolBuy: entry_signal_type = \"Vol Breakout Long\";\n                if isPotentialFibBuy: entry_signal_type = \"Fib Bounce Long\";\n                if isPotentialEmaBuy: entry_signal_type = \"EMA Cross Long\";\n                if isPotentialBbMidBounceSell: entry_signal_type = \"BB Bounce Short\";\n                if isPotentialEmaBounceSell: entry_signal_type = \"EMA Bounce Short\";\n                if isPotentialVolSell: entry_signal_type = \"Vol Breakout Short\";\n                if isPotentialFibSell: entry_signal_type = \"Fib Bounce Short\";\n                if isPotentialEmaSell: entry_signal_type = \"EMA Cross Short\";\n\n                if plotSignalBuy:\n                    entry_price_adj = current['close'] * (1 + PARAMS['backtest']['slippage_pct']); trade_state.position = 'Long'; trade_state.entry_price = entry_price_adj; trade_state.entry_index = i; trade_state.time_in_trade = 0; trade_state.stopLossLevel = current['low'] - current['atrVal'] * PARAMS['core']['trailing_stop_atr_multiplier']; trade_state.highest_high_in_trade = current['high']\n                    if PARAMS['fibonacci']['useFibExit']:\n                        lookback_fib = PARAMS['fibonacci']['fibLookbackExit']; lookback_start_fib = max(0, i - lookback_fib); lowest_series = df['low'].iloc[lookback_start_fib : i]\n                        if not lowest_series.empty: swingLowPriceExit = lowest_series.min(); swingRangeFibExit = entry_price_adj - swingLowPriceExit;\n                            # --- Corrected Syntax ---\n                            if swingRangeFibExit > 0:\n                                trade_state.fibTargetLevelExit = entry_price_adj + swingRangeFibExit * PARAMS['fibonacci']['fibExtensionLevel']\n                            else:\n                                trade_state.fibTargetLevelExit = np.nan\n                            # --- End Correction ---\n                        else: trade_state.fibTargetLevelExit = np.nan\n                    else: trade_state.fibTargetLevelExit = np.nan\n                    df.loc[current_idx, 'signal'] = 'Long'; df.loc[current_idx, 'entry_price'] = trade_state.entry_price; df.loc[current_idx, 'stop_loss'] = trade_state.stopLossLevel; df.loc[current_idx, 'entry_signal_type'] = entry_signal_type\n                elif plotSignalSell:\n                    entry_price_adj = current['close'] * (1 - PARAMS['backtest']['slippage_pct']); trade_state.position = 'Short'; trade_state.entry_price = entry_price_adj; trade_state.entry_index = i; trade_state.time_in_trade = 0; trade_state.stopLossLevel = current['high'] + current['atrVal'] * PARAMS['core']['trailing_stop_atr_multiplier']; trade_state.lowest_low_in_trade = current['low']\n                    if PARAMS['fibonacci']['useFibExit']:\n                        lookback_fib = PARAMS['fibonacci']['fibLookbackExit']; lookback_start_fib = max(0, i - lookback_fib); highest_series = df['high'].iloc[lookback_start_fib : i]\n                        if not highest_series.empty: swingHighPriceExit = highest_series.max(); swingRangeFibExit = swingHighPriceExit - entry_price_adj;\n                            # --- Corrected Syntax ---\n                            if swingRangeFibExit > 0:\n                                trade_state.fibTargetLevelExit = entry_price_adj - swingRangeFibExit * PARAMS['fibonacci']['fibExtensionLevel']\n                            else:\n                                trade_state.fibTargetLevelExit = np.nan\n                            # --- End Correction ---\n                        else: trade_state.fibTargetLevelExit = np.nan\n                    else: trade_state.fibTargetLevelExit = np.nan\n                    df.loc[current_idx, 'signal'] = 'Short'; df.loc[current_idx, 'entry_price'] = trade_state.entry_price; df.loc[current_idx, 'stop_loss'] = trade_state.stopLossLevel; df.loc[current_idx, 'entry_signal_type'] = entry_signal_type\n\n            # --- III. Update Trailing Stop ---\n            if trade_state.position is not None and not exit_triggered_this_bar:\n                 trade_state.update_trailing_stop(current['low'], current['high'], current['atrVal']); df.loc[current_idx, 'trailing_stop'] = trade_state.stopLossLevel\n\n            # --- IV. Update Position State ---\n            if trade_state.position is not None and df.loc[current_idx, 'signal'] == 'Hold':\n                df.loc[current_idx, 'position'] = trade_state.position; df.loc[current_idx, 'entry_price'] = trade_state.entry_price\n\n        logger.info(\"Finished main processing loop\")\n        return df\n    except Exception as e: logger.error(f\"Error in process_signals: {str(e)}\", exc_info=True); raise\n\n\n# --- EnhancedSignalAnalyzer Class ---\n# (Keep the EnhancedSignalAnalyzer class definition as it was in pinescript_to_python_colab_with_analyzer)\nclass EnhancedSignalAnalyzer:\n    def __init__(self):\n        self.trade_history = []\n        self.summary_stats = defaultdict(float)\n        self.entry_stats = defaultdict(lambda: defaultdict(float))\n        self.exit_stats = defaultdict(lambda: defaultdict(float))\n        self.signal_stats = defaultdict(lambda: defaultdict(float))\n\n    def analyze_trades(self, df: pd.DataFrame):\n        logger.info(\"Analyzing generated trades for detailed statistics\")\n        try:\n            self.trade_history = []\n            current_trade = None\n            running_pnl = 0.0; peak_pnl = 0.0; max_drawdown = 0.0\n            win_pnls = []; loss_pnls = []\n            win_durations = []; loss_durations = []\n            risk_rewards = []\n            current_streak = 0; max_consec_wins = 0; max_consec_losses = 0\n            current_streak_type = None\n\n            for i in range(len(df)):\n                current_idx = df.index[i]\n                signal = df.loc[current_idx, 'signal']\n\n                if signal in ['Long', 'Short'] and current_trade is None:\n                    entry_price = df.loc[current_idx, 'entry_price']\n                    stop_loss = df.loc[current_idx, 'stop_loss']\n                    target_price_col = 'target_price_long' if signal == 'Long' else 'target_price_short'\n                    # Use .get for target price in case column doesn't exist (though it should)\n                    target_price = df.get(target_price_col, pd.Series(index=df.index, dtype=float)).loc[current_idx]\n                    if pd.notna(entry_price) and pd.notna(stop_loss):\n                        current_trade = {'entry_index': i, 'entry_idx_time': current_idx, 'entry_price': entry_price, 'position': signal, 'stop_loss': stop_loss, 'target_price': target_price, 'signal_type': df.loc[current_idx, 'entry_signal_type']}\n                        if current_trade['position'] == 'Long': risk = current_trade['entry_price'] - current_trade['stop_loss']; reward = current_trade['target_price'] - current_trade['entry_price'] if pd.notna(current_trade['target_price']) else np.nan\n                        else: risk = current_trade['stop_loss'] - current_trade['entry_price']; reward = current_trade['entry_price'] - current_trade['target_price'] if pd.notna(current_trade['target_price']) else np.nan\n                        current_trade['risk_at_entry'] = risk; current_trade['reward_at_entry'] = reward\n                        current_trade['risk_reward_ratio'] = reward / risk if risk > 0 and pd.notna(reward) else np.nan\n\n                elif current_trade and 'Exit' in signal:\n                    exit_price = df.loc[current_idx, 'exit_price']\n                    if pd.isna(exit_price): exit_price = df.loc[current_idx, 'close']; logger.warning(f\"Exit price NaN for trade entered on {current_trade['entry_idx_time'].date()}, using close price {exit_price:.2f}\")\n                    exit_idx_time = current_idx; exit_reason = df.loc[current_idx, 'exit_reason']\n                    if current_trade['position'] == 'Long': pnl_points = exit_price - current_trade['entry_price']\n                    else: pnl_points = current_trade['entry_price'] - exit_price\n                    commission = (current_trade['entry_price'] + exit_price) * PARAMS['backtest']['commission_pct']\n                    net_pnl_points = pnl_points - commission\n                    pct_change = (net_pnl_points / current_trade['entry_price']) * 100 if current_trade['entry_price'] else 0\n                    duration_delta = exit_idx_time - current_trade['entry_idx_time']; duration_bars = i - current_trade['entry_index']\n                    outcome = 'Win' if net_pnl_points > 0 else 'Loss'\n                    trade_record = {**current_trade, 'exit_idx_time': exit_idx_time, 'exit_price': exit_price, 'pnl_points': net_pnl_points, 'pct_change': pct_change, 'duration_delta': duration_delta, 'duration_bars': duration_bars, 'outcome': outcome, 'exit_reason': exit_reason}\n                    self.trade_history.append(trade_record)\n                    self.summary_stats['total_trades'] += 1; self.summary_stats['total_pnl'] += net_pnl_points\n                    if outcome == 'Win': self.summary_stats['winning_trades'] += 1; win_pnls.append(net_pnl_points); win_durations.append(duration_bars)\n                    else: self.summary_stats['losing_trades'] += 1; loss_pnls.append(abs(net_pnl_points)); loss_durations.append(duration_bars)\n                    if pd.notna(current_trade['risk_reward_ratio']): risk_rewards.append(current_trade['risk_reward_ratio'])\n                    if outcome == current_streak_type: current_streak += 1\n                    else: current_streak = 1; current_streak_type = outcome\n                    if outcome == 'Win': max_consec_wins = max(max_consec_wins, current_streak)\n                    else: max_consec_losses = max(max_consec_losses, current_streak)\n                    running_pnl += net_pnl_points; peak_pnl = max(peak_pnl, running_pnl); drawdown = peak_pnl - running_pnl\n                    self.summary_stats['max_drawdown_points'] = max(self.summary_stats.get('max_drawdown_points', 0.0), drawdown)\n                    pos = current_trade['position']; sig_type = current_trade['signal_type']; exit_type = exit_reason\n                    self.entry_stats[pos]['total'] += 1; self.entry_stats[pos]['total_pnl'] += net_pnl_points; self.entry_stats[pos]['total_duration_bars'] += duration_bars\n                    if outcome == 'Win': self.entry_stats[pos]['success'] += 1\n                    if exit_type == 'Trailing Stop' or exit_type == 'ATR Stop': self.entry_stats[pos]['sl_hit'] += 1\n                    if exit_type == 'Fib Target' or exit_type == 'Target': self.entry_stats[pos]['target_hit'] += 1\n                    self.exit_stats[exit_type]['total'] += 1; self.exit_stats[exit_type]['total_pnl'] += net_pnl_points; self.exit_stats[exit_type]['total_duration_bars'] += duration_bars\n                    if outcome == 'Win': self.exit_stats[exit_type]['success'] += 1\n                    self.signal_stats[sig_type]['total'] += 1; self.signal_stats[sig_type]['total_pnl'] += net_pnl_points\n                    if outcome == 'Win': self.signal_stats[sig_type]['success'] += 1\n                    current_trade = None\n\n            if self.summary_stats['total_trades'] > 0:\n                avg_win = np.mean(win_pnls) if win_pnls else 0; avg_loss = np.mean(loss_pnls) if loss_pnls else 0\n                self.summary_stats['win_rate'] = (self.summary_stats['winning_trades'] / self.summary_stats['total_trades']) * 100\n                self.summary_stats['avg_win_points'] = avg_win; self.summary_stats['avg_loss_points'] = avg_loss\n                self.summary_stats['profit_factor'] = abs(sum(win_pnls) / sum(loss_pnls)) if sum(loss_pnls) != 0 else np.inf\n                self.summary_stats['expectancy_points'] = (avg_win * (self.summary_stats['win_rate']/100)) - (avg_loss * (1 - self.summary_stats['win_rate']/100))\n                self.summary_stats['max_consec_wins'] = max_consec_wins; self.summary_stats['max_consec_losses'] = max_consec_losses\n                self.summary_stats['avg_win_duration_bars'] = np.mean(win_durations) if win_durations else 0\n                self.summary_stats['avg_loss_duration_bars'] = np.mean(loss_durations) if loss_durations else 0\n                self.summary_stats['avg_risk_reward_ratio'] = np.nanmean(risk_rewards) if risk_rewards else np.nan\n                health_score = min(100, max(0, (self.summary_stats['win_rate'] * 0.4) + (min(self.summary_stats['profit_factor'], 5) * 10 if pd.notna(self.summary_stats['profit_factor']) else 0) + (1 - (self.summary_stats['avg_loss_duration_bars']/self.summary_stats['avg_win_duration_bars'] if self.summary_stats['avg_win_duration_bars'] > 0 else 1) * 20) + (self.summary_stats['avg_risk_reward_ratio'] * 10 if pd.notna(self.summary_stats['avg_risk_reward_ratio']) else 0) ))\n                self.summary_stats['health_score'] = health_score\n\n            for pos in list(self.entry_stats.keys()):\n                if self.entry_stats[pos]['total'] > 0: self.entry_stats[pos]['avg_pnl'] = self.entry_stats[pos]['total_pnl'] / self.entry_stats[pos]['total']; self.entry_stats[pos]['avg_duration_bars'] = self.entry_stats[pos]['total_duration_bars'] / self.entry_stats[pos]['total']; self.entry_stats[pos]['win_rate'] = (self.entry_stats[pos]['success'] / self.entry_stats[pos]['total']) * 100; self.entry_stats[pos]['sl_rate'] = (self.entry_stats[pos]['sl_hit'] / self.entry_stats[pos]['total']) * 100; self.entry_stats[pos]['target_rate'] = (self.entry_stats[pos]['target_hit'] / self.entry_stats[pos]['total']) * 100\n            for exit_type in list(self.exit_stats.keys()):\n                 if self.exit_stats[exit_type]['total'] > 0: self.exit_stats[exit_type]['avg_pnl'] = self.exit_stats[exit_type]['total_pnl'] / self.exit_stats[exit_type]['total']; self.exit_stats[exit_type]['avg_duration_bars'] = self.exit_stats[exit_type]['total_duration_bars'] / self.exit_stats[exit_type]['total']; self.exit_stats[exit_type]['win_rate'] = (self.exit_stats[exit_type]['success'] / self.exit_stats[exit_type]['total']) * 100\n            for sig_type in list(self.signal_stats.keys()):\n                 if self.signal_stats[sig_type]['total'] > 0: self.signal_stats[sig_type]['avg_pnl'] = self.signal_stats[sig_type]['total_pnl'] / self.signal_stats[sig_type]['total']; self.signal_stats[sig_type]['win_rate'] = (self.signal_stats[sig_type]['success'] / self.signal_stats[sig_type]['total']) * 100\n\n            logger.info(\"Finished analyzing trades.\")\n            return df # Return the df passed in (analysis is stored in object)\n        except Exception as e:\n            logger.error(f\"Error in analyze_trades: {str(e)}\", exc_info=True)\n            raise\n\n    def print_summary(self):\n        if not self.summary_stats or self.summary_stats['total_trades'] == 0:\n             print(\"\\nNo trades to summarize.\")\n             logger.info(\"No trades to summarize.\")\n             return\n        try:\n            summary = [ f\"\\n=== ENHANCED TRADE SUMMARY ===\", f\"Total Trades: {int(self.summary_stats['total_trades'])}\", f\"Winning Trades: {int(self.summary_stats['winning_trades'])} ({self.summary_stats['win_rate']:.1f}%)\", f\"Losing Trades: {int(self.summary_stats['losing_trades'])}\", f\"Total P&L (Points): {self.summary_stats['total_pnl']:.2f}\", f\"Profit Factor: {self.summary_stats['profit_factor']:.2f}\", f\"Expectancy (Points): {self.summary_stats['expectancy_points']:.2f}\", f\"Max Drawdown (Points): {self.summary_stats['max_drawdown_points']:.2f}\", f\"Avg Win / Avg Loss (Points): {self.summary_stats['avg_win_points']:.2f} / {self.summary_stats['avg_loss_points']:.2f}\", f\"Max Consecutive Wins: {int(self.summary_stats['max_consec_wins'])}\", f\"Max Consecutive Losses: {int(self.summary_stats['max_consec_losses'])}\", f\"Avg Win Duration (Bars): {self.summary_stats['avg_win_duration_bars']:.1f}\", f\"Avg Loss Duration (Bars): {self.summary_stats['avg_loss_duration_bars']:.1f}\", f\"Avg Risk/Reward Ratio (at Entry): {self.summary_stats['avg_risk_reward_ratio']:.2f}:1\" if pd.notna(self.summary_stats['avg_risk_reward_ratio']) else \"N/A\", f\"Strategy Health Score: {self.summary_stats['health_score']:.1f}/100\", \"\\n=== ENTRY STATISTICS ===\", \"Position | Total | Win % | Avg P&L | Avg Dur | SL % | Target %\", \"-------------------------------------------------------------\"]\n            for position, stats in self.entry_stats.items(): summary.append(f\"{position:8} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f} | {stats['avg_duration_bars']:7.1f} | {stats['sl_rate']:4.1f}% | {stats['target_rate']:6.1f}%\")\n            summary.extend([\"\\n=== EXIT STATISTICS ===\", \"Exit Type           | Total | Win % | Avg P&L | Avg Dur\", \"------------------------------------------------------\"])\n            for exit_type, stats in sorted(self.exit_stats.items()): summary.append(f\"{str(exit_type):19} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f} | {stats['avg_duration_bars']:7.1f}\")\n            summary.extend([\"\\n=== SIGNAL TYPE STATISTICS ===\", \"Signal Type          | Total | Win % | Avg P&L\", \"---------------------------------------------\"])\n            for signal_type, stats in sorted(self.signal_stats.items()):\n                 if not signal_type: continue\n                 summary.append(f\"{str(signal_type):20} | {int(stats['total']):5} | {stats['win_rate']:5.1f}% | {stats['avg_pnl']:7.2f}\")\n\n            print(\"\\n\".join(summary)); logger.info(\"\\n\".join(summary))\n            health = self.summary_stats['health_score']\n            if health >= 70: health_indicator = \" STRONG\"\n            elif health >= 50: health_indicator = \" MODERATE\"\n            else: health_indicator = \" WEAK\"\n            print(f\"\\nStrategy Health: {health_indicator}\")\n            if self.summary_stats['total_trades'] < 30: print(\"  Warning: Low sample size (<30 trades)\")\n        except Exception as e:\n            logger.error(f\"Error printing summary: {str(e)}\", exc_info=True)\n            raise\n\n\n# --- Plotting Function ---\ndef plot_signals(df: pd.DataFrame, save_path: Optional[Path] = None):\n    # (Keep plotting function as is from pinescript_to_python_colab)\n    logger.info(\"Generating signal plot\")\n    plt.style.use('seaborn-v0_8-darkgrid')\n    fig, axes = plt.subplots(4, 1, sharex=True, figsize=(20, 15))\n    if df.empty: logger.warning(\"Plotting skipped: DataFrame is empty.\"); return\n\n    ax1 = axes[0] # Price Chart\n    ax1.plot(df['close'], label='Price', color='black', alpha=0.9, linewidth=1.0)\n    if 'emaFast' in df.columns: ax1.plot(df['emaFast'], label=f\"EMA Fast\", alpha=0.6, linewidth=0.8)\n    if 'emaMed' in df.columns: ax1.plot(df['emaMed'], label=f\"EMA Med\", alpha=0.6, linewidth=0.8)\n    if 'emaSlow' in df.columns: ax1.plot(df['emaSlow'], label=f\"EMA Slow\", alpha=0.6, linewidth=0.8)\n    if 'bbMiddle' in df.columns: ax1.plot(df['bbMiddle'], label='BB Mid', color='grey', linestyle='--', alpha=0.7, linewidth=0.8)\n    if 'bbUpper' in df.columns: ax1.plot(df['bbUpper'], label='BB Upper', color='grey', linestyle=':', alpha=0.5, linewidth=0.8)\n    if 'bbLower' in df.columns: ax1.plot(df['bbLower'], label='BB Lower', color='grey', linestyle=':', alpha=0.5, linewidth=0.8)\n\n    long_entries = df[df['signal'] == 'Long']; short_entries = df[df['signal'] == 'Short']\n    long_exits = df[df['signal'].str.contains('Exit Long', na=False)]; short_exits = df[df['signal'].str.contains('Exit Short', na=False)]\n    if not long_entries.empty: ax1.scatter(long_entries.index, long_entries['entry_price'], marker='^', color='lime', s=100, label='Long Entry', zorder=5, edgecolors='black')\n    if not short_entries.empty: ax1.scatter(short_entries.index, short_entries['entry_price'], marker='v', color='red', s=100, label='Short Entry', zorder=5, edgecolors='black')\n    exit_long_prices = long_exits['exit_price'].fillna(long_exits['close']); exit_short_prices = short_exits['exit_price'].fillna(short_exits['close'])\n    if not long_exits.empty: ax1.scatter(long_exits.index, exit_long_prices, marker='x', color='fuchsia', s=80, label='Exit', zorder=5)\n    if not short_exits.empty: ax1.scatter(short_exits.index, exit_short_prices, marker='x', color='fuchsia', s=80, zorder=5)\n    if 'trailing_stop' in df.columns: ax1.plot(df['trailing_stop'], label='Trailing Stop', linestyle='--', color='purple', alpha=0.7, linewidth=1.0)\n    # Add plot for Fib Target if needed (requires storing it in df)\n    ax1.legend(loc='upper left'); ax1.set_title('Price, Indicators, Signals & Stops'); ax1.set_ylabel('Price'); ax1.grid(True, which='both', linestyle=':', linewidth=0.5)\n\n    ax_score = axes[1] # Score Chart\n    if 'scaled_score' in df.columns:\n        ax_score.plot(df['scaled_score'], label='Scaled Score (0-10)', color='teal', linewidth=1.5)\n        ax_score.axhline(5.0, color='grey', linestyle='--', alpha=0.7)\n        ax_score.set_ylim(0, 10); ax_score.legend(loc='upper left'); ax_score.set_title('Confidence Score'); ax_score.set_ylabel('Score'); ax_score.grid(True, which='both', linestyle=':', linewidth=0.5)\n    else: ax_score.set_title('Confidence Score (Not Calculated)'); ax_score.grid(True)\n\n    ax_rsi = axes[2] # RSI Chart\n    if 'priceRsi' in df.columns:\n        ax_rsi.plot(df['priceRsi'], label='RSI', color='orange', linewidth=1.0)\n        ax_rsi.axhline(50, linestyle='--', color='gray', alpha=0.5); ax_rsi.axhline(PARAMS['rsi']['rsiBuyLevel'], linestyle=':', color='green', alpha=0.4); ax_rsi.axhline(PARAMS['rsi']['rsiSellLevel'], linestyle=':', color='red', alpha=0.4)\n        if 'bullish_rsi_div' in df.columns and 'bearish_rsi_div' in df.columns:\n            bull_div = df[df['bullish_rsi_div']]; bear_div = df[df['bearish_rsi_div']]\n            if not bull_div.empty: ax_rsi.scatter(bull_div.index, bull_div['priceRsi'] * 0.98, marker='^', color='cyan', s=50, label='Bullish Div', zorder=5)\n            if not bear_div.empty: ax_rsi.scatter(bear_div.index, bear_div['priceRsi'] * 1.02, marker='v', color='magenta', s=50, label='Bearish Div', zorder=5)\n        ax_rsi.legend(loc='upper left'); ax_rsi.set_title('RSI & Divergence'); ax_rsi.set_ylabel('RSI'); ax_rsi.grid(True, which='both', linestyle=':', linewidth=0.5)\n    else: ax_rsi.set_title('RSI (Not Calculated)'); ax_rsi.grid(True)\n\n    ax_macd = axes[3] # MACD Chart\n    if 'macdLine' in df.columns and 'signalLine' in df.columns and 'histLine' in df.columns:\n        ax_macd.plot(df['macdLine'], label='MACD', color='blue', linewidth=1.0); ax_macd.plot(df['signalLine'], label='Signal', color='red', alpha=0.8, linewidth=1.0)\n        colors = ['g' if v >= 0 else 'r' for v in df['histLine']]; ax_macd.bar(df.index, df['histLine'], label='Histogram', color=colors, alpha=0.5)\n        ax_macd.axhline(0, linestyle='--', color='gray', alpha=0.5); ax_macd.legend(loc='upper left'); ax_macd.set_title('MACD'); ax_macd.set_ylabel('MACD'); ax_macd.grid(True, which='both', linestyle=':', linewidth=0.5)\n    else: ax_macd.set_title('MACD (Not Calculated)'); ax_macd.grid(True)\n\n    axes[-1].tick_params(axis='x', rotation=45)\n    plt.xlabel('Date')\n    plt.tight_layout(rect=[0, 0.03, 1, 0.97])\n    fig.suptitle('PineScript Strategy Backtest', fontsize=16)\n\n    if save_path: plt.savefig(save_path, dpi=150); logger.info(f\"Saved signal plot to {save_path}\")\n    else: plt.show()\n    plt.close(fig)\n\n# --- Command Line Argument Parsing ---\ndef parse_args():\n    # Kept for potential local execution, but not used directly in Colab run block\n    parser = argparse.ArgumentParser(description='Run PineScript-like strategy backtest.')\n    parser.add_argument('--input', type=str, default=str(DEFAULT_INPUT_FILE), help=f'Input RAW OHLCV CSV (default: {DEFAULT_INPUT_FILE})')\n    parser.add_argument('--output', type=str, default=str(DEFAULT_OUTPUT_FILE), help=f'Output CSV (default: {DEFAULT_OUTPUT_FILE})')\n    parser.add_argument('--plot', type=str, default=str(DEFAULT_PLOT_FILE), help=f'Plot image path (default: {DEFAULT_PLOT_FILE})')\n    parser.add_argument('--no-plot', action='store_true', help='Disable generating plot')\n    parser.add_argument('--full-history', action='store_true', help='Run on full history')\n    return parser.parse_args()\n\n# --- Main Execution Block ---\nif __name__ == \"__main__\":\n\n    # --- Define Paths and Options Directly for Colab ---\n    # V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V\n    # EDIT THESE LINES FOR YOUR COLAB SETUP:\n    input_file = Path('/content/nifty_ohlcv.csv') # <-- CHANGE 'nifty_ohlcv.csv' TO YOUR UPLOADED RAW OHLCV FILE NAME\n    output_file = Path('/content/pinescript_strategy_analyzer_output.csv') # Output file path in Colab\n    plot_file = Path('/content/pinescript_strategy_analyzer_plot.png') # Plot file path in Colab\n    run_no_plot = False # Set to True if you DON'T want the plot image saved\n    run_full_history = False # Set to True if you want to use ALL data, False for last month\n    # ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^\n\n    try:\n        output_file.parent.mkdir(parents=True, exist_ok=True)\n        if not run_no_plot: plot_file.parent.mkdir(parents=True, exist_ok=True)\n\n        logger.info(f\"Loading data from {input_file}\")\n        if not input_file.exists(): raise FileNotFoundError(f\"Input file not found: {input_file}. Make sure you uploaded it and the path is correct.\")\n        df_raw = pd.read_csv(input_file, parse_dates=['datetime'], index_col='datetime')\n        if df_raw.empty: raise pd.errors.EmptyDataError(\"Input file is empty.\")\n        required_ohlcv = ['open', 'high', 'low', 'close', 'volume']\n        if not all(col in df_raw.columns for col in required_ohlcv): raise ValueError(f\"Input CSV must contain OHLCV columns: {', '.join(required_ohlcv)}\")\n\n        logger.info(\"Calculating all indicators...\")\n        calculator = IndicatorCalculator()\n        df_with_indicators = calculator.calculate_all_indicators(df_raw)\n        logger.info(f\"Indicators calculated. DataFrame shape: {df_with_indicators.shape}\")\n        if df_with_indicators.empty:\n             logger.warning(\"DataFrame empty after indicator calculation. Exiting.\")\n             sys.exit(0)\n\n        # --- Filter Data ---\n        df_processed = df_with_indicators # Start with indicator df\n        if PARAMS['backtest']['filter_last_month'] and not run_full_history:\n            if not df_processed.empty:\n                last_date = df_processed.index.max(); one_month_prior = last_date - pd.DateOffset(months=1)\n                df = df_processed.loc[one_month_prior:].copy()\n                if df.empty: logger.warning(\"DataFrame empty after filtering for last month.\")\n                else: logger.info(f\"Filtered data from {df.index.min().date()} to {df.index.max().date()}.\")\n            else: df = df_processed\n        else: df = df_processed.copy(); logger.info(f\"Using full data history from {df.index.min().date()} to {df.index.max().date()}.\")\n\n        if df.empty:\n             logger.warning(\"DataFrame empty after filtering. Skipping signal processing.\")\n             df_final = df # Keep df empty\n             analyzer = None\n        else:\n            logger.info(\"Processing signals based on PineScript logic...\")\n            df_final = process_signals(df) # Generate signals\n\n            # --- ADDED: Analyze Trades using Enhanced Analyzer ---\n            logger.info(\"Analyzing trades...\")\n            analyzer = EnhancedSignalAnalyzer() # Instantiate analyzer\n            analyzer.analyze_trades(df_final) # Analyze the processed df\n            analyzer.print_summary() # Print detailed stats\n            # --- End Added Section ---\n\n        logger.info(f\"Saving results to {output_file}\")\n        df_final.to_csv(output_file) # Save df with signals & indicators\n\n        # --- Plotting ---\n        if not run_no_plot and not df_final.empty:\n            plot_signals(df_final, plot_file)\n        elif not run_no_plot and df_final.empty:\n             logger.warning(\"Plotting skipped as no data.\")\n\n        logger.info(\"Processing completed successfully\")\n        # sys.exit(0) # Use return or just finish in Colab\n\n    except FileNotFoundError as e: logger.error(str(e))#; sys.exit(1)\n    except pd.errors.EmptyDataError as e: logger.error(f\"Input file '{input_file}' empty/corrupt.\")#; sys.exit(1)\n    except ValueError as e: logger.error(f\"Data validation error: {str(e)}\")#; sys.exit(1)\n    except Exception as e: logger.error(f\"Unexpected error: {str(e)}\", exc_info=True)#; sys.exit(1)","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}