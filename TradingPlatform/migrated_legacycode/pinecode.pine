// © Trading Legend (Range Levels Part)
//@version=6
indicator(
     title="Consolidated Strategy with Range Levels [v1.26]", 
     shorttitle="ConRL v1.26", 
     overlay=true, 
     max_lines_count=500, // Increased for Range Levels
     max_labels_count=500  // Increased for Range Levels
     )

// === CONSOLIDATED STRATEGY INPUTS ===

// --- Core Entry & Exit ---
grpCore = "CORE STRATEGY SETTINGS"
exitScoreDropThreshold = input.float(1.5, "Exit on Score Drop Threshold", minval=0.1, maxval=5.0, step=0.1, group=grpCore, 
  tooltip="Exit if score drops below (5.0 - Threshold) for longs or above (5.0 + Threshold) for shorts")
useFibBounceEntry = input.bool(true, "Use Fib 0.5-0.618 Bounce Entry (Long)", group=grpCore, 
  tooltip="Generate BUY signal on upward bounce from 0.5-0.618 Fib in uptrend")
useFibBounceSell = input.bool(true, "Use Fib 0.5-0.382 Bounce Entry (Short)", group=grpCore, 
  tooltip="Generate SELL signal on downward bounce from 0.5-0.382 Fib in downtrend") 
fibBounceLookback = input.int(3, "Fib Bounce Price Lookback Bars", minval=1, maxval=10, group=grpCore, 
  tooltip="Bars back to check for Fib zone touch")
useEmaBounceBuy = input.bool(true, title="Use EMA Bounce Entry (Long)?", group=grpCore)
useEmaBounceSell = input.bool(true, title="Use EMA Bounce Entry (Short)?", group=grpCore)
emaBounceLookback = input.int(2, title="EMA Bounce Price Lookback Bars", minval=1, maxval=5, group=grpCore)
emaBounceSource = input.string("Fast EMA", title="EMA Source for Bounce", options=["Fast EMA", "Medium EMA"], group=grpCore)
useBbMidBounceBuy = input.bool(true, title="Use BB Mid Bounce Entry (Long)?", group=grpCore)
useBbMidBounceSell = input.bool(true, title="Use BB Mid Bounce Entry (Short)?", group=grpCore)
bbBounceLookback = input.int(2, title="BB Mid Bounce Price Lookback Bars", minval=1, maxval=5, group=grpCore)
useVolBreakoutBuy = input.bool(true, title="Use Volume Breakout Entry (Long)?", group=grpCore)
useVolBreakoutSell = input.bool(true, title="Use Volume Breakout Entry (Short)?", group=grpCore)

// --- EMAs ---
grpEMA = "STRATEGY: EMA Settings"
emaFastLen = input.int(9, "Fast EMA Length", minval=1, group=grpEMA)
emaMedLen = input.int(14, "Medium EMA Length", minval=1, group=grpEMA)
emaSlowLen = input.int(21, "Slow EMA Length", minval=1, group=grpEMA)
useEmaExit = input.bool(true, "Use Fast/Med EMA Cross for Exit", group=grpEMA)

// --- Bollinger Bands ---
grpBB = "STRATEGY: Bollinger Bands Settings"
showBB = input.bool(true, "Show Bollinger Bands", group=grpBB)
bbLen = input.int(20, "BB Length", minval=1, group=grpBB)
bbStdDev = input.float(2.0, "BB StdDev Multiplier", minval=0.1, group=grpBB)
bbColor = input.color(color.new(color.gray, 70), "BB Color", group=grpBB)
useBBReturnExit = input.bool(true, "Use BB Return to Mean for Exit", group=grpBB)

// --- RSI ---
grpRSI = "STRATEGY: RSI Settings"
rsiLen = input.int(14, "RSI Length", minval=1, group=grpRSI)
rsiBuyLevel = input.float(55.0, "RSI Buy Threshold (>)", group=grpRSI)
rsiSellLevel = input.float(45.0, "RSI Sell Threshold (<)", group=grpRSI)
useRsiDivExit = input.bool(false, "Use RSI Divergence Exit", group=grpRSI, 
  tooltip="Exit on RSI divergence (lower high/higher low)")
rsiConfirmFibBounce = input.bool(true, "Require RSI Confirmation for Fib Bounce", group=grpRSI, 
  tooltip="Long: RSI>40 Rising. Short: RSI<60 Falling")
rsiConfirmEmaBounce = input.bool(false, title="Require RSI Confirmation for EMA Bounce?", group=grpRSI) 
rsiConfirmBbBounce = input.bool(false, title="Require RSI Confirmation for BB Bounce?", group=grpRSI) 

// --- MACD ---
grpMACD = "STRATEGY: MACD Settings"
macdFastLen = input.int(12, "MACD Fast Length", group=grpMACD)
macdSlowLen = input.int(26, "MACD Slow Length", group=grpMACD)
macdSignalLen = input.int(9, "MACD Signal Length", group=grpMACD)

// --- Volume ---
grpVol = "STRATEGY: Volume Settings"
volMALen = input.int(50, "Volume MA Length", minval=1, group=grpVol)
volMultiplier = input.float(1.5, "Volume Breakout Multiplier (> MA)", group=grpVol)
useVolFadeExit = input.bool(true, "Use Low Volume Pullback Exit", group=grpVol)

// --- ATR Stop Loss ---
grpATR = "STRATEGY: ATR Stop Loss"
useAtrStop = input.bool(true, "Use ATR Stop Loss for Exit", group=grpATR)
atrLen = input.int(14, "ATR Length", minval=1, group=grpATR)
atrMult = input.float(2.0, "ATR Multiplier", minval=0.1, group=grpATR)

// --- Fibonacci EXIT Target ---
grpFibExit = "STRATEGY: Fibonacci Exit Target"
useFibExit = input.bool(true, "Use Fib Extension Exit Target", group=grpFibExit)
fibLookbackExit = input.int(30, "Fib Exit Swing Lookback", minval=5, group=grpFibExit, 
  tooltip="Bars back from entry to find swing point")
fibExtensionLevel = input.float(1.618, "Fib Extension Target", minval=0.1, group=grpFibExit)

// --- Auto Fibonacci RETRACEMENT ---
grpFibRet = "STRATEGY: Auto Fib Retracement"
showAutoFib = input.bool(true, "Show Auto Fib Retracement", group=grpFibRet)
fibPivotLookback = input.int(15, "Pivot Lookback (Left/Right Bars)", minval=2, group=grpFibRet)
fibMaxBars = input.int(200, "Max Bars Back for Pivots", minval=20, group=grpFibRet)
fibLineColor = input.color(color.new(color.gray, 50), "Fib Line Color", group=grpFibRet)
fibLineWidth = input.int(1, "Fib Line Width", minval=1, group=grpFibRet)

// --- Trend / Market Condition Filters ---
grpFilter = "STRATEGY: Trend Filters"
useEmaTrendFilter = input.bool(true, "Require EMA Trend (Med > Slow)", group=grpFilter)
useAdxFilter = input.bool(true, "Use ADX Filter", group=grpFilter)
adxLen = input.int(14, "ADX Length", minval=1, group=grpFilter)
adxThreshold = input.float(20.0, "ADX Trend Strength Threshold (>)", minval=0, group=grpFilter)
useAdxDirectionFilter = input.bool(true, "Require ADX Direction (DI+ vs DI-)", group=grpFilter)
useHtfFilter = input.bool(false, "Use Higher Timeframe EMA Filter", group=grpFilter)
htf = input.timeframe("60", "Higher Timeframe for Filter", group=grpFilter)
htfEmaLen = input.int(50, "HTF EMA Length", group=grpFilter)

// --- SCORE CALCULATION WEIGHTS ---
grpScore = "STRATEGY: Confidence Score Weights"
wEmaTrend = input.int(2, "Weight: EMA Trend", group=grpScore, minval=0)
wEmaSignal = input.int(1, "Weight: EMA Cross Signal", group=grpScore, minval=0)
wRsiThresh = input.int(1, "Weight: RSI Threshold", group=grpScore, minval=0)
wMacdSignal = input.int(1, "Weight: MACD Signal Cross", group=grpScore, minval=0)
wMacdZero = input.int(1, "Weight: MACD Zero Cross", group=grpScore, minval=0)
wVolBreak = input.int(1, "Weight: Volume Breakout", group=grpScore, minval=0)
wAdxStrength = input.int(1, "Weight: ADX Strength", group=grpScore, minval=0)
wAdxDirection = input.int(1, "Weight: ADX Direction", group=grpScore, minval=0)
wHtfTrend = input.int(2, "Weight: HTF Trend", group=grpScore, minval=0)
wFibBounce = input.int(2, "Weight: Fib Bounce Signal", group=grpScore, minval=0) 
wEmaBounce = input.int(1, "Weight: EMA Bounce Signal", group=grpScore, minval=0) 
wBbBounce = input.int(1, "Weight: BB Mid Bounce Signal", group=grpScore, minval=0) 

// === RANGE LEVELS INPUTS ===
grpRangeLevels = "RANGE LEVELS SETTINGS"

// Input Parameters for multiplying factor and ratio
rangeAnchorIn = input.string(title="Timeframe‏  ‏  ‏  ‏", defval="Daily", options=["Auto", "Daily", "Weekly", "Monthly", "Quarterly", "Yearly"], group=grpRangeLevels, inline="RL_Factor")
maxHistoricalRangeIn = input.int(title="‏  ‏  ‏  ‏  ‏  ‏History", defval=10, minval=1, maxval=200, group=grpRangeLevels, inline="RL_Factor") 

rangeFactor  = input.float(title="Range Factor", defval=3.07, minval=1.000, maxval=9.999, step=0.010, group=grpRangeLevels, inline = "RL_Range")
splitRangeIn = input.string(title="‏  ‏  ‏  ‏  ‏  ‏  ‏Range ", defval="Full", options=["Full", "Half", "One Third", "Quarter"], group=grpRangeLevels, inline = "RL_Range")

lineStyle = input.string("Dotted", "‏  ‏  ‏  Style‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ‏  ", options=["Dotted", "Dashed", "Line"], group=grpRangeLevels, inline="RL_style") // Removed display = display.data_window
linewidthInput = input.int(title="‏  ‏  ‏  ‏  ‏  ‏  ‏Wdth‏  ‏", defval=1, minval=1, maxval=100, group=grpRangeLevels, inline = "RL_style") // Removed display = display.data_window
showLabelsInput = input.bool(title="Show Labels‏  ‏  ‏  ‏  ‏  ‏", defval=true, group=grpRangeLevels, inline="RL_show") // Removed display = display.data_window
showPricesInput = input.bool(title="Show Prices‏  ‏  ‏  ‏  ‏  ‏", defval=false, group=grpRangeLevels, inline="RL_show") // Removed display = display.data_window
positionLabelsInput = input.string("Left", " ", options=["Left", "Right"], group=grpRangeLevels, inline="RL_show")

// Color Inputs (grouped for tidiness in UI)
grpRLColors = "RANGE LEVELS: Colors"
colorP0=color.rgb(200, 250, 200)
colorS1=color.rgb(185, 250, 185)
colorS2=color.rgb(170, 250, 170)
colorS3=color.rgb(155, 250, 155)
colorS4=color.rgb(140, 250, 140)
colorS5=color.rgb(125, 250, 125)
colorS6=color.rgb(110, 250, 110)
colorS7=color.rgb(095, 250, 095)
colorS8=color.rgb(080, 225, 080)
colorS0=color.rgb(065, 175, 065)
colorS9=color.rgb(050, 200, 050)
colorR1=color.rgb(255, 175, 175)
colorR2=color.rgb(255, 160, 160)
colorR3=color.rgb(255, 145, 145)
colorR4=color.rgb(255, 130, 130)
colorR5=color.rgb(255, 115, 115)
colorR6=color.rgb(225, 100, 100)
colorR7=color.rgb(200, 085, 085)
colorR8=color.rgb(175, 070, 070)
colorR9=color.rgb(175, 055, 055)
colorR0=color.rgb(255, 040, 040)

pShowInput = input.bool(true, "O", inline="RL_L1", group=grpRLColors)
pColorInput = input.color(colorP0, "", inline="RL_L1", group=grpRLColors)
s1ShowInput = input.bool(true, "S1", inline="RL_L1", group=grpRLColors)
s1ColorInput = input.color(colorS1, "", inline="RL_L1", group=grpRLColors)
r1ShowInput = input.bool(true, "R1", inline="RL_L1", group=grpRLColors)
r1ColorInput = input.color(colorR1, "", inline="RL_L1", group=grpRLColors)

s2ShowInput = input.bool(true, "S2", inline="RL_L2", group=grpRLColors)
s2ColorInput = input.color(colorS2, "", inline="RL_L2", group=grpRLColors)
s3ShowInput = input.bool(true, "S3", inline="RL_L2", group=grpRLColors)
s3ColorInput = input.color(colorS3, "", inline="RL_L2", group=grpRLColors)
s4ShowInput = input.bool(true, "S4", inline="RL_L2", group=grpRLColors)
s4ColorInput = input.color(colorS4, "", inline="RL_L2", group=grpRLColors)

r2ShowInput = input.bool(true, "R2", inline="RL_L3", group=grpRLColors)
r2ColorInput = input.color(colorR2, "", inline="RL_L3", group=grpRLColors)
r3ShowInput = input.bool(true, "R3", inline="RL_L3", group=grpRLColors)
r3ColorInput = input.color(colorR3, "", inline="RL_L3", group=grpRLColors)
r4ShowInput = input.bool(true, "R4", inline="RL_L3", group=grpRLColors)
r4ColorInput = input.color(colorR4, "", inline="RL_L3", group=grpRLColors)

s5ShowInput = input.bool(false, "S5", inline="RL_L4", group=grpRLColors)
s5ColorInput = input.color(colorS5, "", inline="RL_L4", group=grpRLColors)
s6ShowInput = input.bool(false, "S6", inline="RL_L4", group=grpRLColors)
s6ColorInput = input.color(colorS6, "", inline="RL_L4", group=grpRLColors)
s7ShowInput = input.bool(false, "S7", inline="RL_L4", group=grpRLColors)
s7ColorInput = input.color(colorS7, "", inline="RL_L4", group=grpRLColors)

r5ShowInput = input.bool(false, "R5", inline="RL_L5", group=grpRLColors)
r5ColorInput = input.color(colorR5, "", inline="RL_L5", group=grpRLColors)
r6ShowInput = input.bool(false, "R6", inline="RL_L5", group=grpRLColors)
r6ColorInput = input.color(colorR6, "", inline="RL_L5", group=grpRLColors)
r7ShowInput = input.bool(false, "R7", inline="RL_L5", group=grpRLColors)
r7ColorInput = input.color(colorR7, "", inline="RL_L5", group=grpRLColors)

s8ShowInput = input.bool(false, "S8", inline="RL_L6", group=grpRLColors)
s8ColorInput = input.color(colorS8, "", inline="RL_L6", group=grpRLColors) // Corrected S8 color
s9ShowInput = input.bool(false, "S9", inline="RL_L6", group=grpRLColors)
s9ColorInput = input.color(colorS9, "", inline="RL_L6", group=grpRLColors) // Corrected S9 color
s0ShowInput = input.bool(false, "S0", inline="RL_L6", group=grpRLColors)
s0ColorInput = input.color(colorS0, "", inline="RL_L6", group=grpRLColors) // Corrected S0 color

r8ShowInput = input.bool(false, "R8", inline="RL_L7", group=grpRLColors)
r8ColorInput = input.color(colorR8, "", inline="RL_L7", group=grpRLColors) // Corrected R8 color
r9ShowInput = input.bool(false, "R9", inline="RL_L7", group=grpRLColors)
r9ColorInput = input.color(colorR9, "", inline="RL_L7", group=grpRLColors) // Corrected R9 color
r0ShowInput = input.bool(false, "R0", inline="RL_L7", group=grpRLColors)
r0ColorInput = input.color(colorR0, "", inline="RL_L7", group=grpRLColors) // Corrected R0 color


// === CONSOLIDATED STRATEGY CALCULATIONS ===

// --- Indicators ---
emaFast = ta.ema(close, emaFastLen)
emaMed = ta.ema(close, emaMedLen)
emaSlow = ta.ema(close, emaSlowLen)
[bbMiddle, bbUpper, bbLower] = ta.bb(close, bbLen, bbStdDev)
priceRsi = ta.rsi(close, rsiLen)
[macdLine, signalLine, histLine] = ta.macd(close, macdFastLen, macdSlowLen, macdSignalLen)
volMA = ta.sma(volume, volMALen)
atrVal = ta.atr(atrLen)
[diPos, diNeg, adxVal] = ta.dmi(adxLen, adxLen)
htfEma = request.security(syminfo.tickerid, htf, ta.ema(close, htfEmaLen), lookahead=barmerge.lookahead_off) // lookahead=off for strategy component
lowestForFibExit = ta.lowest(low, fibLookbackExit)[1]
highestForFibExit = ta.highest(high, fibLookbackExit)[1]

// --- Basic Conditions ---
condEmaFastSlowCrossBuy = ta.crossover(emaFast, emaSlow)
condEmaFastSlowCrossSell = ta.crossunder(emaFast, emaSlow)
condEmaFastMedCrossBuy = ta.crossover(emaFast, emaMed)
condEmaFastMedCrossSell = ta.crossunder(emaFast, emaMed)
condBbReturnMeanBuy = ta.crossover(close, bbMiddle) 
condBbReturnMeanSell = ta.crossunder(close, bbMiddle) 
condRsiBuy = priceRsi > rsiBuyLevel
condRsiSell = priceRsi < rsiSellLevel
condMacdSignalCrossBuy = ta.crossover(macdLine, signalLine)
condMacdSignalCrossSell = ta.crossunder(macdLine, signalLine)
condMacdZeroCrossBuy = ta.crossover(macdLine, 0)
condMacdZeroCrossSell = ta.crossunder(macdLine, 0)
condHighVol = volume > volMA * volMultiplier
condVolBreakoutBuy = condHighVol and close > open and close > emaSlow 
condVolBreakoutSell = condHighVol and close < open and close < emaSlow 
condVolFadeLong = close < emaFast and volume < volMA 
condVolFadeShort = close > emaFast and volume < volMA 

// --- Filter Conditions ---
condEmaTrendOkBuy = not useEmaTrendFilter or emaMed > emaSlow
condEmaTrendOkSell = not useEmaTrendFilter or emaMed < emaSlow
condAdxStrengthOk = not useAdxFilter or adxVal > adxThreshold
condAdxDirectionOkBuy = not useAdxDirectionFilter or diPos > diNeg
condAdxDirectionOkSell = not useAdxDirectionFilter or diNeg > diPos
condAdxFilterOkBuy = condAdxStrengthOk and condAdxDirectionOkBuy
condAdxFilterOkSell = condAdxStrengthOk and condAdxDirectionOkSell
condHtfFilterOkBuy = not useHtfFilter or close > htfEma
condHtfFilterOkSell = not useHtfFilter or close < htfEma

allFiltersOkBuy = condEmaTrendOkBuy and condAdxFilterOkBuy and condHtfFilterOkBuy
allFiltersOkSell = condEmaTrendOkSell and condAdxFilterOkSell and condHtfFilterOkSell

// --- Auto Fibonacci Retracement Calculation ---
var float lastPivotHighPrice = na
var int lastPivotHighBar = na
var float lastPivotLowPrice = na 
var int lastPivotLowBar = na 
pivotHighVal = ta.pivothigh(high, fibPivotLookback, fibPivotLookback)
pivotLowVal = ta.pivotlow(low, fibPivotLookback, fibPivotLookback)
if not na(pivotHighVal)
    pivotHighBarIndex = bar_index[fibPivotLookback] 
    if na(lastPivotHighBar) or pivotHighBarIndex > lastPivotHighBar or pivotHighVal > nz(lastPivotHighPrice, -999999)
        lastPivotHighPrice := pivotHighVal
        lastPivotHighBar := pivotHighBarIndex
if not na(pivotLowVal)
    pivotLowBarIndex = bar_index[fibPivotLookback]
    if na(lastPivotLowBar) or pivotLowBarIndex > lastPivotLowBar or pivotLowVal < nz(lastPivotLowPrice, 999999)
        lastPivotLowPrice := pivotLowVal
        lastPivotLowBar := pivotLowBarIndex
if bar_index - nz(lastPivotHighBar) > fibMaxBars
    lastPivotHighPrice := na
    lastPivotHighBar := na
if bar_index - nz(lastPivotLowBar) > fibMaxBars
    lastPivotLowPrice := na
    lastPivotLowBar := na
float fibSwingHigh = na
int fibSwingHighBar = na
float fibSwingLow = na 
int fibSwingLowBar = na
if not na(lastPivotHighPrice) and not na(lastPivotLowPrice)
    if nz(lastPivotHighBar) > nz(lastPivotLowBar) 
        fibSwingHigh := lastPivotHighPrice
        fibSwingHighBar := lastPivotHighBar
        fibSwingLow := lastPivotLowPrice 
        fibSwingLowBar := lastPivotLowBar
    else 
        fibSwingLow := lastPivotLowPrice
        fibSwingLowBar := lastPivotLowBar
        fibSwingHigh := lastPivotHighPrice 
        fibSwingHighBar := lastPivotHighBar
var float level_0 = na, var float level_236 = na, var float level_382 = na
var float level_500 = na, var float level_618 = na, var float level_786 = na, var float level_100 = na
bool validFibRange = not na(fibSwingHigh) and not na(fibSwingLow) and fibSwingHigh > fibSwingLow and not na(fibSwingHighBar) and not na(fibSwingLowBar)
bool isUptrendFib = validFibRange and fibSwingLowBar < fibSwingHighBar 
float fibRange = na 
if validFibRange
    fibRange := fibSwingHigh - fibSwingLow 
    if not isUptrendFib 
        level_0 := fibSwingHigh
        level_100 := fibSwingLow
    else 
        level_0 := fibSwingLow
        level_100 := fibSwingHigh
    level_236 := level_0 + (level_100 - level_0) * 0.236
    level_382 := level_0 + (level_100 - level_0) * 0.382
    level_500 := level_0 + (level_100 - level_0) * 0.500
    level_618 := level_0 + (level_100 - level_0) * 0.618
    level_786 := level_0 + (level_100 - level_0) * 0.786
else 
    level_0 := na 
    level_236 := na 
    level_382 := na 
    level_500 := na 
    level_618 := na 
    level_786 := na 
    level_100 := na

// --- Fibonacci Bounce Condition (Buy & Sell) ---
bool touchedFibZoneBuy = false
if isUptrendFib and not na(level_618) 
    for i = 0 to fibBounceLookback - 1
        if low[i] <= level_618 
            touchedFibZoneBuy := true
            break 
bool bouncedAbove50Buy = close > level_500 
bool rsiConfirmsBounceBuy = not rsiConfirmFibBounce or (priceRsi > 40 and priceRsi > priceRsi[1]) 
condFibBounceBuy = useFibBounceEntry and isUptrendFib and touchedFibZoneBuy and bouncedAbove50Buy and rsiConfirmsBounceBuy
bool touchedFibZoneSell = false
if not isUptrendFib and validFibRange and not na(level_382) 
    for i = 0 to fibBounceLookback - 1
        if high[i] >= level_382 
            touchedFibZoneSell := true
            break 
bool rejectedBelow50Sell = close < level_500 
bool rsiConfirmsBounceSell = not rsiConfirmFibBounce or (priceRsi < 60 and priceRsi < priceRsi[1]) 
condFibBounceSell = useFibBounceSell and not isUptrendFib and validFibRange and touchedFibZoneSell and rejectedBelow50Sell and rsiConfirmsBounceSell
// === CONSOLIDATED STRATEGY CALCULATIONS (Continued) ===

// --- EMA Bounce Condition (Buy & Sell) --- 
float emaSource = emaBounceSource == "Fast EMA" ? emaFast : emaMed
bool touchedEmaBuy = false
bool touchedEmaSell = false
if useEmaBounceBuy
    for i = 1 to emaBounceLookback 
        if low[i] <= emaSource[i]
            touchedEmaBuy := true
            break
if useEmaBounceSell
    for i = 1 to emaBounceLookback 
        if high[i] >= emaSource[i]
            touchedEmaSell := true
            break
// Check if price was on the other side of the EMA before the touch lookback period started
// bool aboveEmaBeforeBuy = low[emaBounceLookback + 1] > emaSource[emaBounceLookback + 1] 
// bool belowEmaBeforeSell = high[emaBounceLookback + 1] < emaSource[emaBounceLookback + 1] 
// Simpler check: Was the close before the lookback on the other side?
bool aboveEmaBeforeBuy = close[emaBounceLookback] > emaSource[emaBounceLookback] 
bool belowEmaBeforeSell = close[emaBounceLookback] < emaSource[emaBounceLookback] 

bool rsiConfirmsEmaBuy = not rsiConfirmEmaBounce or (priceRsi > 40 and priceRsi > priceRsi[1])
bool rsiConfirmsEmaSell = not rsiConfirmEmaBounce or (priceRsi < 60 and priceRsi < priceRsi[1])

// Entry Condition: Was above/below, then touched within lookback, now closed back above/below EMA on a bullish/bearish bar
condEmaBounceBuy = useEmaBounceBuy and aboveEmaBeforeBuy and touchedEmaBuy and close > emaSource and close > open and rsiConfirmsEmaBuy
condEmaBounceSell = useEmaBounceSell and belowEmaBeforeSell and touchedEmaSell and close < emaSource and close < open and rsiConfirmsEmaSell


// --- BB Middle Bounce Condition (Buy & Sell) --- 
bool touchedBbMidBuy = false
bool touchedBbMidSell = false
if useBbMidBounceBuy
    for i = 1 to bbBounceLookback 
        if low[i] <= bbMiddle[i]
            touchedBbMidBuy := true
            break
if useBbMidBounceSell
    for i = 1 to bbBounceLookback 
        if high[i] >= bbMiddle[i]
            touchedBbMidSell := true
            break
bool rsiConfirmsBbBuy = not rsiConfirmBbBounce or (priceRsi > 40 and priceRsi > priceRsi[1])
bool rsiConfirmsBbSell = not rsiConfirmBbBounce or (priceRsi < 60 and priceRsi < priceRsi[1])
condBbMidBounceBuy = useBbMidBounceBuy and touchedBbMidBuy and close > bbMiddle and close > open and rsiConfirmsBbBuy
condBbMidBounceSell = useBbMidBounceSell and touchedBbMidSell and close < bbMiddle and close < open and rsiConfirmsBbSell

// --- Confidence Score & Reason Calculation --- 
float buyScore_bar = 0.0
float sellScore_bar = 0.0
string bullReason_bar = ""
string bearReason_bar = ""

if condEmaTrendOkBuy
    buyScore_bar += wEmaTrend
    bullReason_bar += "ET+"
else if condEmaTrendOkSell // Note: Only one trend direction contributes
    sellScore_bar += wEmaTrend
    bearReason_bar += "ET-"

if condEmaFastSlowCrossBuy
    buyScore_bar += wEmaSignal
    bullReason_bar += "ES+"
if condEmaFastSlowCrossSell
    sellScore_bar += wEmaSignal
    bearReason_bar += "ES-"

if condRsiBuy
    buyScore_bar += wRsiThresh
    bullReason_bar += "R+"
if condRsiSell
    sellScore_bar += wRsiThresh
    bearReason_bar += "R-"

if condMacdSignalCrossBuy
    buyScore_bar += wMacdSignal
    bullReason_bar += "MS+"
if condMacdSignalCrossSell
    sellScore_bar += wMacdSignal
    bearReason_bar += "MS-"

if condMacdZeroCrossBuy
    buyScore_bar += wMacdZero
    bullReason_bar += "MZ+"
if condMacdZeroCrossSell
    sellScore_bar += wMacdZero
    bearReason_bar += "MZ-"

if useVolBreakoutBuy and condVolBreakoutBuy // Check if enabled before adding score
    buyScore_bar += wVolBreak
    bullReason_bar += "V+"
if useVolBreakoutSell and condVolBreakoutSell // Check if enabled
    sellScore_bar += wVolBreak
    bearReason_bar += "V-"

// ADX Score Logic Refined: Strength contributes if trend exists, Direction contributes if direction matches
if condAdxStrengthOk 
    if condAdxDirectionOkBuy
        buyScore_bar += wAdxStrength // Add Strength weight if direction is Buy
        bullReason_bar += "AS+"
    if condAdxDirectionOkSell
        sellScore_bar += wAdxStrength // Add Strength weight if direction is Sell
        bearReason_bar += "AS-"
// Separate check for Direction weight        
if condAdxDirectionOkBuy
    buyScore_bar += wAdxDirection
    bullReason_bar += "AD+"
if condAdxDirectionOkSell
    sellScore_bar += wAdxDirection
    bearReason_bar += "AD-"


if condHtfFilterOkBuy
    buyScore_bar += wHtfTrend
    bullReason_bar += "HT+"
if condHtfFilterOkSell
    sellScore_bar += wHtfTrend
    bearReason_bar += "HT-"

if condFibBounceBuy
    buyScore_bar += wFibBounce
    bullReason_bar += "FB+"
if condFibBounceSell
    sellScore_bar += wFibBounce
    bearReason_bar += "FB-"

if condEmaBounceBuy
    buyScore_bar += wEmaBounce
    bullReason_bar += "EB+"
if condEmaBounceSell
    sellScore_bar += wEmaBounce
    bearReason_bar += "EB-"

if condBbMidBounceBuy
    buyScore_bar += wBbBounce
    bullReason_bar += "BB+"
if condBbMidBounceSell
    sellScore_bar += wBbBounce
    bearReason_bar += "BB-"
// Calculate total possible score based ONLY on ENABLED features and their weights
totalPossibleScore = 0.0 // Initialize as float
totalPossibleScore += float(wEmaTrend) // Always considered, ensure float addition
totalPossibleScore += float(wEmaSignal) 
totalPossibleScore += float(wRsiThresh) 
totalPossibleScore += float(wMacdSignal)
totalPossibleScore += float(wMacdZero) 

// CORRECTED LINES: Removed colon ':'
if useVolBreakoutBuy or useVolBreakoutSell
    totalPossibleScore += float(wVolBreak) // Add if either is enabled
if useAdxFilter
    totalPossibleScore += float(wAdxStrength) // Add if ADX filter is on
if useAdxDirectionFilter
    totalPossibleScore += float(wAdxDirection) // Add if Direction filter is on
if useHtfFilter
    totalPossibleScore += float(wHtfTrend) // Add if HTF filter is on
if useFibBounceEntry or useFibBounceSell
    totalPossibleScore += float(wFibBounce)
if useEmaBounceBuy or useEmaBounceSell
    totalPossibleScore += float(wEmaBounce)
if useBbMidBounceBuy or useBbMidBounceSell
    totalPossibleScore += float(wBbBounce)

totalPossibleScore := math.max(1.0, totalPossibleScore) // Ensure no division by zero, keep as float
netScore = buyScore_bar - sellScore_bar // buy/sell scores should already be float/int, result is float/int
scaledScore = (netScore / totalPossibleScore) * 5.0 + 5.0 
scaledScore := math.max(0.0, math.min(10.0, scaledScore)) // Clamp between 0 and 10

// --- RSI Divergence ---
rsiPeak = ta.pivothigh(priceRsi, 5, 2) 
rsiTrough = ta.pivotlow(priceRsi, 5, 2)
pricePeak = ta.pivothigh(high, 5, 2)
priceTrough = ta.pivotlow(low, 5, 2)

// Check pivots exist on the required historical bar (index 1 relative to current pivot check bar)
rsiPeakPrev = rsiPeak[1]
pricePeakPrev = pricePeak[1]
rsiTroughPrev = rsiTrough[1]
priceTroughPrev = priceTrough[1]

validRsiTrough = not na(rsiTrough) and not na(rsiTroughPrev) and not na(priceTrough) and not na(priceTroughPrev)
validRsiPeak = not na(rsiPeak) and not na(rsiPeakPrev) and not na(pricePeak) and not na(pricePeakPrev)

// Bullish Divergence: Lower Low in Price, Higher Low in RSI
// Compare current low/rsi with the low/rsi at the time the previous RSI trough was confirmed
bullishRsiDiv = validRsiTrough and low < priceTroughPrev and priceRsi > rsiTroughPrev

// Bearish Divergence: Higher High in Price, Lower High in RSI
// Compare current high/rsi with the high/rsi at the time the previous RSI peak was confirmed
bearishRsiDiv = validRsiPeak and high > pricePeakPrev and priceRsi < rsiPeakPrev

condRsiBullDivExit = useRsiDivExit and bearishRsiDiv // Exit Long on Bearish Divergence
condRsiBearDivExit = useRsiDivExit and bullishRsiDiv  // Exit Short on Bullish Divergence

// --- State Tracking ---
var bool inLong = false 
var bool inShort = false
var float stopLossLevel = na
var float fibTargetLevelExit = na
var float entryPrice = na
var string exitReason = "" 
var bool wasInLong = false // Use previous state for exit checks
var bool wasInShort = false

// Capture state BEFORE potential changes on the current bar
wasInLong := inLong
wasInShort := inShort

// --- Entry Logic ---
isPotentialEmaBuy = condEmaFastSlowCrossBuy and allFiltersOkBuy 
isPotentialFibBuy = condFibBounceBuy and allFiltersOkBuy 
isPotentialEmaBounceBuy = condEmaBounceBuy and allFiltersOkBuy 
isPotentialBbMidBounceBuy = condBbMidBounceBuy and allFiltersOkBuy 
isPotentialVolBuy = useVolBreakoutBuy and condVolBreakoutBuy and allFiltersOkBuy

isPotentialEmaSell = condEmaFastSlowCrossSell and allFiltersOkSell 
isPotentialFibSell = condFibBounceSell and allFiltersOkSell 
isPotentialEmaBounceSell = condEmaBounceSell and allFiltersOkSell 
isPotentialBbMidBounceSell = condBbMidBounceSell and allFiltersOkSell 
isPotentialVolSell = useVolBreakoutSell and condVolBreakoutSell and allFiltersOkSell

// Combine all potential signals for plotting/alerting
plotSignalBuy = isPotentialEmaBuy or isPotentialFibBuy or isPotentialEmaBounceBuy or isPotentialBbMidBounceBuy or isPotentialVolBuy
plotSignalSell = isPotentialEmaSell or isPotentialFibSell or isPotentialEmaBounceSell or isPotentialBbMidBounceSell or isPotentialVolSell
// Determine signal type for plotting/alerting distinction (prioritize more specific signals)
string buySignalType = na 

// CORRECTED LINES: Removed colon ':'
if isPotentialBbMidBounceBuy
    buySignalType := "BB"
if isPotentialEmaBounceBuy
    buySignalType := "EB" 
if isPotentialVolBuy
    buySignalType := "Vol"
if isPotentialFibBuy
    buySignalType := "Fib"
if isPotentialEmaBuy 
    buySignalType := "EMA" 

string sellSignalType = na 

// CORRECTED LINES: Removed colon ':'
if isPotentialBbMidBounceSell
    sellSignalType := "BB"
if isPotentialEmaBounceSell
    sellSignalType := "EB"
if isPotentialVolSell
    sellSignalType := "Vol"
if isPotentialFibSell
    sellSignalType := "Fib"
if isPotentialEmaSell // EMA Cross checked last
    sellSignalType := "EMA"

// Check if a signal actually triggered a NEW trade
isNewTradeBuy = plotSignalBuy and not wasInLong // Only enter if signal AND not already long
isNewTradeSell = plotSignalSell and not wasInShort // Only enter if signal AND not already short

// Capture score and type only on the bar a *new* trade is initiated
float scoreOnBuySignal = isNewTradeBuy ? scaledScore : na 
float scoreOnSellSignal = isNewTradeSell ? scaledScore : na
string actualBuySignalType = isNewTradeBuy ? buySignalType : na 
string actualSellSignalType = isNewTradeSell ? sellSignalType : na
// Update Trade State
if isNewTradeBuy
    inLong := true
    inShort := false // Ensure short is exited if a buy signal occurs
    entryPrice := close
    stopLossLevel := low - atrVal * atrMult // Initial SL
    swingLowPriceExit = lowestForFibExit
    swingRangeFibExit = entryPrice - swingLowPriceExit
    fibTargetLevelExit := swingRangeFibExit > 0 and useFibExit ? entryPrice + swingRangeFibExit * fibExtensionLevel : na
    exitReason := "" 
    
if isNewTradeSell
    inShort := true
    inLong := false // Ensure long is exited if a sell signal occurs
    entryPrice := close
    stopLossLevel := high + atrVal * atrMult // Initial SL
    swingHighPriceExit = highestForFibExit
    swingRangeFibExit = swingHighPriceExit - entryPrice
    fibTargetLevelExit := swingRangeFibExit > 0 and useFibExit ? entryPrice - swingRangeFibExit * fibExtensionLevel : na
    exitReason := "" 
    
// Update Trailing SL (Only if in trade and NOT the entry bar)
if useAtrStop and inLong and not isNewTradeBuy
    newStopLong = low - atrVal * atrMult
    // Ensure SL only trails up, never moves down
    stopLossLevel := na(stopLossLevel) ? newStopLong : math.max(stopLossLevel, newStopLong) 
    
if useAtrStop and inShort and not isNewTradeSell
    newStopShort = high + atrVal * atrMult
    // Ensure SL only trails down, never moves up
    stopLossLevel := na(stopLossLevel) ? newStopShort : math.min(stopLossLevel, newStopShort)

// --- Exit Logic --- 
// Use the state from the *start* of the bar (wasInLong/wasInShort) to check exits
exitedLongThisBar = false
exitedShortThisBar = false
atrStopFiredLong = false
atrStopFiredShort = false
exitReason_bar = "" 

if wasInLong // Check exits only if we started the bar in a long position
    // Exit conditions are checked in order of priority (can be adjusted)
    atrStopHitLong = useAtrStop and not na(stopLossLevel) and low <= stopLossLevel // Check if price touched SL
    fibHitLong = useFibExit and not na(fibTargetLevelExit) and high >= fibTargetLevelExit
    scoreDropExitLong = scaledScore < (5.0 - exitScoreDropThreshold)
    emaExitLong = useEmaExit and condEmaFastMedCrossSell
    bbExitLong = useBBReturnExit and condBbReturnMeanSell 
    volExitLong = useVolFadeExit and condVolFadeLong
    rsiDivExitLong = condRsiBullDivExit 
    
    if atrStopHitLong
        exitedLongThisBar := true
        exitReason_bar := "ATR SL"
        atrStopFiredLong := true
    else if fibHitLong
        exitedLongThisBar := true
        exitReason_bar := "Fib Tgt"
    else if scoreDropExitLong
        exitedLongThisBar := true
        exitReason_bar := "Score Drop (" + str.tostring(scaledScore, "#.#") + ")"
    else if emaExitLong
        exitedLongThisBar := true
        exitReason_bar := "EMA Cross"
    else if bbExitLong
        exitedLongThisBar := true
        exitReason_bar := "BB Mid Exit"
    else if volExitLong
        exitedLongThisBar := true
        exitReason_bar := "Vol Fade"
    else if rsiDivExitLong
        exitedLongThisBar := true
        exitReason_bar := "RSI Div"

if wasInShort // Check exits only if we started the bar in a short position
    // Exit conditions checked in order
    atrStopHitShort = useAtrStop and not na(stopLossLevel) and high >= stopLossLevel // Check if price touched SL
    fibHitShort = useFibExit and not na(fibTargetLevelExit) and low <= fibTargetLevelExit
    scoreDropExitShort = scaledScore > (5.0 + exitScoreDropThreshold)
    emaExitShort = useEmaExit and condEmaFastMedCrossBuy
    bbExitShort = useBBReturnExit and condBbReturnMeanBuy 
    volExitShort = useVolFadeExit and condVolFadeShort
    rsiDivExitShort = condRsiBearDivExit 
    
    if atrStopHitShort
        exitedShortThisBar := true
        exitReason_bar := "ATR SL"
        atrStopFiredShort := true
    else if fibHitShort
        exitedShortThisBar := true
        exitReason_bar := "Fib Tgt"
    else if scoreDropExitShort
        exitedShortThisBar := true
        exitReason_bar := "Score Drop (" + str.tostring(scaledScore, "#.#") + ")"
    else if emaExitShort
        exitedShortThisBar := true
        exitReason_bar := "EMA Cross"
    else if bbExitShort
        exitedShortThisBar := true
        exitReason_bar := "BB Mid Exit"
    else if volExitShort
        exitedShortThisBar := true
        exitReason_bar := "Vol Fade"
    else if rsiDivExitShort
        exitedShortThisBar := true
        exitReason_bar := "RSI Div"

// --- Reset State on Exit ---
// Must happen AFTER checking exit conditions but BEFORE plotting for the current bar
if exitedLongThisBar
    inLong := false
    stopLossLevel := na
    fibTargetLevelExit := na
    entryPrice := na
    exitReason := exitReason_bar // Store the exit reason
    
if exitedShortThisBar
    inShort := false
    stopLossLevel := na
    fibTargetLevelExit := na
    entryPrice := na
    exitReason := exitReason_bar // Store the exit reason


// === RANGE LEVELS CALCULATIONS & LOGIC ===
// --- Range Levels Timeframe Logic --- CORREСTED switch ---
// --- Range Levels Timeframe Logic --- CORRECTED switch (Verbose) ---
autoAnchor = switch timeframe.period
    // Intraday cases mapping to Daily anchor
    '1'   => '1D'
    '3'   => '1D'
    '5'   => '1D'
    '15'  => '1D'
    
    // Intraday cases mapping to Weekly anchor
    '30'  => '1W'
    '45'  => '1W'
    '60'  => '1W'
    '120' => '1W'
    '180' => '1W'
    '240' => '1W'
    
    // Daily case
    'D'   => '1M' // Maps Daily TF to Monthly anchor
    
    // Weekly case
    'W'   => '3M' // Maps Weekly TF to Quarterly anchor
    
    // Default case for Monthly or higher TFs
    => '12M' // Maps Monthly or higher TFs to Yearly anchor

// (Rest of the timeframe logic remains the same)
rangeTimeframe = switch rangeAnchorIn
    "Auto"      => autoAnchor
    "Daily"     => "1D"
    "Weekly"    => "1W"
    "Monthly"   => "1M"
    "Quarterly" => "3M"
    "Yearly"    => "12M"
    => "12M" // Default case

rangeYearMultiplier = switch rangeAnchorIn
    => 1 // Default to 1 for D, W, M, Q, Y
class graphicSettings // No braces, line ends here
    // Fields - INDENTED relative to 'class'
    string levelName = na
    color levelColor = na
    bool showLevel = na
    
    // Initializer method - INDENTED relative to 'class'
    // Removed 'export method new(...)' for simplicity
    export method init(string _name, color _color, bool _show) => // INDENTED relative to 'class'
        // Statements inside method - INDENTED relative to 'method'
        self.levelName := _name
        self.levelColor := _color
        self.showLevel := _show
        self // Return self is good practice for init

class rangeGraphic // No braces, line ends here
    // Fields - INDENTED
    line rangeLine = na
    label rangeLabel = na

    // Initializer method - INDENTED
    export method init(line _line, label _label) => // INDENTED
        // Statements inside - INDENTED relative to 'method'
        self.rangeLine := _line
        self.rangeLabel := _label
        self

    // Method to delete graphics - INDENTED relative to 'class'
    export method delete() => // INDENTED
        // Statements inside - INDENTED relative to 'method'
        if not na(self.rangeLine)
            self.rangeLine.delete()
        if not na(self.rangeLabel)
            self.rangeLabel.delete()

// --- Range Levels Global Variables & Setup ---
var bool isDailyBasedInput = true 

// Initialize graphic settings array - ADJUSTED to call init directly
var graphicSettingsArray = array.new<graphicSettings>(21) // Pre-allocate size

// Populate the array using the simplified init call
array.set(graphicSettingsArray, 0, graphicSettings.new().init("O", pColorInput, pShowInput)) 
array.set(graphicSettingsArray, 1, graphicSettings.new().init("R1", r1ColorInput, r1ShowInput))
array.set(graphicSettingsArray, 2, graphicSettings.new().init("S1", s1ColorInput, s1ShowInput))
array.set(graphicSettingsArray, 3, graphicSettings.new().init("R2", r2ColorInput, r2ShowInput))
array.set(graphicSettingsArray, 4, graphicSettings.new().init("S2", s2ColorInput, s2ShowInput))
array.set(graphicSettingsArray, 5, graphicSettings.new().init("R3", r3ColorInput, r3ShowInput))
array.set(graphicSettingsArray, 6, graphicSettings.new().init("S3", s3ColorInput, s3ShowInput))
array.set(graphicSettingsArray, 7, graphicSettings.new().init("R4", r4ColorInput, r4ShowInput))
array.set(graphicSettingsArray, 8, graphicSettings.new().init("S4", s4ColorInput, s4ShowInput))
array.set(graphicSettingsArray, 9, graphicSettings.new().init("R5", r5ColorInput, r5ShowInput))
array.set(graphicSettingsArray, 10, graphicSettings.new().init("S5", s5ColorInput, s5ShowInput))
array.set(graphicSettingsArray, 11, graphicSettings.new().init("R6", r6ColorInput, r6ShowInput))
array.set(graphicSettingsArray, 12, graphicSettings.new().init("S6", s6ColorInput, s6ShowInput))
array.set(graphicSettingsArray, 13, graphicSettings.new().init("R7", r7ColorInput, r7ShowInput))
array.set(graphicSettingsArray, 14, graphicSettings.new().init("S7", s7ColorInput, s7ShowInput))
array.set(graphicSettingsArray, 15, graphicSettings.new().init("R8", r8ColorInput, r8ShowInput))
array.set(graphicSettingsArray, 16, graphicSettings.new().init("S8", s8ColorInput, s8ShowInput))
array.set(graphicSettingsArray, 17, graphicSettings.new().init("R9", r9ColorInput, r9ShowInput))
array.set(graphicSettingsArray, 18, graphicSettings.new().init("S9", s9ColorInput, s9ShowInput))
array.set(graphicSettingsArray, 19, graphicSettings.new().init("R0", r0ColorInput, r0ShowInput))
array.set(graphicSettingsArray, 20, graphicSettings.new().init("S0", s0ColorInput, s0ShowInput))


// Matrix to store drawn graphics (Lines and Labels)
var drawnGraphics = matrix.new<rangeGraphic>() 

// --- Range Levels Functions --- 
// (Make sure the call inside drawNewranges uses the simplified instantiation if needed)

//@function Draws range lines and labels from `startTime` to the approximate end of the period.
drawNewranges(time) => // Renamed startTime to time
    
    newGraphics = array.new<rangeGraphic>() // Array to hold graphics for the new period

    if not na(rangePointsArray) and array.size(rangePointsArray) == 21
        for index = 0 to array.size(rangePointsArray) - 1
            coord = array.get(rangePointsArray, index)
            // Ensure graphicSettingsArray is populated before accessing
            if index < array.size(graphicSettingsArray)
                levelSettings = graphicSettingsArray.get(index) // Get settings by index
            
                levelStyle = switch lineStyle
                    "Dotted" => line.style_dotted
                    "Dashed" => line.style_dashed
                    "Line"   => line.style_solid
                    => line.style_solid // Default case

                if not na(coord) and not na(levelSettings) and levelSettings.showLevel // Check levelSettings validity
                    // ... (line and label creation logic remains the same) ...
                    rangeLine = line.new(time, coord, lineEndTime, coord, xloc = xloc.bar_time, color=levelSettings.levelColor, width=linewidthInput, style=levelStyle, extend = extend.right) 
                    rangeLabel = label.new(x = labelXpos, y = coord, text = (showLabelsInput ? levelSettings.levelName + " " : "") + (showPricesInput ? "(" + str.tostring(coord, format.mintick) + ")" : ""), style = labelStyle, textcolor = levelSettings.levelColor, color = color.new(color.black, 100), size = size.small, xloc=xloc.bar_time)
                
                    # // Add the new line/label pair using simplified instantiation
                    # // We need the rangeGraphic class to follow the same pattern or adjust the call
                    # // Let's assume rangeGraphic still uses the `new().init()` pattern for now.
                    # // If rangeGraphic was also simplified, this would need to change.
                    # // Add the new line/label pair using simplified instantiation
                array.push(newGraphics, rangeGraphic.new().init(rangeLine, rangeLabel)) // Reverted to previous call, ensure rangeGraphic has the new().init() combo or just export init
            else
                 // Handle case where index is out of bounds for graphicSettingsArray (shouldn't happen if sizes match)
                 continue // Skip this level if settings are missing
        
        // Add the array of new graphics as a new row to the matrix
        drawnGraphics.add_row(drawnGraphics.rows(), newGraphics) // Add row at the end

        // Manage history: If matrix exceeds max size, remove the oldest row
        if drawnGraphics.rows() > maxHistoricalRangeIn
            oldGraphics_row_array = drawnGraphics.remove_row(0) // Remove the first row (oldest)
            
            // Delete the line and label objects from the removed row
            for i = 0 to array.size(oldGraphics_row_array) - 1
                 graphic_to_delete = array.get(oldGraphics_row_array, i)
                 if not na(graphic_to_delete)
                    graphic_to_delete.delete() // Call the delete method of the rangeGraphic class

// (Rest of the script follows)

// --- Range Levels Drawing Logic ---

// Determine if new ranges should be drawn based on timeframe change counter from security call
securityrangeDrawConditionStatic = isDailyBasedInput and securityrangeCounter != nz(securityrangeCounter[1]) // Check if counter changed

// Store first bar time only once
var FIRST_BAR_TIME = time 

if (securityrangeDrawConditionStatic) // Only draw based on security timeframe change
    affixOldranges(time) // End the previous lines/labels
    drawNewranges(time) // Draw the new set

// Initial Draw / Error Handling (simplified)
if barstate.islastconfirmedhistory and drawnGraphics.rows() == 0
    // Try to draw on the last historical bar if nothing was drawn yet
    if not na(securityRanges) and not na(securityrangeCounter) and securityrangeCounter >= 0 
        drawNewranges(FIRST_BAR_TIME) // Attempt draw from the very start
    else if barstate.islast 
        // Only show error on the very last bar if still no data
        runtime.error("Not enough data to calculate Range Levels for the selected Timeframe/History. Try adjusting settings.")


// === PLOTTING (Consolidated Strategy + Range Levels) ===

// --- Strategy Indicators ---
plot(emaFast, "Fast EMA", color=color.new(color.blue, 0)) 
plot(emaMed, "Medium EMA", color=color.new(color.orange, 0)) 
plot(emaSlow, "Slow EMA", color=color.new(color.red, 0))
bbMidPlot = plot(showBB ? bbMiddle : na, "BB Middle", color=bbColor, linewidth=1) 
bbUpperPlot = plot(showBB ? bbUpper : na, "BB Upper", color=bbColor, linewidth=1) 
bbLowerPlot = plot(showBB ? bbLower : na, "BB Lower", color=bbColor, linewidth=1)
fill(bbUpperPlot, bbLowerPlot, color=color.new(bbColor, 90), title="BB Fill")

// --- Strategy Auto Fib Retracement ---
// Function to draw Fib lines (only if enabled and valid)
drawFibLine(levelVal, levelName) =>
    if showAutoFib and validFibRange and not na(levelVal)
        line.new(bar_index[int(nz(fibSwingHighBar > fibSwingLowBar ? fibSwingLowBar : fibSwingHighBar, 1))], levelVal, 
                 bar_index, levelVal, 
                 color = fibLineColor, width = fibLineWidth, extend = extend.right)
        // label.new(bar_index + 5, levelVal, levelName + ": " + str.tostring(levelVal, format.mintick), 
        //          color=fibLineColor, textcolor=color.white, style=label.style_label_left, size=size.tiny) // Optional labels

// Draw the Fib lines if enabled
if showAutoFib and validFibRange
    drawFibLine(level_0, "0.0")
    drawFibLine(level_236, "23.6")
    drawFibLine(level_382, "38.2")
    drawFibLine(level_500, "50.0")
    drawFibLine(level_618, "61.8")
    drawFibLine(level_786, "78.6")
    drawFibLine(level_100, "100.0")

// --- Strategy SL and Target Lines ---
plot(inLong and useAtrStop ? stopLossLevel : na, "Long SL", color=color.new(color.maroon, 0), style=plot.style_linebr, linewidth=2)
plot(inShort and useAtrStop ? stopLossLevel : na, "Short SL", color=color.new(color.teal, 0), style=plot.style_linebr, linewidth=2)
plot(inLong and useFibExit ? fibTargetLevelExit : na, "Long Tgt", color=color.new(color.fuchsia, 0), style=plot.style_linebr, linewidth=1)
plot(inShort and useFibExit ? fibTargetLevelExit : na, "Short Tgt", color=color.new(color.fuchsia, 0), style=plot.style_linebr, linewidth=1)

// --- Strategy Entry/Exit Signal Shapes ---
// Buy Signals (below bar)
plotshape(series=isPotentialEmaBuy, title="EMA Buy Signal", location=location.belowbar, color=color.new(#00FF00, 0), style=shape.triangleup, size=size.small) 
plotshape(series=isPotentialFibBuy, title="Fib Buy Signal", location=location.belowbar, color=color.new(#00CC00, 0), style=shape.diamond, size=size.small) 
plotshape(series=isPotentialEmaBounceBuy, title="EMA Bounce Buy", location=location.belowbar, color=color.new(#009900, 0), style=shape.circle, size=size.tiny) 
plotshape(series=isPotentialBbMidBounceBuy, title="BB Mid Bounce Buy", location=location.belowbar, color=color.new(#006600, 0), style=shape.square, size=size.tiny) 
plotshape(series=isPotentialVolBuy, title="Volume Buy Signal", location=location.belowbar, color=color.new(#003300, 0), style=shape.square, size=size.tiny)

// Sell Signals (above bar)
plotshape(series=isPotentialEmaSell, title="EMA Sell Signal", location=location.abovebar, color=color.new(#FF0000, 0), style=shape.triangledown, size=size.small) 
plotshape(series=isPotentialFibSell, title="Fib Sell Signal", location=location.abovebar, color=color.new(#CC0000, 0), style=shape.diamond, size=size.small) 
plotshape(series=isPotentialEmaBounceSell, title="EMA Bounce Sell", location=location.abovebar, color=color.new(#990000, 0), style=shape.circle, size=size.tiny) 
plotshape(series=isPotentialBbMidBounceSell, title="BB Mid Bounce Sell", location=location.abovebar, color=color.new(#660000, 0), style=shape.square, size=size.tiny) 
plotshape(series=isPotentialVolSell, title="Volume Sell Signal", location=location.abovebar, color=color.new(#330000, 0), style=shape.square, size=size.tiny)

// Exit Shapes
plotshape(exitedLongThisBar, "Exit Long Shape", location=location.abovebar, color=color.new(color.maroon, 50), style=shape.cross, size=size.small) // Made slightly larger
plotshape(exitedShortThisBar, "Exit Short Shape", location=location.belowbar, color=color.new(color.teal, 50), style=shape.cross, size=size.small) // Made slightly larger

// --- Strategy Signal Score Label ---
signalScoreBuyText = buySignalType + "\n" + str.tostring(scoreOnBuySignal, "#.#") 
signalScoreSellText = sellSignalType + "\n" + str.tostring(scoreOnSellSignal, "#.#") 

// Calculate label positions once (relative to price)
labelBuyY = low - atrVal * 0.2 // Adjusted offset
labelSellY = high + atrVal * 0.2 // Adjusted offset

// Create labels only when a *new trade* is triggered (isNewTradeBuy/Sell)
if isNewTradeBuy and not na(scoreOnBuySignal) 
    // Enhanced green intensity calculation (0-10 score → 0-255 green intensity)
    greenIntensity = math.round( scoreOnBuySignal / 10.0 * 255.0 )
    greenIntensity := math.min(255, math.max(0, greenIntensity)) // Clamp between 0-255
    
    // Create semi-transparent label with white text
    buyLabelColor = color.new(color.rgb(0, greenIntensity, 0), 70) // 70% transparency
    label.new(
         bar_index, labelBuyY, signalScoreBuyText, 
         color=buyLabelColor, 
         textcolor=color.white, 
         style=label.style_label_up, 
         yloc=yloc.price, 
         size=size.small,
         textalign=text.align_center
     )
    
if isNewTradeSell and not na(scoreOnSellSignal) 
    // Enhanced red intensity calculation (0-10 score -> 0-255 red intensity, inverted)
    // Score closer to 0 means strong sell -> more red
    // Score closer to 10 means weak sell -> less red
    redIntensity = math.round( (10.0 - scoreOnSellSignal) / 10.0 * 255.0 )
    redIntensity := math.min(255, math.max(0, redIntensity)) // Clamp between 0-255
    
    // Create semi-transparent label with white text
    sellLabelColor = color.new(color.rgb(redIntensity, 0, 0), 70) // 70% transparency
    label.new(
         bar_index, labelSellY, signalScoreSellText, 
         color=sellLabelColor, 
         textcolor=color.white, 
         style=label.style_label_down, 
         yloc=yloc.price, 
         size=size.small,
         textalign=text.align_center
     )

// --- Strategy Background color ---
bgcolor(inLong ? color.new(color.green, 85) : inShort ? color.new(color.red, 85) : na)

// --- Strategy Data Window Plotting ---
plot(scaledScore, "Confidence Score", color=color.new(color.gray,0), display=display.data_window)
plotchar(inLong, "In Long", "", location.top, display=display.data_window) // Show state in data window
plotchar(inShort, "In Short", "", location.top, display=display.data_window)
plotchar(exitReason, "Last Exit Reason", "", location.top, display=display.data_window) // Show last exit reason

// === ALERTS (Consolidated Strategy) ===
alertcondition(isNewTradeBuy, "Consolidated Trade Buy", "{{ticker}}: ENTER BUY state. Score: {{plot('Confidence Score')}}. Price: {{close}}") 
alertcondition(isNewTradeSell, "Consolidated Trade Sell", "{{ticker}}: ENTER SELL state. Score: {{plot('Confidence Score')}}. Price: {{close}}") 
alertcondition(exitedLongThisBar and not atrStopFiredLong, "Consolidated Exit Long", "{{ticker}}: EXIT LONG signal ("+ exitReason + "). Price: {{close}}") // Added exit reason
alertcondition(exitedShortThisBar and not atrStopFiredShort, "Consolidated Exit Short", "{{ticker}}: EXIT SHORT signal ("+ exitReason + "). Price: {{close}}") // Added exit reason
alertcondition(atrStopFiredLong, "Consolidated ATR Stop Long", "{{ticker}}: ATR STOP LONG hit. Price: {{close}}")
alertcondition(atrStopFiredShort, "Consolidated ATR Stop Short", "{{ticker}}: ATR STOP SHORT hit. Price: {{close}}")

// Optional Alerts for Potential Signals (fires even if already in a trade)
alertcondition(plotSignalBuy and not plotSignalBuy[1], "Potential Buy Signal", "{{ticker}}: Potential " + buySignalType + " Buy Signal. Filters OK. Score: {{plot('Confidence Score')}}. Price: {{close}}") 
alertcondition(plotSignalSell and not plotSignalSell[1], "Potential Sell Signal", "{{ticker}}: Potential " + sellSignalType + " Sell Signal. Filters OK. Score: {{plot('Confidence Score')}}. Price: {{close}}") 

// === END OF SCRIPT ===