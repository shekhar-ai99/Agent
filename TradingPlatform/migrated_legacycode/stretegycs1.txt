//@version=6
strategy("Enhanced CS1 Strategy", shorttitle="ECS1", overlay=true, 
     default_qty_type=strategy.percent_of_equity, 
     default_qty_value=100, 
     commission_type=strategy.commission.percent, 
     commission_value=0.075,
     pyramiding=0,
     calc_on_every_tick=false,
     initial_capital=10000,ƒ
     currency=currency.USD)

// --- Core Entry & Exit ---
grpCore = "Core Strategy Settings"
exitScoreDropThreshold = input.float(1.5, "Exit on Score Drop Threshold", minval=0.1, maxval=5.0, step=0.1, group=grpCore, 
  tooltip="Exit if score drops below (5.0 - Threshold) for longs or above (5.0 + Threshold) for shorts")
useFibBounceEntry = input.bool(true, "Use Fib 0.5-0.618 Bounce Entry (Long)", group=grpCore, 
  tooltip="Generate BUY signal on upward bounce from 0.5-0.618 Fib in uptrend")
useFibBounceSell = input.bool(true, "Use Fib 0.5-0.382 Bounce Entry (Short)", group=grpCore, 
  tooltip="Generate SELL signal on downward bounce from 0.5-0.382 Fib in downtrend") 
fibBounceLookback = input.int(3, "Fib Bounce Price Lookback Bars", minval=1, maxval=10, group=grpCore, 
  tooltip="Bars back to check for Fib zone touch")
useEmaBounceBuy = input.bool(true, title="Use EMA Bounce Entry (Long)?", group=grpCore)
useEmaBounceSell = input.bool(true, title="Use EMA Bounce Entry (Short)?", group=grpCore)
emaBounceLookback = input.int(2, title="EMA Bounce Price Lookback Bars", minval=1, maxval=5, group=grpCore)
emaBounceSource = input.string("Fast EMA", title="EMA Source for Bounce", options=["Fast EMA", "Medium EMA"], group=grpCore)
useBbMidBounceBuy = input.bool(true, title="Use BB Mid Bounce Entry (Long)?", group=grpCore)
useBbMidBounceSell = input.bool(true, title="Use BB Mid Bounce Entry (Short)?", group=grpCore)
bbBounceLookback = input.int(2, title="BB Mid Bounce Price Lookback Bars", minval=1, maxval=5, group=grpCore)
useVolBreakoutBuy = input.bool(true, title="Use Volume Breakout Entry (Long)?", group=grpCore)
useVolBreakoutSell = input.bool(true, title="Use Volume Breakout Entry (Short)?", group=grpCore)
// Inside the grpCore = "Core Strategy Settings" section
//useSkipTradeFilter = input.bool(true, "Filter Weak Momentum/Volume Signals?", group=grpCore,
  //tooltip="If enabled, signals on bars with low range (vs ATR) and low volume (vs SMA) will be skipped.")
  // --- Weak Signal Filter Settings ---
grpSkip = "Weak Signal Filter Settings"
useSkipTradeFilter = input.bool(true, "Enable Weak Signal Filter?", group=grpSkip,
  tooltip="If enabled, signals on bars matching the criteria below will be skipped.")
skipAtrFactor = input.float(0.3, "Min Price Move (ATR Factor)", minval=0.0, step=0.05, group=grpSkip,
  tooltip="Skip signal if |close - open| is less than ATR * this factor. Set to 0 to disable this part of the check.")
skipVolMALen = input.int(20, "Volume MA Length for Filter", minval=1, group=grpSkip,
  tooltip="The lookback period for the Simple Moving Average of volume used in the filter.")
skipVolMultiplier = input.float(1.2, "Min Volume Spike (x MA)", minval=0.0, step=0.1, group=grpSkip,
  tooltip="Skip signal if volume is less than its MA * this multiplier. Set to 0 to disable this part of the check.")


// --- EMAs ---
grpEMA = "EMA Settings"
emaFastLen = input.int(9, "Fast EMA Length", minval=1, group=grpEMA)
emaMedLen = input.int(14, "Medium EMA Length", minval=1, group=grpEMA)
emaSlowLen = input.int(21, "Slow EMA Length", minval=1, group=grpEMA)
useEmaExit = input.bool(true, "Use Fast/Med EMA Cross for Exit", group=grpEMA)

// --- Bollinger Bands ---
grpBB = "Bollinger Bands Settings"
showBB = input.bool(true, "Show Bollinger Bands", group=grpBB)
bbLen = input.int(20, "BB Length", minval=1, group=grpBB)
bbStdDev = input.float(2.0, "BB StdDev Multiplier", minval=0.1, group=grpBB)
bbColor = input.color(color.new(color.gray, 70), "BB Color", group=grpBB)
useBBReturnExit = input.bool(true, "Use BB Return to Mean for Exit", group=grpBB)

// --- RSI ---
grpRSI = "RSI Settings"
rsiLen = input.int(14, "RSI Length", minval=1, group=grpRSI)
rsiBuyLevel = input.float(55.0, "RSI Buy Threshold (>)", group=grpRSI)
rsiSellLevel = input.float(45.0, "RSI Sell Threshold (<)", group=grpRSI)
useRsiDivExit = input.bool(false, "Use RSI Divergence Exit", group=grpRSI, 
  tooltip="Exit on RSI divergence (lower high/higher low)")
rsiConfirmFibBounce = input.bool(true, "Require RSI Confirmation for Fib Bounce", group=grpRSI, 
  tooltip="Long: RSI>40 Rising. Short: RSI<60 Falling")
rsiConfirmEmaBounce = input.bool(false, title="Require RSI Confirmation for EMA Bounce?", group=grpRSI) 
rsiConfirmBbBounce = input.bool(false, title="Require RSI Confirmation for BB Bounce?", group=grpRSI) 

// --- MACD ---
grpMACD = "MACD Settings"
macdFastLen = input.int(12, "MACD Fast Length", group=grpMACD)
macdSlowLen = input.int(26, "MACD Slow Length", group=grpMACD)
macdSignalLen = input.int(9, "MACD Signal Length", group=grpMACD)

// --- Volume ---
grpVol = "Volume Settings"
volMALen = input.int(50, "Volume MA Length", minval=1, group=grpVol)
volMultiplier = input.float(1.5, "Volume Breakout Multiplier (> MA)", group=grpVol)
useVolFadeExit = input.bool(true, "Use Low Volume Pullback Exit", group=grpVol)

// --- ATR Stop Loss ---
grpATR = "ATR Stop Loss"
useAtrStop = input.bool(true, "Use ATR Stop Loss for Exit", group=grpATR)
atrLen = input.int(14, "ATR Length", minval=1, group=grpATR)
atrMult = input.float(2.0, "ATR Multiplier", minval=0.1, group=grpATR)




// --- Fibonacci EXIT Target ---
grpFibExit = "Fibonacci Exit Target"
useFibExit = input.bool(true, "Use Fib Extension Exit Target", group=grpFibExit)
fibLookbackExit = input.int(30, "Fib Exit Swing Lookback", minval=5, group=grpFibExit, 
  tooltip="Bars back from entry to find swing point")
fibExtensionLevel = input.float(1.618, "Fib Extension Target", minval=0.1, group=grpFibExit)

// --- Auto Fibonacci RETRACEMENT ---
grpFibRet = "Auto Fib Retracement"
showAutoFib = input.bool(true, "Show Auto Fib Retracement", group=grpFibRet)
fibPivotLookback = input.int(15, "Pivot Lookback (Left/Right Bars)", minval=2, group=grpFibRet)
fibMaxBars = input.int(200, "Max Bars Back for Pivots", minval=20, group=grpFibRet)
fibLineColor = input.color(color.new(color.gray, 50), "Fib Line Color", group=grpFibRet)
fibLineWidth = input.int(1, "Fib Line Width", minval=1, group=grpFibRet)

// --- Trend / Market Condition Filters ---
grpFilter = "Trend Filters"
useEmaTrendFilter = input.bool(true, "Require EMA Trend (Med > Slow)", group=grpFilter)
useAdxFilter = input.bool(true, "Use ADX Filter", group=grpFilter)
adxLen = input.int(14, "ADX Length", minval=1, group=grpFilter)
adxThreshold = input.float(20.0, "ADX Trend Strength Threshold (>)", minval=0, group=grpFilter)
useAdxDirectionFilter = input.bool(true, "Require ADX Direction (DI+ vs DI-)", group=grpFilter)
useHtfFilter = input.bool(false, "Use Higher Timeframe EMA Filter", group=grpFilter)
htf = input.timeframe("60", "Higher Timeframe for Filter", group=grpFilter)
htfEmaLen = input.int(50, "HTF EMA Length", group=grpFilter)

// --- SCORE CALCULATION WEIGHTS ---
grpScore = "Confidence Score Weights"
wEmaTrend = input.int(2, "Weight: EMA Trend", group=grpScore, minval=0)
wEmaSignal = input.int(1, "Weight: EMA Cross Signal", group=grpScore, minval=0)
wRsiThresh = input.int(1, "Weight: RSI Threshold", group=grpScore, minval=0)
wMacdSignal = input.int(1, "Weight: MACD Signal Cross", group=grpScore, minval=0)
wMacdZero = input.int(1, "Weight: MACD Zero Cross", group=grpScore, minval=0)
wVolBreak = input.int(1, "Weight: Volume Breakout", group=grpScore, minval=0)
wAdxStrength = input.int(1, "Weight: ADX Strength", group=grpScore, minval=0)
wAdxDirection = input.int(1, "Weight: ADX Direction", group=grpScore, minval=0)
wHtfTrend = input.int(2, "Weight: HTF Trend", group=grpScore, minval=0)
wFibBounce = input.int(2, "Weight: Fib Bounce Signal", group=grpScore, minval=0) 
wEmaBounce = input.int(1, "Weight: EMA Bounce Signal", group=grpScore, minval=0) 
wBbBounce = input.int(1, "Weight: BB Mid Bounce Signal", group=grpScore, minval=0) 

// === CALCULATIONS ===

// --- Indicators ---
emaFast = ta.ema(close, emaFastLen)
emaMed = ta.ema(close, emaMedLen)
emaSlow = ta.ema(close, emaSlowLen)
[bbMiddle, bbUpper, bbLower] = ta.bb(close, bbLen, bbStdDev)
priceRsi = ta.rsi(close, rsiLen)
[macdLine, signalLine, histLine] = ta.macd(close, macdFastLen, macdSlowLen, macdSignalLen)
volMA = ta.sma(volume, volMALen)
atrVal = ta.atr(atrLen)
[diPos, diNeg, adxVal] = ta.dmi(adxLen, adxLen)
htfEma = request.security(syminfo.tickerid, htf, ta.ema(close, htfEmaLen), lookahead=barmerge.lookahead_off)
lowestForFibExit = ta.lowest(low, fibLookbackExit)[1]
highestForFibExit = ta.highest(high, fibLookbackExit)[1]

// --- Modify them like this: ---
expectedMove = atrVal * skipAtrFactor       // Use input for ATR factor
priceMove = math.abs(close - open)
// Only check momentum if factor > 0
momentumOk = skipAtrFactor > 0 ? (priceMove > expectedMove) : true
// Only check volume if multiplier > 0
volumeSpike = skipVolMultiplier > 0 ? (volume > ta.sma(volume, skipVolMALen) * skipVolMultiplier) : true // Use inputs for Vol MA len and multiplier


// --- Basic Conditions ---
condEmaFastSlowCrossBuy = ta.crossover(emaFast, emaSlow)
condEmaFastSlowCrossSell = ta.crossunder(emaFast, emaSlow)
condEmaFastMedCrossBuy = ta.crossover(emaFast, emaMed)
condEmaFastMedCrossSell = ta.crossunder(emaFast, emaMed)
condBbReturnMeanBuy = ta.crossover(close, bbMiddle) 
condBbReturnMeanSell = ta.crossunder(close, bbMiddle) 
condRsiBuy = priceRsi > rsiBuyLevel
condRsiSell = priceRsi < rsiSellLevel
condMacdSignalCrossBuy = ta.crossover(macdLine, signalLine)
condMacdSignalCrossSell = ta.crossunder(macdLine, signalLine)
condMacdZeroCrossBuy = ta.crossover(macdLine, 0)
condMacdZeroCrossSell = ta.crossunder(macdLine, 0)
condHighVol = volume > volMA * volMultiplier
condVolBreakoutBuy = condHighVol and close > open and close > emaSlow 
condVolBreakoutSell = condHighVol and close < open and close < emaSlow 
condVolFadeLong = close < emaFast and volume < volMA 
condVolFadeShort = close > emaFast and volume < volMA 

// --- Filter Conditions ---
condEmaTrendOkBuy = not useEmaTrendFilter or emaMed > emaSlow
condEmaTrendOkSell = not useEmaTrendFilter or emaMed < emaSlow
condAdxStrengthOk = not useAdxFilter or adxVal > adxThreshold
condAdxDirectionOkBuy = not useAdxDirectionFilter or diPos > diNeg
condAdxDirectionOkSell = not useAdxDirectionFilter or diNeg > diPos
condAdxFilterOkBuy = condAdxStrengthOk and condAdxDirectionOkBuy
condAdxFilterOkSell = condAdxStrengthOk and condAdxDirectionOkSell
condHtfFilterOkBuy = not useHtfFilter or close > htfEma
condHtfFilterOkSell = not useHtfFilter or close < htfEma

allFiltersOkBuy = condEmaTrendOkBuy and condAdxFilterOkBuy and condHtfFilterOkBuy
allFiltersOkSell = condEmaTrendOkSell and condAdxFilterOkSell and condHtfFilterOkSell
skipTrade = not (momentumOk and volumeSpike)
bbWidth = bbUpper - bbLower
minBBWidth = ta.sma(bbWidth, 10) * 0.3  // adjust 0.3 as needed
isInRange = bbWidth < minBBWidth or (useAdxFilter and adxVal < 12)
allFiltersOkBuy := allFiltersOkBuy and not isInRange
allFiltersOkSell := allFiltersOkSell and not isInRange



// --- Auto Fibonacci Retracement Calculation ---
var float lastPivotHighPrice = na
var int lastPivotHighBar = na
var float lastPivotLowPrice = na 
var int lastPivotLowBar = na 
pivotHighVal = ta.pivothigh(high, fibPivotLookback, fibPivotLookback)
pivotLowVal = ta.pivotlow(low, fibPivotLookback, fibPivotLookback)
if not na(pivotHighVal)
    pivotHighBarIndex = bar_index[fibPivotLookback] 
    if na(lastPivotHighBar) or pivotHighBarIndex > lastPivotHighBar or pivotHighVal > nz(lastPivotHighPrice, -999999)
        lastPivotHighPrice := pivotHighVal
        lastPivotHighBar := pivotHighBarIndex
if not na(pivotLowVal)
    pivotLowBarIndex = bar_index[fibPivotLookback]
    if na(lastPivotLowBar) or pivotLowBarIndex > lastPivotLowBar or pivotLowVal < nz(lastPivotLowPrice, 999999)
        lastPivotLowPrice := pivotLowVal
        lastPivotLowBar := pivotLowBarIndex
if bar_index - nz(lastPivotHighBar) > fibMaxBars
    lastPivotHighPrice := na
    lastPivotHighBar := na
if bar_index - nz(lastPivotLowBar) > fibMaxBars
    lastPivotLowPrice := na
    lastPivotLowBar := na
float fibSwingHigh = na
int fibSwingHighBar = na
float fibSwingLow = na 
int fibSwingLowBar = na
if not na(lastPivotHighPrice) and not na(lastPivotLowPrice)
    if nz(lastPivotHighBar) > nz(lastPivotLowBar) 
        fibSwingHigh := lastPivotHighPrice
        fibSwingHighBar := lastPivotHighBar
        fibSwingLow := lastPivotLowPrice 
        fibSwingLowBar := lastPivotLowBar
    else 
        fibSwingLow := lastPivotLowPrice
        fibSwingLowBar := lastPivotLowBar
        fibSwingHigh := lastPivotHighPrice 
        fibSwingHighBar := lastPivotHighBar
var float level_0 = na, var float level_236 = na, var float level_382 = na
var float level_500 = na, var float level_618 = na, var float level_786 = na, var float level_100 = na
bool validFibRange = not na(fibSwingHigh) and not na(fibSwingLow) and fibSwingHigh > fibSwingLow and not na(fibSwingHighBar) and not na(fibSwingLowBar)
bool isUptrendFib = validFibRange and fibSwingLowBar < fibSwingHighBar 
float fibRange = na 
if validFibRange
    fibRange := fibSwingHigh - fibSwingLow 
    if not isUptrendFib 
        level_0 := fibSwingHigh
        level_100 := fibSwingLow
    else 
        level_0 := fibSwingLow
        level_100 := fibSwingHigh
    level_236 := level_0 + (level_100 - level_0) * 0.236
    level_382 := level_0 + (level_100 - level_0) * 0.382
    level_500 := level_0 + (level_100 - level_0) * 0.500
    level_618 := level_0 + (level_100 - level_0) * 0.618
    level_786 := level_0 + (level_100 - level_0) * 0.786
else 
    level_0 := na 
    level_236 := na 
    level_382 := na 
    level_500 := na 
    level_618 := na 
    level_786 := na 
    level_100 := na

// --- Fibonacci Bounce Condition (Buy & Sell) ---
bool touchedFibZoneBuy = false
if isUptrendFib and not na(level_618) 
    for i = 0 to fibBounceLookback - 1
        if low[i] <= level_618 
            touchedFibZoneBuy := true
            break 
bool bouncedAbove50Buy = close > level_500 
bool rsiConfirmsBounceBuy = not rsiConfirmFibBounce or (priceRsi > 40 and priceRsi > priceRsi[1]) 
condFibBounceBuy = useFibBounceEntry and isUptrendFib and touchedFibZoneBuy and bouncedAbove50Buy and rsiConfirmsBounceBuy
bool touchedFibZoneSell = false
if not isUptrendFib and validFibRange and not na(level_382) 
    for i = 0 to fibBounceLookback - 1
        if high[i] >= level_382 
            touchedFibZoneSell := true
            break 
bool rejectedBelow50Sell = close < level_500 
bool rsiConfirmsBounceSell = not rsiConfirmFibBounce or (priceRsi < 60 and priceRsi < priceRsi[1]) 
condFibBounceSell = useFibBounceSell and not isUptrendFib and validFibRange and touchedFibZoneSell and rejectedBelow50Sell and rsiConfirmsBounceSell

// --- EMA Bounce Condition (Buy & Sell) --- 
float emaSource = emaBounceSource == "Fast EMA" ? emaFast : emaMed
bool touchedEmaBuy = false
bool touchedEmaSell = false
if useEmaBounceBuy
    for i = 1 to emaBounceLookback 
        if low[i] <= emaSource[i]
            touchedEmaBuy := true
            break
if useEmaBounceSell
    for i = 1 to emaBounceLookback 
        if high[i] >= emaSource[i]
            touchedEmaSell := true
            break
bool aboveEmaBeforeBuy = close[emaBounceLookback+1] > emaSource[emaBounceLookback+1] 
bool belowEmaBeforeSell = close[emaBounceLookback+1] < emaSource[emaBounceLookback+1] 
bool rsiConfirmsEmaBuy = not rsiConfirmEmaBounce or (priceRsi > 40 and priceRsi > priceRsi[1])
bool rsiConfirmsEmaSell = not rsiConfirmEmaBounce or (priceRsi < 60 and priceRsi < priceRsi[1])
condEmaBounceBuy = useEmaBounceBuy and aboveEmaBeforeBuy and touchedEmaBuy and close > emaSource and close > open and rsiConfirmsEmaBuy
condEmaBounceSell = useEmaBounceSell and belowEmaBeforeSell and touchedEmaSell and close < emaSource and close < open and rsiConfirmsEmaSell

// --- BB Middle Bounce Condition (Buy & Sell) --- 
bool touchedBbMidBuy = false
bool touchedBbMidSell = false
if useBbMidBounceBuy
    for i = 1 to bbBounceLookback 
        if low[i] <= bbMiddle[i]
            touchedBbMidBuy := true
            break
if useBbMidBounceSell
    for i = 1 to bbBounceLookback 
        if high[i] >= bbMiddle[i]
            touchedBbMidSell := true
            break
bool rsiConfirmsBbBuy = not rsiConfirmBbBounce or (priceRsi > 40 and priceRsi > priceRsi[1])
bool rsiConfirmsBbSell = not rsiConfirmBbBounce or (priceRsi < 60 and priceRsi < priceRsi[1])
condBbMidBounceBuy = useBbMidBounceBuy and touchedBbMidBuy and close > bbMiddle and close > open and rsiConfirmsBbBuy
condBbMidBounceSell = useBbMidBounceSell and touchedBbMidSell and close < bbMiddle and close < open and rsiConfirmsBbSell

// --- Confidence Score & Reason Calculation --- 
float buyScore_bar = 0.0
float sellScore_bar = 0.0
string bullReason_bar = ""
string bearReason_bar = ""

if condEmaTrendOkBuy
    buyScore_bar += wEmaTrend
    bullReason_bar += "ET+"
else if condEmaTrendOkSell
    sellScore_bar += wEmaTrend
    bearReason_bar += "ET-"

if condEmaFastSlowCrossBuy
    buyScore_bar += wEmaSignal
    bullReason_bar += "ES+"
if condEmaFastSlowCrossSell
    sellScore_bar += wEmaSignal
    bearReason_bar += "ES-"

if condRsiBuy
    buyScore_bar += wRsiThresh
    bullReason_bar += "R+"
if condRsiSell
    sellScore_bar += wRsiThresh
    bearReason_bar += "R-"

if condMacdSignalCrossBuy
    buyScore_bar += wMacdSignal
    bullReason_bar += "MS+"
if condMacdSignalCrossSell
    sellScore_bar += wMacdSignal
    bearReason_bar += "MS-"

if condMacdZeroCrossBuy
    buyScore_bar += wMacdZero
    bullReason_bar += "MZ+"
if condMacdZeroCrossSell
    sellScore_bar += wMacdZero
    bearReason_bar += "MZ-"

if condVolBreakoutBuy
    buyScore_bar += wVolBreak
    bullReason_bar += "V+"
if condVolBreakoutSell
    sellScore_bar += wVolBreak
    bearReason_bar += "V-"

if condAdxStrengthOk
    if condAdxDirectionOkBuy
        buyScore_bar += wAdxStrength
        bullReason_bar += "AS+"
    if condAdxDirectionOkSell
        sellScore_bar += wAdxStrength
        bearReason_bar += "AS-"

if condAdxDirectionOkBuy
    buyScore_bar += wAdxDirection
    bullReason_bar += "AD+"
if condAdxDirectionOkSell
    sellScore_bar += wAdxDirection
    bearReason_bar += "AD-"

if condHtfFilterOkBuy
    buyScore_bar += wHtfTrend
    bullReason_bar += "HT+"
if condHtfFilterOkSell
    sellScore_bar += wHtfTrend
    bearReason_bar += "HT-"

if condFibBounceBuy
    buyScore_bar += wFibBounce
    bullReason_bar += "FB+"
if condFibBounceSell
    sellScore_bar += wFibBounce
    bearReason_bar += "FB-"

if condEmaBounceBuy
    buyScore_bar += wEmaBounce
    bullReason_bar += "EB+"
if condEmaBounceSell
    sellScore_bar += wEmaBounce
    bearReason_bar += "EB-"

if condBbMidBounceBuy
    buyScore_bar += wBbBounce
    bullReason_bar += "BB+"
if condBbMidBounceSell
    sellScore_bar += wBbBounce
    bearReason_bar += "BB-"

totalPossibleScore = wEmaTrend + wEmaSignal + wRsiThresh + wMacdSignal + wMacdZero + wVolBreak + wAdxStrength + wAdxDirection + wHtfTrend + wFibBounce + wEmaBounce + wBbBounce 
totalPossibleScore := math.max(1, totalPossibleScore) 
netScore = buyScore_bar - sellScore_bar
scaledScore = (netScore / totalPossibleScore) * 5.0 + 5.0 
scaledScore := math.max(0.0, math.min(10.0, scaledScore))

// --- RSI Divergence ---
rsiPeak = ta.pivothigh(priceRsi, 5, 2) 
rsiTrough = ta.pivotlow(priceRsi, 5, 2)
pricePeak = ta.pivothigh(high, 5, 2)
priceTrough = ta.pivotlow(low, 5, 2)
validRsiTrough = not na(rsiTrough[1]) and not na(priceTrough[1])
validRsiPeak = not na(rsiPeak[1]) and not na(pricePeak[1])
bullishRsiDiv = validRsiTrough and priceRsi > rsiTrough[1] and low < priceTrough[1] 
bearishRsiDiv = validRsiPeak and priceRsi < rsiPeak[1] and high > pricePeak[1] 
condRsiBullDivExit = useRsiDivExit and bearishRsiDiv 
condRsiBearDivExit = useRsiDivExit and bullishRsiDiv 
// === ENHANCEMENTS ===
// 1. Added dynamic position sizing with risk management
// 2. Implemented adaptive stop loss system
// 3. Added trade cooldown period between signals
// 4. Enhanced exit logic with partial profit taking
// 5. Improved market regime filtering
// 6. Added trade statistics tracking
// 7. Optimized entry confirmation with price action

// === NEW INPUTS ===
grpRisk = "Enhanced Risk Management"
riskPercent = input.float(1.0, "Risk % per Trade", minval=0.1, maxval=5.0, step=0.1, group=grpRisk)
maxTradeDuration = input.int(50, "Max Trade Duration (Bars)", minval=5, maxval=100, group=grpRisk)
cooldownBars = input.int(3, "Cooldown Bars After Exit", minval=0, maxval=10, group=grpRisk)
usePartialExit = input.bool(true, "Use Partial Profit Taking?", group=grpRisk)
partialExitPercent = input.float(50, "% to Take at 1st Target", minval=10, maxval=90, group=grpRisk)
confirmWithClose = input.bool(true, "Require Close Confirmation?", group=grpRisk, 
     tooltip="Wait for candle close before entering trades")

grpAdvanced = "Advanced Filters"
useRegimeFilter = input.bool(true, "Use Market Regime Filter?", group=grpAdvanced)
//minBBWidth = input.float(0.3, "Min BB Width Factor", minval=0.1, maxval=1.0, step=0.1, group=grpAdvanced)
maxDailyLoss = input.float(2.0, "Max Daily Loss %", minval=0.5, maxval=5.0, step=0.1, group=grpAdvanced)

// === ENHANCED RISK MANAGEMENT ===
var float dailyHighEquity = na
var float dailyLowEquity = na
var bool tradeLockout = false

// --- Entry Logic ---
isPotentialEmaBuy = condEmaFastSlowCrossBuy and allFiltersOkBuy 
isPotentialFibBuy = condFibBounceBuy and allFiltersOkBuy 
isPotentialEmaBounceBuy = condEmaBounceBuy and allFiltersOkBuy 
isPotentialBbMidBounceBuy = condBbMidBounceBuy and allFiltersOkBuy 
isPotentialVolBuy = useVolBreakoutBuy and condVolBreakoutBuy and allFiltersOkBuy

isPotentialEmaSell = condEmaFastSlowCrossSell and allFiltersOkSell 
isPotentialFibSell = condFibBounceSell and allFiltersOkSell 
isPotentialEmaBounceSell = condEmaBounceSell and allFiltersOkSell 
isPotentialBbMidBounceSell = condBbMidBounceSell and allFiltersOkSell 
isPotentialVolSell = useVolBreakoutSell and condVolBreakoutSell and allFiltersOkSell
// Original lines:
// plotSignalBuy = (isPotentialEmaBuy or isPotentialFibBuy or isPotentialEmaBounceBuy or isPotentialBbMidBounceBuy or isPotentialVolBuy) and not skipTrade
// plotSignalSell = (isPotentialEmaSell or isPotentialFibSell or isPotentialEmaBounceSell or isPotentialBbMidBounceSell or isPotentialVolSell) and not skipTrade

// --- Modify them like this: ---
plotSignalBuy = (isPotentialEmaBuy or isPotentialFibBuy or isPotentialEmaBounceBuy or isPotentialBbMidBounceBuy or isPotentialVolBuy) and (not useSkipTradeFilter or not skipTrade)
plotSignalSell = (isPotentialEmaSell or isPotentialFibSell or isPotentialEmaBounceSell or isPotentialBbMidBounceSell or isPotentialVolSell) and (not useSkipTradeFilter or not skipTrade)
//plotSignalBuy = isPotentialEmaBuy or isPotentialFibBuy or isPotentialEmaBounceBuy or isPotentialBbMidBounceBuy or isPotentialVolBuy
//plotSignalSell = isPotentialEmaSell or isPotentialFibSell or isPotentialEmaBounceSell or isPotentialBbMidBounceSell or isPotentialVolSell
// Update Trade State

/// Determine signal type for plotting/alerting distinction
    // --- State Tracking ---
var bool inLong = false 
var bool inShort = false
var float stopLossLevel = na
var float fibTargetLevelExit = na
var float entryPrice = na
var string exitReason = "" 
var bool wasInLong = false
var bool wasInShort = false
wasInLong := inLong
wasInShort := inShort
var float entryEquity = na
var float tradePnL = na
var int barsHeld = 0
var int atrStopHitLongCount = 0
var int atrStopHitShortCount = 0
var int lastTradeBar = na

canReEnter = na(lastTradeBar) or (bar_index - lastTradeBar > cooldownBars)


string buySignalType = na 
if isPotentialBbMidBounceBuy
    buySignalType := "BB"
if isPotentialEmaBounceBuy
    buySignalType := "EB"
if isPotentialVolBuy
    buySignalType := "Vol"
if isPotentialFibBuy
    buySignalType := "Fib"
if isPotentialEmaBuy
    buySignalType := "EMA"

string sellSignalType = na 
if isPotentialBbMidBounceSell
    sellSignalType := "BB"
if isPotentialEmaBounceSell
    sellSignalType := "EB"
if isPotentialVolSell
    sellSignalType := "Vol"
if isPotentialFibSell
    sellSignalType := "Fib"
if isPotentialEmaSell
    sellSignalType := "EMA"

isNewTradeBuy = plotSignalBuy and not wasInLong
isNewTradeSell = plotSignalSell and not wasInShort
float scoreOnBuySignal = plotSignalBuy ? scaledScore : na
float scoreOnSellSignal = plotSignalSell ? scaledScore : na
if isNewTradeBuy
    inLong := true, inShort := false, entryPrice := close, stopLossLevel := low - atrVal * atrMult
    swingLowPriceExit = lowestForFibExit, swingRangeFibExit = entryPrice - swingLowPriceExit
    fibTargetLevelExit := swingRangeFibExit > 0 and useFibExit ? entryPrice + swingRangeFibExit * fibExtensionLevel : na
    exitReason := "" 
    lastTradeBar := bar_index
    entryEquity := close
    tradePnL := na
    barsHeld := 0
if isNewTradeSell
    inShort := true, inLong := false, entryPrice := close, stopLossLevel := high + atrVal * atrMult
    swingHighPriceExit = highestForFibExit, swingRangeFibExit = swingHighPriceExit - entryPrice
    fibTargetLevelExit := swingRangeFibExit > 0 and useFibExit ? entryPrice - swingRangeFibExit * fibExtensionLevel : na
    exitReason := "" 
    lastTradeBar := bar_index
    entryEquity := close
    tradePnL := na
    barsHeld := 0
// Reset daily levels at session start
if not na(ta.change(time("D")))
    dailyHighEquity := strategy.equity
    dailyLowEquity := strategy.equity
else
    dailyHighEquity := math.max(dailyHighEquity, strategy.equity)
    dailyLowEquity := math.min(dailyLowEquity, strategy.equity)

dailyDrawdown = (dailyHighEquity - dailyLowEquity) / dailyHighEquity * 100
exceededDailyLoss = dailyDrawdown >= maxDailyLoss

// === ENHANCED MARKET REGIME FILTER ===
//bbWidth = bbUpper - bbLower
avgBBWidth = ta.sma(bbWidth, 20)
isExpanding = bbWidth > avgBBWidth * 1.2
isContracting = bbWidth < avgBBWidth * 0.8
isTrending = adxVal > 25 and math.abs(diPos - diNeg) > 15
isNeutral = adxVal < 20 and math.abs(diPos - diNeg) < 10

// Modify filters based on regime
if useRegimeFilter
    allFiltersOkBuy := allFiltersOkBuy and (isTrending or isExpanding)
    allFiltersOkSell := allFiltersOkSell and (isTrending or isExpanding)

// === ENHANCED POSITION SIZING ===
positionSize() =>
    riskAmount = strategy.equity * riskPercent / 100
    atrDistance = atrVal * atrMult
    positionValue = riskAmount / (atrDistance / close)
    positionValue / close // Return number of shares/contracts

// === ENHANCED ENTRY CONFIRMATION ===
// Wait for close confirmation if enabled
confirmedSignalBuy = confirmWithClose ? plotSignalBuy and barstate.isconfirmed : plotSignalBuy
confirmedSignalSell = confirmWithClose ? plotSignalSell and barstate.isconfirmed : plotSignalSell

// === ENTRY/EXECUTION LOGIC ===
var int lastExitBar = na
canTrade = na(lastExitBar) or (bar_index - lastExitBar > cooldownBars) and not exceededDailyLoss

// Simplified entry logic while maintaining your original conditions:
enterLong = confirmedSignalBuy and canTrade and not tradeLockout
enterShort = confirmedSignalSell and canTrade and not tradeLockout

if (enterLong)
    strategy.entry("Long", strategy.long, qty=positionSize())
    if usePartialExit
        strategy.exit("Long Exit1", "Long", qty_percent=partialExitPercent,limit=entryPrice + (atrVal * 2),stop=stopLossLevel)
        strategy.exit("Long Exit2", "Long",limit=fibTargetLevelExit,stop=stopLossLevel)
    else
        strategy.exit("Long Exit", "Long", 
             limit=fibTargetLevelExit, 
             stop=stopLossLevel)
    
if (enterShort)
    strategy.entry("Short", strategy.short, qty=positionSize())
    if usePartialExit
        strategy.exit("Short Exit1", "Short", qty_percent=partialExitPercent,
             limit=entryPrice - (atrVal * 2),
             stop=stopLossLevel)
        strategy.exit("Short Exit2", "Short",
             limit=fibTargetLevelExit,
             stop=stopLossLevel)
    else
        strategy.exit("Short Exit", "Short",
             limit=fibTargetLevelExit,
             stop=stopLossLevel)
// Exit Conditions

// --- Exit Logic --- 

exitedLongThisBar = false
exitedShortThisBar = false
atrStopFiredLong = false
atrStopFiredShort = false
exitReason_bar = "" 

if wasInLong 
    atrStopHitLong = useAtrStop and close < stopLossLevel
    fibHitLong = useFibExit and not na(fibTargetLevelExit) and high >= fibTargetLevelExit
    scoreDropExitLong = scaledScore < (5.0 - exitScoreDropThreshold)
    emaExitLong = useEmaExit and condEmaFastMedCrossSell
    bbExitLong = useBBReturnExit and condBbReturnMeanSell 
    volExitLong = useVolFadeExit and condVolFadeLong
    rsiDivExitLong = condRsiBullDivExit 
    
    if atrStopHitLong
        exitedLongThisBar := true
        exitReason_bar := "ATR SL"
        atrStopFiredLong := true
    else if fibHitLong
        exitedLongThisBar := true
        exitReason_bar := "Fib Tgt"
    else if scoreDropExitLong
        exitedLongThisBar := true
        exitReason_bar := "Score Drop (" + str.tostring(scaledScore, "#.#") + ")"
    else if emaExitLong
        exitedLongThisBar := true
        exitReason_bar := "EMA Cross"
    else if bbExitLong
        exitedLongThisBar := true
        exitReason_bar := "BB Mid Exit"
    else if volExitLong
        exitedLongThisBar := true
        exitReason_bar := "Vol Fade"
    else if rsiDivExitLong
        exitedLongThisBar := true
        exitReason_bar := "RSI Div"

if wasInShort 
    atrStopHitShort = useAtrStop and close > stopLossLevel
    fibHitShort = useFibExit and not na(fibTargetLevelExit) and low <= fibTargetLevelExit
    scoreDropExitShort = scaledScore > (5.0 + exitScoreDropThreshold)
    emaExitShort = useEmaExit and condEmaFastMedCrossBuy
    bbExitShort = useBBReturnExit and condBbReturnMeanBuy 
    volExitShort = useVolFadeExit and condVolFadeShort
    rsiDivExitShort = condRsiBearDivExit 
    
    if atrStopHitShort
        exitedShortThisBar := true
        exitReason_bar := "ATR SL"
        atrStopFiredShort := true
    else if fibHitShort
        exitedShortThisBar := true
        exitReason_bar := "Fib Tgt"
    else if scoreDropExitShort
        exitedShortThisBar := true
        exitReason_bar := "Score Drop (" + str.tostring(scaledScore, "#.#") + ")"
    else if emaExitShort
        exitedShortThisBar := true
        exitReason_bar := "EMA Cross"
    else if bbExitShort
        exitedShortThisBar := true
        exitReason_bar := "BB Mid Exit"
    else if volExitShort
        exitedShortThisBar := true
        exitReason_bar := "Vol Fade"
    else if rsiDivExitShort
        exitedShortThisBar := true
        exitReason_bar := "RSI Div"

// --- Reset State on Exit ---
if exitedLongThisBar
    inLong := false
    stopLossLevel := na
    fibTargetLevelExit := na
    entryPrice := na
    exitReason := exitReason_bar
    
if exitedShortThisBar
    inShort := false
    stopLossLevel := na
    fibTargetLevelExit := na
    entryPrice := na
    exitReason := exitReason_bar
// === PLOTTING ===

// Indicators
plot(emaFast, "Fast EMA", color=color.new(color.blue, 0)) 
plot(emaMed, "Medium EMA", color=color.new(color.orange, 0)) 
plot(emaSlow, "Slow EMA", color=color.new(color.red, 0))
bbMidPlot = plot(showBB ? bbMiddle : na, "BB Middle", color=bbColor, linewidth=1) 
bbUpperPlot = plot(showBB ? bbUpper : na, "BB Upper", color=bbColor, linewidth=1) 
bbLowerPlot = plot(showBB ? bbLower : na, "BB Lower", color=bbColor, linewidth=1)
fill(bbUpperPlot, bbLowerPlot, color=color.new(bbColor, 90), title="BB Fill")

// SL and Target Lines
plot(inLong and useAtrStop ? stopLossLevel : na, "Long SL", color=color.new(color.maroon, 0), style=plot.style_linebr, linewidth=2)
plot(inShort and useAtrStop ? stopLossLevel : na, "Short SL", color=color.new(color.teal, 0), style=plot.style_linebr, linewidth=2)
plot(inLong and useFibExit ? fibTargetLevelExit : na, "Long Tgt", color=color.new(color.fuchsia, 0), style=plot.style_linebr, linewidth=1)
plot(inShort and useFibExit ? fibTargetLevelExit : na, "Short Tgt", color=color.new(color.fuchsia, 0), style=plot.style_linebr, linewidth=1)

// Entry/Exit Signal Shapes with enhanced colors
// Entry/Exit Signal Shapes with enhanced colors (corrected syntax)
// Buy Signals (below bar)
// Entry/Exit Signal Shapes with enhanced colors (fully corrected)
// Buy Signals (below bar)
plotshape(series=isPotentialEmaBuy, title="EMA Buy Signal", location=location.belowbar, color=color.new(#00FF00, 0), style=shape.triangleup, size=size.small) 
plotshape(series=isPotentialFibBuy, title="Fib Buy Signal", location=location.belowbar, color=color.new(#00CC00, 0), style=shape.diamond, size=size.small) 
plotshape(series=isPotentialEmaBounceBuy, title="EMA Bounce Buy", location=location.belowbar, color=color.new(#009900, 0), style=shape.circle, size=size.tiny) 
plotshape(series=isPotentialBbMidBounceBuy, title="BB Mid Bounce Buy", location=location.belowbar, color=color.new(#006600, 0), style=shape.square, size=size.tiny) 
plotshape(series=isPotentialVolBuy, title="Volume Buy Signal", location=location.belowbar, color=color.new(#003300, 0), style=shape.square, size=size.tiny)

// Sell Signals (above bar)
plotshape(series=isPotentialEmaSell, title="EMA Sell Signal", location=location.abovebar, color=color.new(#FF0000, 0), style=shape.triangledown, size=size.small) 
plotshape(series=isPotentialFibSell, title="Fib Sell Signal", location=location.abovebar, color=color.new(#CC0000, 0), style=shape.diamond, size=size.small) 
plotshape(series=isPotentialEmaBounceSell, title="EMA Bounce Sell", location=location.abovebar, color=color.new(#990000, 0), style=shape.circle, size=size.tiny) 
plotshape(series=isPotentialBbMidBounceSell, title="BB Mid Bounce Sell", location=location.abovebar, color=color.new(#660000, 0), style=shape.square, size=size.tiny) 
plotshape(series=isPotentialVolSell, title="Volume Sell Signal", location=location.abovebar, color=color.new(#330000, 0), style=shape.square, size=size.tiny)
plotshape(exitedLongThisBar, "Exit Long Shape", location=location.abovebar, color=color.new(color.maroon, 50), style=shape.cross, size=size.tiny) 
plotshape(exitedShortThisBar, "Exit Short Shape", location=location.belowbar, color=color.new(color.teal, 50), style=shape.cross, size=size.tiny)
// Original line:
// plotshape(skipTrade, title="Skipped Weak Signal", location=location.bottom, color=color.orange, style=shape.xcross, size=size.tiny)

// --- Modify it like this: ---
plotshape(useSkipTradeFilter and skipTrade, title="Skipped Weak Signal", location=location.bottom, color=color.orange, style=shape.xcross, size=size.tiny)// Signal Score Label with enhanced score-based color intensity
signalScoreBuyText = buySignalType + "\n" + str.tostring(scoreOnBuySignal, "#.#") 
signalScoreSellText = sellSignalType + "\n" + str.tostring(scoreOnSellSignal, "#.#") 

// Calculate label positions once
labelBuyY = low - atrVal * 0.1
labelSellY = high + atrVal * 0.1

if plotSignalBuy and not plotSignalBuy[1] and not na(scoreOnBuySignal)
    // Enhanced green intensity calculation (0-10 score → 100-250 intensity)
    greenBase = 100
    greenRange = 150
    greenIntensity = math.round(greenBase + (scoreOnBuySignal/10 * greenRange))
    greenIntensity := math.min(250, math.max(100, greenIntensity)) // Clamp between 100-250
    
    // Create semi-transparent label with white text
    buyLabelColor = color.new(color.rgb(0, greenIntensity, 0), 80) // 80% transparency
    label.new(
         bar_index, labelBuyY, signalScoreBuyText, 
         color=buyLabelColor, 
         textcolor=color.white, 
         style=label.style_label_up, 
         yloc=yloc.price, 
         size=size.small,
         textalign=text.align_center
     )
    
if plotSignalSell and not plotSignalSell[1] and not na(scoreOnSellSignal)
    // Enhanced red intensity calculation (0-10 score → 100-250 intensity)
    redBase = 100
    redRange = 150
    redIntensity = math.round(redBase + (scoreOnSellSignal/10 * redRange))
    redIntensity := math.min(250, math.max(100, redIntensity)) // Clamp between 100-250
    
    // Create semi-transparent label with white text
    sellLabelColor = color.new(color.rgb(redIntensity, 0, 0), 80) // 80% transparency
    label.new(
         bar_index, labelSellY, signalScoreSellText, 
         color=sellLabelColor, 
         textcolor=color.white, 
         style=label.style_label_down, 
         yloc=yloc.price, 
         size=size.small,
         textalign=text.align_center
     )
// Background color with intensity based on score
bgcolor(inLong ? color.new(color.green, 85) : inShort ? color.new(color.red, 85) : na)

// Data Window Plotting
plot(scaledScore, "Confidence Score", color=color.new(color.gray,0), display=display.data_window)
plotchar(scaledScore, "Score", "", location.top, display=display.none) 

// === ENTRY CONDITION: Add canReEnter check ===
plotSignalBuy := plotSignalBuy and canReEnter
plotSignalSell := plotSignalSell and canReEnter

// === PLOTTING: Add near data window plotting ===
plot(inLong or inShort ? tradePnL : na, "Live Trade PnL (%)", color=color.new(color.lime, 0), display=display.data_window)
plot(inLong or inShort ? barsHeld : na, "Bars Held", color=color.new(color.orange, 0), display=display.data_window)
plot(atrStopHitLongCount, "Long SL Count", color=color.red, display=display.data_window)
plot(atrStopHitShortCount, "Short SL Count", color=color.teal, display=display.data_window)

// === OPTIONAL LABEL (BONUS): Add near score label block ===
if (inLong or inShort) and not exitedLongThisBar and not exitedShortThisBar
    label.new(bar_index, close, "PnL: " + str.tostring(tradePnL, "#.##") + "%\nBars: " + str.tostring(barsHeld), style=label.style_label_left, color=color.gray, textcolor=color.white, size=size.tiny)

// Risk Management

atrStopMultiplier = input.float(2.0, "ATR Stop Multiplier", minval=0.5, maxval=5.0, step=0.1)

// Dynamic Position Sizing
positionSize = strategy.equity * riskPercent / 100 / (atrVal * atrStopMultiplier)


// Exit Conditions
exitLong = exitedLongThisBar
exitShort = exitedShortThisBar

// === ENHANCED EXIT LOGIC ===
timeExitLong = barsHeld >= maxTradeDuration and inLong
timeExitShort = barsHeld >= maxTradeDuration and inShort

if (exitLong or timeExitLong) and not atrStopFiredLong
    strategy.close("Long", comment=exitReason + (timeExitLong ? " (Time Exit)" : ""))
    lastExitBar := bar_index
    
if (exitShort or timeExitShort) and not atrStopFiredShort
    strategy.close("Short", comment=exitReason + (timeExitShort ? " (Time Exit)" : ""))
    lastExitBar := bar_index

// === ENHANCED VISUALIZATION ===
// Plot dynamic stop levels
plot(strategy.position_size > 0 ? stopLossLevel : na, "Long Stop", color=color.new(color.red, 50), style=plot.style_linebr)
plot(strategy.position_size < 0 ? stopLossLevel : na, "Short Stop", color=color.new(color.red, 50), style=plot.style_linebr)

// === PERFORMANCE TRACKING ===
var float totalTrades = 0
var float winningTrades = 0
var float grossProfit = 0
var float grossLoss = 0

if strategy.closedtrades > 0 and strategy.closedtrades != totalTrades
    lastTradeProfit = strategy.closedtrades.profit(strategy.closedtrades-1)
    if lastTradeProfit > 0
        winningTrades += 1
        grossProfit += lastTradeProfit
    else
        grossLoss += math.abs(lastTradeProfit)
    totalTrades += 1

winRate = totalTrades > 0 ? winningTrades / totalTrades * 100 : 0
profitFactor = grossLoss > 0 ? grossProfit / grossLoss : 1

// === INFO PANEL ===
var table statsTable = table.new(position.top_right, 5, 6, border_width=1)
if barstate.islast
    table.cell(statsTable, 0, 0, "Enhanced CS1 Strategy", bgcolor=color.new(color.blue, 90), text_color=color.white)
    table.cell(statsTable, 0, 1, "Trades: " + str.tostring(totalTrades))
    table.cell(statsTable, 1, 1, "Win Rate: " + str.tostring(winRate, "#.##") + "%")
    table.cell(statsTable, 2, 1, "Profit Factor: " + str.tostring(profitFactor, "#.##"))
    table.cell(statsTable, 0, 2, "Current PnL:", bgcolor=color.new(color.gray, 80))
    table.cell(statsTable, 1, 2, str.tostring(tradePnL, "#.##") + "%", 
         bgcolor=tradePnL >= 0 ? color.new(color.green, 70) : color.new(color.red, 70))
    table.cell(statsTable, 0, 3, "Bars Held:", bgcolor=color.new(color.gray, 80))
    table.cell(statsTable, 1, 3, str.tostring(barsHeld))
    table.cell(statsTable, 0, 4, "Daily Drawdown:", bgcolor=color.new(color.gray, 80))
    table.cell(statsTable, 1, 4, str.tostring(dailyDrawdown, "#.##") + "%",
         bgcolor=dailyDrawdown >= maxDailyLoss ? color.new(color.red, 70) : color.new(color.gray, 70))
    table.cell(statsTable, 0, 5, "Market Regime:", bgcolor=color.new(color.gray, 80))
    table.cell(statsTable, 1, 5, isTrending ? "Trending" : isNeutral ? "Neutral" : "Transition",
         bgcolor=isTrending ? color.new(color.blue, 70) : isNeutral ? color.new(color.gray, 70) : color.new(color.orange, 70))