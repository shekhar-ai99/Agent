{"cells":[{"cell_type":"code","source":["import numpy as np\n","import pandas as pd\n","import os\n","import logging\n","import matplotlib.pyplot as plt\n","from typing import Dict, Any, Optional, Tuple, List\n","from pathlib import Path\n","import argparse\n","from datetime import timedelta\n","from collections import defaultdict # Needed for EnhancedSignalAnalyzer\n","import sys\n","import math # For score calculation\n","\n","# Initialize logging\n","logging.basicConfig(\n","    level=logging.INFO,\n","    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n","    handlers=[\n","        logging.FileHandler('pinescript_strategy_analyzer.log'), # New log file name\n","        logging.StreamHandler()\n","    ]\n",")\n","logger = logging.getLogger(__name__)\n","\n","# Configuration\n","DATA_FOLDER = Path(\"data\")\n","DEFAULT_INPUT_FILE = DATA_FOLDER / \"nifty_historical_data.csv\"\n","DEFAULT_OUTPUT_FILE = DATA_FOLDER / \"pinescript_strategy_analyzer_output.csv\"\n","DEFAULT_PLOT_FILE = DATA_FOLDER / \"pinescript_strategy_analyzer_plot.png\"\n","\n","# --- IndicatorCalculator Class (Calculates base indicators) ---\n","class IndicatorCalculator:\n","    DEFAULT_PARAMS = {\n","        'ema_periods': [9, 14, 21], # Corresponds to fast, med, slow\n","        'macd_params': (12, 26, 9),\n","        'rsi_period': 14,\n","        'bollinger_period': 20,\n","        'bollinger_std': 2,\n","        'atr_period': 14,\n","        'adx_period': 14,\n","        'vol_sma_period': 50,\n","    }\n","\n","    def __init__(self, params: Optional[Dict] = None):\n","        self.params = {**self.DEFAULT_PARAMS, **(params or {})}\n","        # Add derived lengths for easier access if needed elsewhere\n","        self.params['emaFastLen'] = self.params['ema_periods'][0]\n","        self.params['emaMedLen'] = self.params['ema_periods'][1]\n","        self.params['emaSlowLen'] = self.params['ema_periods'][2]\n","        self.params['bbLen'] = self.params['bollinger_period']\n","        self.params['rsiLen'] = self.params['rsi_period']\n","        self.params['atrLen'] = self.params['atr_period']\n","        self.params['adxLen'] = self.params['adx_period']\n","        self.params['volMALen'] = self.params['vol_sma_period']\n","        self._validate_params()\n","\n","    def _validate_params(self) -> None:\n","        periods_to_check = [\n","            *self.params['ema_periods'], self.params['rsi_period'],\n","            self.params['bollinger_period'], self.params['atr_period'],\n","            self.params['adx_period'], self.params['vol_sma_period']\n","        ]\n","        if any(p <= 0 for p in periods_to_check): raise ValueError(\"All periods must be positive integers\")\n","        if self.params['bollinger_std'] <= 0: raise ValueError(\"Bollinger standard deviation must be positive\")\n","\n","    def validate_dataframe(self, df: pd.DataFrame) -> None:\n","        required_columns = ['open', 'high', 'low', 'close', 'volume']\n","        missing = [col for col in required_columns if col not in df.columns]\n","        if missing: raise ValueError(f\"Missing required columns: {missing}\")\n","        for col in required_columns:\n","            if not pd.api.types.is_numeric_dtype(df[col]): raise ValueError(f\"Column {col} must be numeric\")\n","        min_period = max([p for p in self.params.values() if isinstance(p, int) and p > 0] + [max(p) for p in self.params.values() if isinstance(p, list) and p])\n","        if len(df) < min_period: logger.warning(f\"Limited data points ({len(df)}) may affect indicator accuracy (min {min_period} recommended)\")\n","        if (df['high'] < df['low']).any(): raise ValueError(\"High price cannot be less than low price\")\n","        if (df['close'] > df['high']).any() or (df['close'] < df['low']).any(): raise ValueError(\"Close price must be between high and low\")\n","        if (df['volume'] < 0).any(): raise ValueError(\"Volume cannot be negative\")\n","\n","    def calculate_emas(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            df['emaFast'] = df['close'].ewm(span=self.params['emaFastLen'], adjust=False, min_periods=1).mean()\n","            df['emaMed'] = df['close'].ewm(span=self.params['emaMedLen'], adjust=False, min_periods=1).mean()\n","            df['emaSlow'] = df['close'].ewm(span=self.params['emaSlowLen'], adjust=False, min_periods=1).mean()\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating EMAs: {str(e)}\"); raise\n","\n","    def calculate_macd(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            fast, slow, signal = self.params['macd_params']\n","            ema_fast = df['close'].ewm(span=fast, adjust=False, min_periods=1).mean()\n","            ema_slow = df['close'].ewm(span=slow, adjust=False, min_periods=1).mean()\n","            df['macdLine'] = ema_fast - ema_slow\n","            df['signalLine'] = df['macdLine'].ewm(span=signal, adjust=False, min_periods=1).mean()\n","            df['histLine'] = df['macdLine'] - df['signalLine']\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating MACD: {str(e)}\"); raise\n","\n","    def calculate_rsi(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['rsiLen']; delta = df['close'].diff()\n","            if len(delta) < period: logger.warning(f\"Insufficient data for RSI ({len(delta)} points)\"); df['priceRsi'] = np.nan; return df\n","            gain = delta.where(delta > 0, 0.0); loss = -delta.where(delta < 0, 0.0)\n","            avg_gain = gain.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            avg_loss = loss.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            rs = avg_gain / avg_loss.replace(0, 1e-6)\n","            df['priceRsi'] = 100.0 - (100.0 / (1.0 + rs))\n","            df['priceRsi'] = df['priceRsi'].fillna(50); df['priceRsi'] = df['priceRsi'].clip(0, 100)\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating RSI: {str(e)}\"); raise\n","\n","    def calculate_bollinger_bands(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['bbLen']; std_dev = self.params['bollinger_std']\n","            sma = df['close'].rolling(window=period, min_periods=1).mean()\n","            rolling_std = df['close'].rolling(window=period, min_periods=1).std()\n","            df['bbUpper'] = sma + (std_dev * rolling_std)\n","            df['bbLower'] = sma - (std_dev * rolling_std)\n","            df['bbMiddle'] = sma\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating Bollinger Bands: {str(e)}\"); raise\n","\n","    def calculate_atr(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['atrLen']\n","            high_low = df['high'] - df['low']\n","            high_close = (df['high'] - df['close'].shift()).abs()\n","            low_close = (df['low'] - df['close'].shift()).abs()\n","            true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)\n","            df['atrVal'] = true_range.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating ATR: {str(e)}\"); raise\n","\n","    def calculate_adx(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['adxLen']\n","            if 'atrVal' not in df.columns: df = self.calculate_atr(df)\n","            up_move = df['high'].diff(); down_move = -df['low'].diff()\n","            plus_dm = ((up_move > down_move) & (up_move > 0)) * up_move\n","            minus_dm = ((down_move > up_move) & (down_move > 0)) * down_move\n","            plus_dm = plus_dm.fillna(0); minus_dm = minus_dm.fillna(0)\n","            smooth_plus_dm = plus_dm.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            smooth_minus_dm = minus_dm.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            atr_smoothed = df['atrVal'].replace(0, 1e-6)\n","            df['diPos'] = 100 * (smooth_plus_dm / atr_smoothed)\n","            df['diNeg'] = 100 * (smooth_minus_dm / atr_smoothed)\n","            di_sum = (df['diPos'] + df['diNeg']).replace(0, 1e-6)\n","            dx = 100 * (abs(df['diPos'] - df['diNeg']) / di_sum)\n","            df['adxVal'] = dx.ewm(alpha=1/period, adjust=False, min_periods=period).mean()\n","            df[['diPos', 'diNeg', 'adxVal']] = df[['diPos', 'diNeg', 'adxVal']].fillna(0)\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating ADX: {str(e)}\"); raise\n","\n","    def calculate_volume_sma(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            period = self.params['volMALen']\n","            df['volMA'] = df['volume'].rolling(window=period, min_periods=1).mean()\n","            return df\n","        except Exception as e: logger.error(f\"Error calculating Volume SMA: {str(e)}\"); raise\n","\n","    def calculate_all_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n","        try:\n","            self.validate_dataframe(df)\n","            df = df.copy()\n","            logger.info(\"Calculating EMAs...\")\n","            df = self.calculate_emas(df)\n","            logger.info(\"Calculating MACD...\")\n","            df = self.calculate_macd(df)\n","            logger.info(\"Calculating RSI...\")\n","            df = self.calculate_rsi(df)\n","            logger.info(\"Calculating Bollinger Bands...\")\n","            df = self.calculate_bollinger_bands(df)\n","            logger.info(\"Calculating ATR...\")\n","            df = self.calculate_atr(df)\n","            logger.info(\"Calculating ADX...\")\n","            df = self.calculate_adx(df)\n","            logger.info(\"Calculating Volume SMA...\")\n","            df = self.calculate_volume_sma(df)\n","            logger.info(f\"Successfully calculated indicators\")\n","            max_lookback = max([p for p in self.params.values() if isinstance(p, int) and p > 0] + [max(p) for p in self.params.values() if isinstance(p, list) and p])\n","            df = df.iloc[max_lookback:].copy()\n","            logger.info(f\"Dropped initial {max_lookback} rows with NaNs, final shape: {df.shape}\")\n","            return df\n","        except Exception as e: logger.error(f\"Indicator calculation failed: {str(e)}\", exc_info=True); raise\n","\n","\n","# --- Strategy Parameters (Derived from PineScript Inputs) ---\n","PARAMS: Dict[str, Dict[str, Any]] = {\n","    'backtest': { 'commission_pct': 0.0005, 'slippage_pct': 0.0002, 'filter_last_month': True },\n","    'core': { \"max_trade_duration\": 50, 'exitScoreDropThreshold': 1.5, 'useFibBounceEntry': True, 'useFibBounceSell': True, 'fibBounceLookback': 3, 'useEmaBounceBuy': True, 'useEmaBounceSell': True, 'emaBounceLookback': 2, 'emaBounceSource': \"Fast EMA\", 'useBbMidBounceBuy': True, 'useBbMidBounceSell': True, 'bbBounceLookback': 2, 'useVolBreakoutBuy': True, 'useVolBreakoutSell': True, 'trailing_stop_type': \"atr\", 'trailing_stop_pct': 0.02, 'trailing_stop_atr_multiplier': 2.0, # Default from PineScript atrMult\n","              'profit_protection_levels': {'level1': {'profit_pct': 0.05, 'new_atr_mult': 1.0}, 'level2': {'profit_pct': 0.10, 'new_atr_mult': 0.5}}}, # Keep profit protection example\n","    'ema': { 'useEmaExit': True }, # Lengths defined in IndicatorCalculator\n","    'bollinger': { 'useBBReturnExit': True }, # Length/StdDev defined in IndicatorCalculator\n","    'rsi': { 'rsiBuyLevel': 55.0, 'rsiSellLevel': 45.0, 'useRsiDivExit': False, 'rsiConfirmFibBounce': True, 'rsiConfirmEmaBounce': False, 'rsiConfirmBbBounce': False, 'rsi_confirm_level_buy': 40.0, 'rsi_confirm_level_sell': 60.0 }, # Length defined in IndicatorCalculator\n","    'macd': {}, # Lengths defined in IndicatorCalculator\n","    'volume': { 'volMultiplier': 1.5, 'useVolFadeExit': True }, # Length defined in IndicatorCalculator\n","    'atr': { 'useAtrStop': True }, # Length defined in IndicatorCalculator\n","    'fibonacci': { 'useFibExit': True, 'fibLookbackExit': 30, 'fibExtensionLevel': 1.618, 'fibPivotLookback': 15, 'fibMaxBars': 200 },\n","    'trend': { 'useEmaTrendFilter': True, 'useAdxFilter': True, 'adxThreshold': 20.0, 'useAdxDirectionFilter': True }, # Length defined in IndicatorCalculator\n","    'score_weights': { 'wEmaTrend': 2, 'wEmaSignal': 1, 'wRsiThresh': 1, 'wMacdSignal': 1, 'wMacdZero': 1, 'wVolBreak': 1, 'wAdxStrength': 1, 'wAdxDirection': 1, 'wHtfTrend': 0, # HTF not implemented, set weight to 0\n","                       'wFibBounce': 2, 'wEmaBounce': 1, 'wBbBounce': 1, }\n","}\n","\n","# --- TradeState Class ---\n","class TradeState:\n","    def __init__(self):\n","        self.position = None # 'Long', 'Short', or None\n","        self.entry_price = np.nan\n","        self.entry_index = -1\n","        self.stopLossLevel = np.nan # Matches PineScript var name\n","        self.fibTargetLevelExit = np.nan # Matches PineScript var name\n","        self.highest_high_in_trade = np.nan\n","        self.lowest_low_in_trade = np.nan\n","        self.time_in_trade = 0\n","\n","    def reset(self):\n","        self.__init__()\n","\n","    def update_trailing_stop(self, current_low, current_high, atrVal):\n","        \"\"\"Updates the ATR trailing stop loss based on PineScript logic.\"\"\"\n","        if self.position is None or pd.isna(atrVal) or pd.isna(self.stopLossLevel):\n","            return # No position or ATR/initial SL not available\n","\n","        atr_mult = PARAMS['core']['trailing_stop_atr_multiplier']\n","\n","        if self.position == 'Long':\n","            newStopLong = current_low - atrVal * atr_mult\n","            self.stopLossLevel = max(self.stopLossLevel, newStopLong)\n","        elif self.position == 'Short':\n","            newStopShort = current_high + atrVal * atr_mult\n","            self.stopLossLevel = min(self.stopLossLevel, newStopShort)\n","\n","\n","# --- Feature Calculation Functions ---\n","def calculate_fibonacci_levels(df: pd.DataFrame) -> pd.DataFrame:\n","    logger.debug(\"Calculating Fibonacci levels (strategy feature)\")\n","    try:\n","        lookback = PARAMS['fibonacci']['fibPivotLookback']; max_bars = PARAMS['fibonacci']['fibMaxBars']\n","        df['rolling_high'] = df['high'].rolling(window=2 * lookback + 1, center=True, min_periods=lookback//2+1).max()\n","        df['rolling_low'] = df['low'].rolling(window=2 * lookback + 1, center=True, min_periods=lookback//2+1).min()\n","        df['is_pivot_high'] = df['high'] == df['rolling_high']; df['is_pivot_low'] = df['low'] == df['rolling_low']\n","        df['last_pivot_high_price'] = df.loc[df['is_pivot_high'], 'high'].ffill().shift()\n","        df['last_pivot_high_idx'] = df.loc[df['is_pivot_high']].index.to_series().ffill().shift()\n","        df['last_pivot_low_price'] = df.loc[df['is_pivot_low'], 'low'].ffill().shift()\n","        df['last_pivot_low_idx'] = df.loc[df['is_pivot_low']].index.to_series().ffill().shift()\n","        current_bar_indices = np.arange(len(df))\n","        df['last_pivot_high_idx_num'] = df['last_pivot_high_idx'].apply(lambda x: df.index.get_loc(x) if pd.notna(x) and x in df.index else np.nan)\n","        df['last_pivot_low_idx_num'] = df['last_pivot_low_idx'].apply(lambda x: df.index.get_loc(x) if pd.notna(x) and x in df.index else np.nan)\n","        high_too_old = (current_bar_indices - df['last_pivot_high_idx_num']) > max_bars\n","        low_too_old = (current_bar_indices - df['last_pivot_low_idx_num']) > max_bars\n","        df.loc[high_too_old, ['last_pivot_high_price', 'last_pivot_high_idx', 'last_pivot_high_idx_num']] = np.nan\n","        df.loc[low_too_old, ['last_pivot_low_price', 'last_pivot_low_idx', 'last_pivot_low_idx_num']] = np.nan\n","        df['last_pivot_high_idx_num'] = df['last_pivot_high_idx_num'].fillna(-1)\n","        df['last_pivot_low_idx_num'] = df['last_pivot_low_idx_num'].fillna(-1)\n","        is_uptrend_fib = (df['last_pivot_high_idx_num'] > df['last_pivot_low_idx_num'])\n","        swing_high = np.where(is_uptrend_fib, df['last_pivot_high_price'], df['last_pivot_low_price'])\n","        swing_low = np.where(is_uptrend_fib, df['last_pivot_low_price'], df['last_pivot_high_price'])\n","        fib_range = swing_high - swing_low; fib_range[fib_range <= 0] = np.nan\n","        level_0 = np.where(is_uptrend_fib, swing_low, swing_high); level_100 = np.where(is_uptrend_fib, swing_high, swing_low)\n","        df['fib_0'] = level_0; df['fib_236'] = level_0 + fib_range * 0.236; df['fib_382'] = level_0 + fib_range * 0.382\n","        df['fib_500'] = level_0 + fib_range * 0.500; df['fib_618'] = level_0 + fib_range * 0.618; df['fib_786'] = level_0 + fib_range * 0.786\n","        df['fib_100'] = level_100; df['is_uptrend_fib'] = is_uptrend_fib\n","        df = df.drop(columns=[ 'rolling_high', 'rolling_low', 'is_pivot_high', 'is_pivot_low', 'last_pivot_high_price', 'last_pivot_high_idx', 'last_pivot_low_price', 'last_pivot_low_idx', 'last_pivot_high_idx_num', 'last_pivot_low_idx_num'], errors='ignore')\n","        return df\n","    except Exception as e: logger.error(f\"Error in calculate_fibonacci_levels: {str(e)}\", exc_info=True); raise\n","\n","def calculate_rsi_divergence(df: pd.DataFrame) -> pd.DataFrame:\n","    logger.debug(f\"Calculating RSI divergence\")\n","    try:\n","        if 'priceRsi' not in df.columns: logger.error(\"RSI column 'priceRsi' missing\"); df['bullish_rsi_div'] = False; df['bearish_rsi_div'] = False; return df\n","        lookback = 5 ; rsi_lookback = 2\n","        df['bullish_rsi_div'] = False; df['bearish_rsi_div'] = False\n","        # Simplified check using rolling min/max\n","        df['price_low_roll'] = df['low'].rolling(window=lookback, closed='left').min()\n","        df['rsi_low_roll'] = df['priceRsi'].rolling(window=lookback, closed='left').min()\n","        df['price_high_roll'] = df['high'].rolling(window=lookback, closed='left').max()\n","        df['rsi_high_roll'] = df['priceRsi'].rolling(window=lookback, closed='left').max()\n","        df['bullish_rsi_div'] = (df['low'] < df['price_low_roll']) & (df['priceRsi'] > df['rsi_low_roll'])\n","        df['bearish_rsi_div'] = (df['high'] > df['price_high_roll']) & (df['priceRsi'] < df['rsi_high_roll'])\n","        df = df.drop(columns=['price_low_roll', 'rsi_low_roll', 'price_high_roll', 'rsi_high_roll'], errors='ignore')\n","        return df\n","    except Exception as e: logger.error(f\"Error in calculate_rsi_divergence: {str(e)}\", exc_info=True); raise\n","\n","# --- Main Signal Processing Function (Translated from PineScript) ---\n","def process_signals(df: pd.DataFrame) -> pd.DataFrame:\n","    logger.info(\"Starting PineScript strategy signal processing\")\n","    try:\n","        required_cols = ['open', 'high', 'low', 'close', 'volume', 'atrVal', 'priceRsi', 'macdLine', 'signalLine', 'histLine', 'emaFast', 'emaMed', 'emaSlow', 'bbMiddle', 'bbUpper', 'bbLower', 'volMA', 'adxVal', 'diPos', 'diNeg']\n","        missing_cols = [col for col in required_cols if col not in df.columns]\n","        if missing_cols: raise ValueError(f\"DataFrame missing required columns for signal processing: {missing_cols}\")\n","\n","        df = calculate_fibonacci_levels(df)\n","        df = calculate_rsi_divergence(df)\n","\n","        df['signal'] = 'Hold'; df['position'] = ''; df['entry_price'] = np.nan; df['stop_loss'] = np.nan; df['trailing_stop'] = np.nan; df['exit_price'] = np.nan; df['exit_reason'] = ''; df['entry_signal_type'] = ''; df['scaled_score'] = 5.0\n","\n","        start_index = max( PARAMS['fibonacci']['fibPivotLookback'] * 2 + 1, PARAMS['fibonacci']['fibLookbackExit'], PARAMS['core']['fibBounceLookback'], PARAMS['core']['emaBounceLookback'], PARAMS['core']['bbBounceLookback'], 5 ) + 1\n","        if start_index >= len(df): logger.warning(f\"Not enough data. Required: {start_index}, Available: {len(df)}\"); return df\n","\n","        logger.info(f\"Starting main processing loop from index {start_index}\")\n","        trade_state = TradeState(); weights = PARAMS['score_weights']\n","        total_possible_score = sum(w for k, w in weights.items() if k != 'wHtfTrend'); total_possible_score = max(1.0, total_possible_score)\n","\n","        for i in range(start_index, len(df)):\n","            current_idx = df.index[i]; prev_idx = df.index[i-1]; current = df.iloc[i]; prev = df.iloc[i-1]\n","            exit_triggered_this_bar = False; exit_price_this_bar = np.nan; exit_reason_bar = ''\n","            wasInLong = trade_state.position == 'Long'; wasInShort = trade_state.position == 'Short'\n","\n","            # Base Conditions\n","            condEmaFastSlowCrossBuy = current['emaFast'] > current['emaSlow'] and prev['emaFast'] <= prev['emaSlow']; condEmaFastSlowCrossSell = current['emaFast'] < current['emaSlow'] and prev['emaFast'] >= prev['emaSlow']\n","            condEmaFastMedCrossBuy = current['emaFast'] > current['emaMed'] and prev['emaFast'] <= prev['emaMed']; condEmaFastMedCrossSell = current['emaFast'] < current['emaMed'] and prev['emaFast'] >= prev['emaMed']\n","            condBbReturnMeanBuy = current['close'] > current['bbMiddle'] and prev['close'] <= prev['bbMiddle']; condBbReturnMeanSell = current['close'] < current['bbMiddle'] and prev['close'] >= prev['bbMiddle']\n","            condRsiBuy = current['priceRsi'] > PARAMS['rsi']['rsiBuyLevel']; condRsiSell = current['priceRsi'] < PARAMS['rsi']['rsiSellLevel']\n","            condMacdSignalCrossBuy = current['macdLine'] > current['signalLine'] and prev['macdLine'] <= prev['signalLine']; condMacdSignalCrossSell = current['macdLine'] < current['signalLine'] and prev['macdLine'] >= prev['signalLine']\n","            condMacdZeroCrossBuy = current['macdLine'] > 0 and prev['macdLine'] <= 0; condMacdZeroCrossSell = current['macdLine'] < 0 and prev['macdLine'] >= 0\n","            condHighVol = current['volume'] > current['volMA'] * PARAMS['volume']['volMultiplier']\n","            condVolBreakoutBuy = condHighVol and current['close'] > current['open'] and current['close'] > current['emaSlow']; condVolBreakoutSell = condHighVol and current['close'] < current['open'] and current['close'] < current['emaSlow']\n","            condVolFadeLong = current['close'] < current['emaFast'] and current['volume'] < current['volMA']; condVolFadeShort = current['close'] > current['emaFast'] and current['volume'] < current['volMA']\n","\n","            # Filters\n","            condEmaTrendOkBuy = not PARAMS['trend']['useEmaTrendFilter'] or current['emaMed'] > current['emaSlow']; condEmaTrendOkSell = not PARAMS['trend']['useEmaTrendFilter'] or current['emaMed'] < current['emaSlow']\n","            condAdxStrengthOk = not PARAMS['trend']['useAdxFilter'] or current['adxVal'] > PARAMS['trend']['adxThreshold']\n","            condAdxDirectionOkBuy = not PARAMS['trend']['useAdxDirectionFilter'] or current['diPos'] > current['diNeg']; condAdxDirectionOkSell = not PARAMS['trend']['useAdxDirectionFilter'] or current['diNeg'] > current['diPos']\n","            condAdxFilterOkBuy = condAdxStrengthOk and condAdxDirectionOkBuy; condAdxFilterOkSell = condAdxStrengthOk and condAdxDirectionOkSell\n","            allFiltersOkBuy = condEmaTrendOkBuy and condAdxFilterOkBuy; allFiltersOkSell = condEmaTrendOkSell and condAdxFilterOkSell\n","\n","            # Dynamic Conditions\n","            condFibBounceBuy = False; condFibBounceSell = False\n","            if PARAMS['core']['useFibBounceEntry'] or PARAMS['core']['useFibBounceSell']:\n","                lookback=PARAMS['core']['fibBounceLookback']; rsi_conf = PARAMS['rsi']['rsiConfirmFibBounce']\n","                if PARAMS['core']['useFibBounceEntry'] and current['is_uptrend_fib']:\n","                    level_618 = current['fib_618']; level_500 = current['fib_500']\n","                    if pd.notna(level_618) and pd.notna(level_500):\n","                        touched_zone = (df['low'].iloc[i-lookback:i] <= level_618).any(); bounced_above = current['close'] > level_500; rsi_ok = not rsi_conf or (current['priceRsi'] > 40 and current['priceRsi'] > prev['priceRsi'])\n","                        if touched_zone and bounced_above and rsi_ok: condFibBounceBuy = True\n","                if PARAMS['core']['useFibBounceSell'] and not current['is_uptrend_fib']:\n","                    level_382 = current['fib_382']; level_500 = current['fib_500']\n","                    if pd.notna(level_382) and pd.notna(level_500):\n","                        touched_zone = (df['high'].iloc[i-lookback:i] >= level_382).any(); bounced_below = current['close'] < level_500; rsi_ok = not rsi_conf or (current['priceRsi'] < 60 and current['priceRsi'] < prev['priceRsi'])\n","                        if touched_zone and bounced_below and rsi_ok: condFibBounceSell = True\n","            condEmaBounceBuy = False; condEmaBounceSell = False\n","            if PARAMS['core']['useEmaBounceBuy'] or PARAMS['core']['useEmaBounceSell']:\n","                lookback=PARAMS['core']['emaBounceLookback']; ema_source_col = 'emaFast' if PARAMS['core']['emaBounceSource'] == \"Fast EMA\" else 'emaMed'; ema_source = df[ema_source_col]; rsi_conf = PARAMS['rsi']['rsiConfirmEmaBounce']\n","                if PARAMS['core']['useEmaBounceBuy']:\n","                    aboveEmaBefore = df[ema_source_col].iloc[i-(lookback+1)] < df['close'].iloc[i-(lookback+1)] if i > lookback else False\n","                    touched_ema = (df['low'].iloc[i-lookback:i] <= ema_source.iloc[i-lookback:i]).any(); bounced_above = current['close'] > current[ema_source_col] and current['close'] > current['open']; rsi_ok = not rsi_conf or (current['priceRsi'] > 40 and current['priceRsi'] > prev['priceRsi'])\n","                    if aboveEmaBefore and touched_ema and bounced_above and rsi_ok: condEmaBounceBuy = True\n","                if PARAMS['core']['useEmaBounceSell']:\n","                    belowEmaBefore = df[ema_source_col].iloc[i-(lookback+1)] > df['close'].iloc[i-(lookback+1)] if i > lookback else False\n","                    touched_ema = (df['high'].iloc[i-lookback:i] >= ema_source.iloc[i-lookback:i]).any(); bounced_below = current['close'] < current[ema_source_col] and current['close'] < current['open']; rsi_ok = not rsi_conf or (current['priceRsi'] < 60 and current['priceRsi'] < prev['priceRsi'])\n","                    if belowEmaBefore and touched_ema and bounced_below and rsi_ok: condEmaBounceSell = True\n","            condBbMidBounceBuy = False; condBbMidBounceSell = False\n","            if PARAMS['core']['useBbMidBounceBuy'] or PARAMS['core']['useBbMidBounceSell']:\n","                lookback=PARAMS['core']['bbBounceLookback']; bb_mid = df['bbMiddle']; rsi_conf = PARAMS['rsi']['rsiConfirmBbBounce']\n","                if PARAMS['core']['useBbMidBounceBuy']:\n","                    touched_bb = (df['low'].iloc[i-lookback:i] <= bb_mid.iloc[i-lookback:i]).any(); bounced_above = current['close'] > current['bbMiddle'] and current['close'] > current['open']; rsi_ok = not rsi_conf or (current['priceRsi'] > 40 and current['priceRsi'] > prev['priceRsi'])\n","                    if touched_bb and bounced_above and rsi_ok: condBbMidBounceBuy = True\n","                if PARAMS['core']['useBbMidBounceSell']:\n","                    touched_bb = (df['high'].iloc[i-lookback:i] >= bb_mid.iloc[i-lookback:i]).any(); bounced_below = current['close'] < current['bbMiddle'] and current['close'] < current['open']; rsi_ok = not rsi_conf or (current['priceRsi'] < 60 and current['priceRsi'] < prev['priceRsi'])\n","                    if touched_bb and bounced_below and rsi_ok: condBbMidBounceSell = True\n","\n","            # Score Calculation\n","            buyScore_bar = 0.0; sellScore_bar = 0.0\n","            if condEmaTrendOkBuy: buyScore_bar += weights['wEmaTrend'];\n","            elif condEmaTrendOkSell: sellScore_bar += weights['wEmaTrend']\n","            if condEmaFastSlowCrossBuy: buyScore_bar += weights['wEmaSignal']\n","            if condEmaFastSlowCrossSell: sellScore_bar += weights['wEmaSignal']\n","            if condRsiBuy: buyScore_bar += weights['wRsiThresh']\n","            if condRsiSell: sellScore_bar += weights['wRsiThresh']\n","            if condMacdSignalCrossBuy: buyScore_bar += weights['wMacdSignal']\n","            if condMacdSignalCrossSell: sellScore_bar += weights['wMacdSignal']\n","            if condMacdZeroCrossBuy: buyScore_bar += weights['wMacdZero']\n","            if condMacdZeroCrossSell: sellScore_bar += weights['wMacdZero']\n","            if condVolBreakoutBuy: buyScore_bar += weights['wVolBreak']\n","            if condVolBreakoutSell: sellScore_bar += weights['wVolBreak']\n","            if condAdxStrengthOk:\n","                if condAdxDirectionOkBuy: buyScore_bar += weights['wAdxStrength']\n","                if condAdxDirectionOkSell: sellScore_bar += weights['wAdxStrength']\n","            if condAdxDirectionOkBuy: buyScore_bar += weights['wAdxDirection']\n","            if condAdxDirectionOkSell: sellScore_bar += weights['wAdxDirection']\n","            if condFibBounceBuy: buyScore_bar += weights['wFibBounce']\n","            if condFibBounceSell: sellScore_bar += weights['wFibBounce']\n","            if condEmaBounceBuy: buyScore_bar += weights['wEmaBounce']\n","            if condEmaBounceSell: sellScore_bar += weights['wEmaBounce']\n","            if condBbMidBounceBuy: buyScore_bar += weights['wBbBounce']\n","            if condBbMidBounceSell: sellScore_bar += weights['wBbBounce']\n","            netScore = buyScore_bar - sellScore_bar; scaledScore = max(0.0, min(10.0, ((netScore / total_possible_score) * 5.0) + 5.0)); df.loc[current_idx, 'scaled_score'] = scaledScore\n","\n","            # RSI Div Exit Conditions\n","            condRsiBullDivExit = PARAMS['rsi']['useRsiDivExit'] and current['bearish_rsi_div']; condRsiBearDivExit = PARAMS['rsi']['useRsiDivExit'] and current['bullish_rsi_div']\n","\n","            # --- I. Check for Exits ---\n","            if wasInLong:\n","                atrStopHitLong = PARAMS['atr']['useAtrStop'] and current['close'] < trade_state.stopLossLevel\n","                fibHitLong = PARAMS['fibonacci']['useFibExit'] and pd.notna(trade_state.fibTargetLevelExit) and current['high'] >= trade_state.fibTargetLevelExit\n","                scoreDropExitLong = scaledScore < (5.0 - PARAMS['core']['exitScoreDropThreshold'])\n","                emaExitLong = PARAMS['ema']['useEmaExit'] and condEmaFastMedCrossSell\n","                bbExitLong = PARAMS['bollinger']['useBBReturnExit'] and condBbReturnMeanSell\n","                volExitLong = PARAMS['volume']['useVolFadeExit'] and condVolFadeLong\n","                rsiDivExitLong = condRsiBullDivExit\n","                if atrStopHitLong: exit_reason_bar = \"ATR SL\"; exit_price_this_bar = min(current['open'], trade_state.stopLossLevel); exit_triggered_this_bar = True\n","                elif fibHitLong: exit_reason_bar = \"Fib Tgt\"; exit_price_this_bar = max(current['open'], trade_state.fibTargetLevelExit); exit_triggered_this_bar = True\n","                elif scoreDropExitLong: exit_reason_bar = f\"Score Drop ({scaledScore:.1f})\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n","                elif emaExitLong: exit_reason_bar = \"EMA Cross\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n","                elif bbExitLong: exit_reason_bar = \"BB Mid Exit\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n","                elif volExitLong: exit_reason_bar = \"Vol Fade\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n","                elif rsiDivExitLong: exit_reason_bar = \"RSI Div\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n","                if exit_triggered_this_bar: df.loc[current_idx, 'signal'] = 'Exit Long'; df.loc[current_idx, 'exit_reason'] = exit_reason_bar; df.loc[current_idx, 'exit_price'] = exit_price_this_bar; trade_state.reset()\n","            elif wasInShort:\n","                atrStopHitShort = PARAMS['atr']['useAtrStop'] and current['close'] > trade_state.stopLossLevel\n","                fibHitShort = PARAMS['fibonacci']['useFibExit'] and pd.notna(trade_state.fibTargetLevelExit) and current['low'] <= trade_state.fibTargetLevelExit\n","                scoreDropExitShort = scaledScore > (5.0 + PARAMS['core']['exitScoreDropThreshold'])\n","                emaExitShort = PARAMS['ema']['useEmaExit'] and condEmaFastMedCrossBuy\n","                bbExitShort = PARAMS['bollinger']['useBBReturnExit'] and condBbReturnMeanBuy\n","                volExitShort = PARAMS['volume']['useVolFadeExit'] and condVolFadeShort\n","                rsiDivExitShort = condRsiBearDivExit\n","                if atrStopHitShort: exit_reason_bar = \"ATR SL\"; exit_price_this_bar = max(current['open'], trade_state.stopLossLevel); exit_triggered_this_bar = True\n","                elif fibHitShort: exit_reason_bar = \"Fib Tgt\"; exit_price_this_bar = min(current['open'], trade_state.fibTargetLevelExit); exit_triggered_this_bar = True\n","                elif scoreDropExitShort: exit_reason_bar = f\"Score Drop ({scaledScore:.1f})\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n","                elif emaExitShort: exit_reason_bar = \"EMA Cross\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n","                elif bbExitShort: exit_reason_bar = \"BB Mid Exit\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n","                elif volExitShort: exit_reason_bar = \"Vol Fade\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n","                elif rsiDivExitShort: exit_reason_bar = \"RSI Div\"; exit_price_this_bar = current['close']; exit_triggered_this_bar = True\n","                if exit_triggered_this_bar: df.loc[current_idx, 'signal'] = 'Exit Short'; df.loc[current_idx, 'exit_reason'] = exit_reason_bar; df.loc[current_idx, 'exit_price'] = exit_price_this_bar; trade_state.reset()\n","\n","            # --- II. Check for Entries ---\n","            if trade_state.position is None and not exit_triggered_this_bar:\n","                isPotentialEmaBuy = condEmaFastSlowCrossBuy and allFiltersOkBuy; isPotentialFibBuy = condFibBounceBuy and allFiltersOkBuy; isPotentialEmaBounceBuy = condEmaBounceBuy and allFiltersOkBuy; isPotentialBbMidBounceBuy = condBbMidBounceBuy and allFiltersOkBuy; isPotentialVolBuy = PARAMS['core']['useVolBreakoutBuy'] and condVolBreakoutBuy and allFiltersOkBuy\n","                isPotentialEmaSell = condEmaFastSlowCrossSell and allFiltersOkSell; isPotentialFibSell = condFibBounceSell and allFiltersOkSell; isPotentialEmaBounceSell = condEmaBounceSell and allFiltersOkSell; isPotentialBbMidBounceSell = condBbMidBounceSell and allFiltersOkSell; isPotentialVolSell = PARAMS['core']['useVolBreakoutSell'] and condVolBreakoutSell and allFiltersOkSell\n","                plotSignalBuy = isPotentialEmaBuy or isPotentialFibBuy or isPotentialEmaBounceBuy or isPotentialBbMidBounceBuy or isPotentialVolBuy\n","                plotSignalSell = isPotentialEmaSell or isPotentialFibSell or isPotentialEmaBounceSell or isPotentialBbMidBounceSell or isPotentialVolSell\n","                entry_signal_type = np.nan\n","                if isPotentialBbMidBounceBuy: entry_signal_type = \"BB Bounce Long\";\n","                if isPotentialEmaBounceBuy: entry_signal_type = \"EMA Bounce Long\";\n","                if isPotentialVolBuy: entry_signal_type = \"Vol Breakout Long\";\n","                if isPotentialFibBuy: entry_signal_type = \"Fib Bounce Long\";\n","                if isPotentialEmaBuy: entry_signal_type = \"EMA Cross Long\";\n","                if isPotentialBbMidBounceSell: entry_signal_type = \"BB Bounce Short\";\n","                if isPotentialEmaBounceSell: entry_signal_type = \"EMA Bounce Short\";\n","                if isPotentialVolSell: entry_signal_type = \"Vol Breakout Short\";\n","                if isPotentialFibSell: entry_signal_type = \"Fib Bounce Short\";\n","                if isPotentialEmaSell: entry_signal_type = \"EMA Cross Short\";\n","\n","                if plotSignalBuy:\n","                    entry_price_adj = current['close'] * (1 + PARAMS['backtest']['slippage_pct']); trade_state.position = 'Long'; trade_state.entry_price = entry_price_adj; trade_state.entry_index = i; trade_state.time_in_trade = 0; trade_state.stopLossLevel = current['low'] - current['atrVal'] * PARAMS['core']['trailing_stop_atr_multiplier']; trade_state.highest_high_in_trade = current['high']\n","                    if PARAMS['fibonacci']['useFibExit']:\n","                        lookback_fib = PARAMS['fibonacci']['fibLookbackExit']; lookback_start_fib = max(0, i - lookback_fib); lowest_series = df['low'].iloc[lookback_start_fib : i]\n","                        if not lowest_series.empty: swingLowPriceExit = lowest_series.min(); swingRangeFibExit = entry_price_adj - swingLowPriceExit;\n","                        if swingRangeFibExit > 0: trade_state.fibTargetLevelExit = entry_price_adj + swingRangeFibExit * PARAMS['fibonacci']['fibExtensionLevel']; else: trade_state.fibTargetLevelExit = np.nan\n","                        else: trade_state.fibTargetLevelExit = np.nan\n","                    else: trade_state.fibTargetLevelExit = np.nan\n","                    df.loc[current_idx, 'signal'] = 'Long'; df.loc[current_idx, 'entry_price'] = trade_state.entry_price; df.loc[current_idx, 'stop_loss'] = trade_state.stopLossLevel; df.loc[current_idx, 'entry_signal_type'] = entry_signal_type\n","                elif plotSignalSell:\n","                    entry_price_adj = current['close'] * (1 - PARAMS['backtest']['slippage_pct']); trade_state.position = 'Short'; trade_state.entry_price = entry_price_adj; trade_state.entry_index = i; trade_state.time_in_trade = 0; trade_state.stopLossLevel = current['high'] + current['atrVal'] * PARAMS['core']['trailing_stop_atr_multiplier']; trade_state.lowest_low_in_trade = current['low']\n","                    if PARAMS['fibonacci']['useFibExit']:\n","                        lookback_fib = PARAMS['fibonacci']['fibLookbackExit']; lookback_start_fib = max(0, i - lookback_fib); highest_series = df['high'].iloc[lookback_start_fib : i]\n","                        if not highest_series.empty: swingHighPriceExit = highest_series.max(); swingRangeFibExit = swingHighPriceExit - entry_price_adj;\n","                        if swingRangeFibExit > 0: trade_state.fibTargetLevelExit = entry_price_adj - swingRangeFibExit * PARAMS['fibonacci']['fibExtensionLevel']; else: trade_state.fibTargetLevelExit = np.nan\n","                        else: trade_state.fibTargetLevelExit = np.nan\n","                    else: trade_state.fibTargetLevelExit = np.nan\n","                    df.loc[current_idx, 'signal'] = 'Short'; df.loc[current_idx, 'entry_price'] = trade_state.entry_price; df.loc[current_idx, 'stop_loss'] = trade_state.stopLossLevel; df.loc[current_idx, 'entry_signal_type'] = entry_signal_type\n","\n","            # --- III. Update Trailing Stop ---\n","            if trade_state.position is not None and not exit_triggered_this_bar:\n","                 trade_state.update_trailing_stop(current['low'], current['high'], current['atrVal']); df.loc[current_idx, 'trailing_stop'] = trade_state.stopLossLevel\n","\n","            # --- IV. Update Position State ---\n","            if trade_state.position is not None and df.loc[current_idx, 'signal'] == 'Hold':\n","                df.loc[current_idx, 'position'] = trade_state.position; df.loc[current_idx, 'entry_price'] = trade_state.entry_price\n","\n","        logger.info(\"Finished main processing loop\")\n","        return df\n","    except Exception as e: logger.error(f\"Error in process_signals: {str(e)}\", exc_info=True); raise\n","\n","\n","# --- Plotting Function ---\n","def plot_signals(df: pd.DataFrame, save_path: Optional[Path] = None):\n","    # (Keep plotting function as is from pinescript_to_python_colab)\n","    logger.info(\"Generating signal plot\")\n","    plt.style.use('seaborn-v0_8-darkgrid')\n","    fig, axes = plt.subplots(4, 1, sharex=True, figsize=(20, 15))\n","    if df.empty: logger.warning(\"Plotting skipped: DataFrame is empty.\"); return\n","\n","    ax1 = axes[0] # Price Chart\n","    ax1.plot(df['close'], label='Price', color='black', alpha=0.9, linewidth=1.0)\n","    if 'emaFast' in df.columns: ax1.plot(df['emaFast'], label=f\"EMA Fast\", alpha=0.6, linewidth=0.8)\n","    if 'emaMed' in df.columns: ax1.plot(df['emaMed'], label=f\"EMA Med\", alpha=0.6, linewidth=0.8)\n","    if 'emaSlow' in df.columns: ax1.plot(df['emaSlow'], label=f\"EMA Slow\", alpha=0.6, linewidth=0.8)\n","    if 'bbMiddle' in df.columns: ax1.plot(df['bbMiddle'], label='BB Mid', color='grey', linestyle='--', alpha=0.7, linewidth=0.8)\n","    if 'bbUpper' in df.columns: ax1.plot(df['bbUpper'], label='BB Upper', color='grey', linestyle=':', alpha=0.5, linewidth=0.8)\n","    if 'bbLower' in df.columns: ax1.plot(df['bbLower'], label='BB Lower', color='grey', linestyle=':', alpha=0.5, linewidth=0.8)\n","\n","    long_entries = df[df['signal'] == 'Long']; short_entries = df[df['signal'] == 'Short']\n","    long_exits = df[df['signal'].str.contains('Exit Long', na=False)]; short_exits = df[df['signal'].str.contains('Exit Short', na=False)]\n","    if not long_entries.empty: ax1.scatter(long_entries.index, long_entries['entry_price'], marker='^', color='lime', s=100, label='Long Entry', zorder=5, edgecolors='black')\n","    if not short_entries.empty: ax1.scatter(short_entries.index, short_entries['entry_price'], marker='v', color='red', s=100, label='Short Entry', zorder=5, edgecolors='black')\n","    exit_long_prices = long_exits['exit_price'].fillna(long_exits['close']); exit_short_prices = short_exits['exit_price'].fillna(short_exits['close'])\n","    if not long_exits.empty: ax1.scatter(long_exits.index, exit_long_prices, marker='x', color='fuchsia', s=80, label='Exit', zorder=5)\n","    if not short_exits.empty: ax1.scatter(short_exits.index, exit_short_prices, marker='x', color='fuchsia', s=80, zorder=5)\n","    if 'trailing_stop' in df.columns: ax1.plot(df['trailing_stop'], label='Trailing Stop', linestyle='--', color='purple', alpha=0.7, linewidth=1.0)\n","    # Add plot for Fib Target if needed (requires storing it in df)\n","    ax1.legend(loc='upper left'); ax1.set_title('Price, Indicators, Signals & Stops'); ax1.set_ylabel('Price'); ax1.grid(True, which='both', linestyle=':', linewidth=0.5)\n","\n","    ax_score = axes[1] # Score Chart\n","    if 'scaled_score' in df.columns:\n","        ax_score.plot(df['scaled_score'], label='Scaled Score (0-10)', color='teal', linewidth=1.5)\n","        ax_score.axhline(5.0, color='grey', linestyle='--', alpha=0.7)\n","        ax_score.set_ylim(0, 10); ax_score.legend(loc='upper left'); ax_score.set_title('Confidence Score'); ax_score.set_ylabel('Score'); ax_score.grid(True, which='both', linestyle=':', linewidth=0.5)\n","    else: ax_score.set_title('Confidence Score (Not Calculated)'); ax_score.grid(True)\n","\n","    ax_rsi = axes[2] # RSI Chart\n","    if 'priceRsi' in df.columns:\n","        ax_rsi.plot(df['priceRsi'], label='RSI', color='orange', linewidth=1.0)\n","        ax_rsi.axhline(50, linestyle='--', color='gray', alpha=0.5); ax_rsi.axhline(PARAMS['rsi']['rsiBuyLevel'], linestyle=':', color='green', alpha=0.4); ax_rsi.axhline(PARAMS['rsi']['rsiSellLevel'], linestyle=':', color='red', alpha=0.4)\n","        if 'bullish_rsi_div' in df.columns and 'bearish_rsi_div' in df.columns:\n","            bull_div = df[df['bullish_rsi_div']]; bear_div = df[df['bearish_rsi_div']]\n","            if not bull_div.empty: ax_rsi.scatter(bull_div.index, bull_div['priceRsi'] * 0.98, marker='^', color='cyan', s=50, label='Bullish Div', zorder=5)\n","            if not bear_div.empty: ax_rsi.scatter(bear_div.index, bear_div['priceRsi'] * 1.02, marker='v', color='magenta', s=50, label='Bearish Div', zorder=5)\n","        ax_rsi.legend(loc='upper left'); ax_rsi.set_title('RSI & Divergence'); ax_rsi.set_ylabel('RSI'); ax_rsi.grid(True, which='both', linestyle=':', linewidth=0.5)\n","    else: ax_rsi.set_title('RSI (Not Calculated)'); ax_rsi.grid(True)\n","\n","    ax_macd = axes[3] # MACD Chart\n","    if 'macdLine' in df.columns and 'signalLine' in df.columns and 'histLine' in df.columns:\n","        ax_macd.plot(df['macdLine'], label='MACD', color='blue', linewidth=1.0); ax_macd.plot(df['signalLine'], label='Signal', color='red', alpha=0.8, linewidth=1.0)\n","        colors = ['g' if v >= 0 else 'r' for v in df['histLine']]; ax_macd.bar(df.index, df['histLine'], label='Histogram', color=colors, alpha=0.5)\n","        ax_macd.axhline(0, linestyle='--', color='gray', alpha=0.5); ax_macd.legend(loc='upper left'); ax_macd.set_title('MACD'); ax_macd.set_ylabel('MACD'); ax_macd.grid(True, which='both', linestyle=':', linewidth=0.5)\n","    else: ax_macd.set_title('MACD (Not Calculated)'); ax_macd.grid(True)\n","\n","    axes[-1].tick_params(axis='x', rotation=45)\n","    plt.xlabel('Date')\n","    plt.tight_layout(rect=[0, 0.03, 1, 0.97])\n","    fig.suptitle('PineScript Strategy Backtest', fontsize=16)\n","\n","    if save_path: plt.savefig(save_path, dpi=150); logger.info(f\"Saved signal plot to {save_path}\")\n","    else: plt.show()\n","    plt.close(fig)\n","\n","# --- Command Line Argument Parsing ---\n","def parse_args():\n","    # Kept for potential local execution, but not used directly in Colab run block\n","    parser = argparse.ArgumentParser(description='Run PineScript-like strategy backtest.')\n","    parser.add_argument('--input', type=str, default=str(DEFAULT_INPUT_FILE), help=f'Input RAW OHLCV CSV (default: {DEFAULT_INPUT_FILE})')\n","    parser.add_argument('--output', type=str, default=str(DEFAULT_OUTPUT_FILE), help=f'Output CSV (default: {DEFAULT_OUTPUT_FILE})')\n","    parser.add_argument('--plot', type=str, default=str(DEFAULT_PLOT_FILE), help=f'Plot image path (default: {DEFAULT_PLOT_FILE})')\n","    parser.add_argument('--no-plot', action='store_true', help='Disable generating plot')\n","    parser.add_argument('--full-history', action='store_true', help='Run on full history')\n","    return parser.parse_args()\n","\n","# --- Main Execution Block ---\n","if __name__ == \"__main__\":\n","\n","    # --- Define Paths and Options Directly for Colab ---\n","    # V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V V\n","    # EDIT THESE LINES FOR YOUR COLAB SETUP:\n","    input_file = Path('/content/nifty_historical_data.csv') # <-- CHANGE 'nifty_ohlcv.csv' TO YOUR UPLOADED RAW OHLCV FILE NAME\n","    output_file = Path('/content/pinescript_strategy_py_output.csv') # Output file path in Colab\n","    plot_file = Path('/content/pinescript_strategy_py_plot.png') # Plot file path in Colab\n","    run_no_plot = False # Set to True if you DON'T want the plot image saved\n","    run_full_history = False # Set to True if you want to use ALL data, False for last month\n","    # ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^\n","\n","    try:\n","        output_file.parent.mkdir(parents=True, exist_ok=True)\n","        if not run_no_plot: plot_file.parent.mkdir(parents=True, exist_ok=True)\n","\n","        logger.info(f\"Loading data from {input_file}\")\n","        if not input_file.exists(): raise FileNotFoundError(f\"Input file not found: {input_file}. Make sure you uploaded it and the path is correct.\")\n","        df_raw = pd.read_csv(input_file, parse_dates=['datetime'], index_col='datetime')\n","        if df_raw.empty: raise pd.errors.EmptyDataError(\"Input file is empty.\")\n","        required_ohlcv = ['open', 'high', 'low', 'close', 'volume']\n","        if not all(col in df_raw.columns for col in required_ohlcv): raise ValueError(f\"Input CSV must contain OHLCV columns: {', '.join(required_ohlcv)}\")\n","\n","        logger.info(\"Calculating all indicators...\")\n","        calculator = IndicatorCalculator()\n","        df_with_indicators = calculator.calculate_all_indicators(df_raw)\n","        logger.info(f\"Indicators calculated. DataFrame shape: {df_with_indicators.shape}\")\n","        if df_with_indicators.empty:\n","             logger.warning(\"DataFrame empty after indicator calculation. Exiting.\")\n","             sys.exit(0)\n","\n","        # --- Filter Data ---\n","        df_processed = df_with_indicators # Start with indicator df\n","        if PARAMS['backtest']['filter_last_month'] and not run_full_history:\n","            if not df_processed.empty:\n","                last_date = df_processed.index.max(); one_month_prior = last_date - pd.DateOffset(months=1)\n","                df = df_processed.loc[one_month_prior:].copy()\n","                if df.empty: logger.warning(\"DataFrame empty after filtering for last month.\")\n","                else: logger.info(f\"Filtered data from {df.index.min().date()} to {df.index.max().date()}.\")\n","            else: df = df_processed\n","        else: df = df_processed.copy(); logger.info(f\"Using full data history from {df.index.min().date()} to {df.index.max().date()}.\")\n","\n","        if df.empty:\n","             logger.warning(\"DataFrame empty after filtering. Skipping signal processing.\")\n","             df_final = df # Keep df empty\n","        else:\n","            logger.info(\"Processing signals based on PineScript logic...\")\n","            df_final = process_signals(df) # Generate signals\n","\n","            # --- Basic Analysis (Optional - Analyzer class removed) ---\n","            trades_entered = df_final[df_final['signal'].isin(['Long', 'Short'])]\n","            trades_exited = df_final[df_final['signal'].str.contains('Exit', na=False)]\n","            logger.info(f\"Detected {len(trades_entered)} entry signals and {len(trades_exited)} exit signals in the processed period.\")\n","            # You would need to re-add the EnhancedSignalAnalyzer or similar logic here\n","            # if you want detailed performance stats printed.\n","\n","        logger.info(f\"Saving results to {output_file}\")\n","        df_final.to_csv(output_file) # Save df with signals & indicators\n","\n","        # --- Plotting ---\n","        if not run_no_plot and not df_final.empty:\n","            plot_signals(df_final, plot_file)\n","        elif not run_no_plot and df_final.empty:\n","             logger.warning(\"Plotting skipped as no data.\")\n","\n","        logger.info(\"Processing completed successfully\")\n","        # sys.exit(0) # Use return or just finish in Colab\n","\n","    except FileNotFoundError as e: logger.error(str(e))#; sys.exit(1)\n","    except pd.errors.EmptyDataError as e: logger.error(f\"Input file '{input_file}' empty/corrupt.\")#; sys.exit(1)\n","    except ValueError as e: logger.error(f\"Data validation error: {str(e)}\")#; sys.exit(1)\n","    except Exception as e: logger.error(f\"Unexpected error: {str(e)}\", exc_info=True)#; sys.exit(1)"],"outputs":[{"output_type":"error","ename":"SyntaxError","evalue":"invalid syntax (<ipython-input-4-e6c781ac453e>, line 447)","traceback":["\u001b[0;36m  File \u001b[0;32m\"<ipython-input-4-e6c781ac453e>\"\u001b[0;36m, line \u001b[0;32m447\u001b[0m\n\u001b[0;31m    if swingRangeFibExit > 0: trade_state.fibTargetLevelExit = entry_price_adj + swingRangeFibExit * PARAMS['fibonacci']['fibExtensionLevel']; else: trade_state.fibTargetLevelExit = np.nan\u001b[0m\n\u001b[0m                                                                                                                                               ^\u001b[0m\n\u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m invalid syntax\n"]}],"execution_count":4,"metadata":{"id":"-wpdm4Q8d_Gk","executionInfo":{"status":"error","timestamp":1743714711261,"user_tz":-330,"elapsed":110,"user":{"displayName":"CHANDRA SHEKHAR","userId":"04101457621295165703"}},"outputId":"b2ce60b9-8d5f-48cc-90d8-a26558f9d676","colab":{"base_uri":"https://localhost:8080/","height":124}}}],"metadata":{"colab":{"provenance":[]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}